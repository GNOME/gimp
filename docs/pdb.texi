\input texinfo   @c -*-texinfo-*-
@setfilename pdb.info
@settitle GIMP Procedural Database Documentation
@setchapternewpage on

@ifinfo
This file describes the GIMP procedural database.

Copyright (C) 1995, 1996, 1997 by Spencer Kimball and Peter Mattis.  All rights reserved.

We distribute @sc{gimp} under the terms of the GNU General Public
License, Version 2, which we have included with this release
in the file named @file{COPYING}, and in the ``Copying'' section of
this manual.
As indicated in the License,
we provide the program
``as is'' without warranty
of any kind, either expressed or implied, without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
@end ifinfo

@c @iftex
@c @hyphenation{Project-Header Project-Author Project-Date Project-Version}
@c @end iftex

@titlepage
@center @titlefont{GIMP: Procedural Database Documentation}
@sp 2
@center Spencer Kimball and Peter Mattis

@center eXperimental Computing Facility
@center The University of California at Berkeley
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1995, 1996, 1997 Spencer Kimball and Peter Mattis.

We distribute @sc{gimp} under the terms of the GNU General Public
License, Version 2, which we have included with this release
in the file named @file{COPYING}, and in the appendix to this manual.  As indicated in the License,
we provide the program
``as is'' without warranty
of any kind, either expressed or implied, without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
@end titlepage

@dircategory Elite Image Manipulation
@direntry
* GIMP!: (pdb).		The GIMP procedural database.
@end direntry

@node    Top, , (dir), (dir)

@ifinfo
This document is the procedural database documentation for @sc{The
GIMP}, the GNU Image Manipulation Program. The documentation is
automatically generated from help strings embedded in the code. It is
intended to provide information about the functionality, arguments and
return values for procedures in the procedural database.
@end ifinfo

@menu
* Commands::     All commands.
@end menu

@node    Commands, , Top, Top
@c 1
@chapter Commands

@defun Colorify run_mode, image, drawable, color
Makes an average of the RGB channels and uses it to set the color--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{color} (PDB_COLOR)--Color to apply
@end itemize
@end defun
@emph{Francisco Bustamante}

@defun extension_db_browser run_mode
--@strong{GIMP Extension}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, [non-interactive]
@end itemize
@end defun
@emph{Thomas Noel}

@defun extension_script_fu 
More help here later--@strong{GIMP Extension}@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun extension_script_fu_console run_mode
Provides an interface which allows interactive scheme development.--@strong{GIMP Extension}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, [non-interactive]
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun extension_script_fu_server run_mode, port, logfile
Provides a server for remote script-fu operation--@strong{GIMP Extension}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--[Interactive], non-interactive
@item @emph{port} (PDB_INT32)--The port on which to listen for requests
@item @emph{logfile} (PDB_STRING)--The file to log server activity to
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun file_bmp_load run_mode, filename, raw_filename
Loads files of Windows BMP file format--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Alexander Schulz}

@defun file_bmp_save run_mode, image, drawable, filename, raw_filename
Saves files in Windows BMP file format--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize
@end defun
@emph{Alexander Schulz}

@defun file_bz2_load run_mode, filename, raw_filename
You need to have bzip2 installed.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Daniel Risacher}

@defun file_bz2_save run_mode, image, drawable, filename, raw_filename
You need to have bzip2 installed--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@end itemize
@end defun
@emph{Daniel Risacher}

@defun file_cel_load run_mode, filename, raw_filename
This plug-in loads individual KISS cell files.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Nick Lamb}

@defun file_cel_save run_mode, image, drawable, filename, raw_filename
This plug-in saves individual KISS cell files.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@end itemize
@end defun
@emph{Nick Lamb}

@defun file_faxg3_load run_mode, filename, raw_filename
This plug-in loads Fax G3 Image files.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Jochen Friedrich}

@defun file_fits_load run_mode, filename, raw_filename
load file of the FITS file format (Flexible Image Transport System)--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Peter Kirchgessner}

@defun file_fits_save run_mode, image, drawable, filename, raw_filename
FITS saving handles all image types except those with alpha channels.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@end itemize
@end defun
@emph{Peter Kirchgessner}

@defun file_fli_load run_mode, filename, raw_filename
This is a experimantal plug-in to handle FLI movies--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Jens Ch. Restemeier}

@defun file_gbr_load run_mode, filename, raw_filename
FIXME: write help--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Tim Newsome}

@defun file_gbr_save run_mode, image, drawable, filename, raw_filename, spacing, description
Yeah!--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{spacing} (PDB_INT32)--Spacing of the brush
@item @emph{description} (PDB_STRING)--Short description of the brush
@end itemize
@end defun
@emph{Tim Newsome}

@defun file_gicon_load run_mode, filename, raw_filename
FIXME: write help--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Spencer Kimball}

@defun file_gicon_save run_mode, image, drawable, filename, raw_filename, icon_name
FIXME: write help--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{icon_name} (PDB_STRING)--The name of the icon
@end itemize
@end defun
@emph{Spencer Kimball}

@defun file_gif_load run_mode, filename, raw_filename
FIXME: write help for gif_load--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Spencer Kimball, Peter Mattis, Adam Moss, David Koblas}

@defun file_gif_save run_mode, image, drawable, filename, raw_filename, interlace, loop, default_delay, default_dispose
FIXME: write help for gif_save--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image to save
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name entered
@item @emph{interlace} (PDB_INT32)--Save as interlaced
@item @emph{loop} (PDB_INT32)--(animated gif) loop infinitely
@item @emph{default_delay} (PDB_INT32)--(animated gif) Default delay between framese in milliseconds
@item @emph{default_dispose} (PDB_INT32)--(animated gif) Default disposal type (0=`don't care`, 1=combine, 2=replace)
@end itemize
@end defun
@emph{Spencer Kimball, Peter Mattis, Adam Moss, David Koblas}

@defun file_gz_load run_mode, filename, raw_filename
You need to have gzip installed.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Daniel Risacher}

@defun file_gz_save run_mode, image, drawable, filename, raw_filename
You need to have gzip installed--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@end itemize
@end defun
@emph{Daniel Risacher}

@defun file_header_save run_mode, image, drawable, filename, raw_filename
FIXME: write help--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun file_hrz_load run_mode, filename, raw_filename
FIXME: write help for hrz_load--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Albert Cahalan}

@defun file_hrz_save run_mode, image, drawable, filename, raw_filename
HRZ saving handles all image types except those with alpha channels.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@end itemize
@end defun
@emph{Albert Cahalan}

@defun file_icon_load run_mode, filename, raw_filename
Loads files of Windows ICO file format--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Lance Dillon}

@defun file_icon_save run_mode, image, drawable, filename, raw_filename
Saves files in Windows ICO file format--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize
@end defun
@emph{Lance Dillon}

@defun file_jpeg_load run_mode, filename, raw_filename
FIXME: write help for jpeg_load--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun file_jpeg_save run_mode, image, drawable, filename, raw_filename, quality, smoothing, optimize
FIXME: write help for jpeg_save--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{quality} (PDB_FLOAT)--Quality of saved image (0 <= quality <= 1)
@item @emph{smoothing} (PDB_FLOAT)--Smoothing factor for saved image (0 <= smoothing <= 1)
@item @emph{optimize} (PDB_INT32)--Optimization of entropy encoding parameters
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun file_pat_load run_mode, filename, raw_filename
FIXME: write help--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Tim Newsome}

@defun file_pat_save run_mode, image, drawable, filename, raw_filename, description
Yeah!--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{description} (PDB_STRING)--Short description of the pattern
@end itemize
@end defun
@emph{Tim Newsome}

@defun file_pcx_load run_mode, filename, raw_filename
FIXME: write help for pcx_load--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Francisco Bustamante}

@defun file_pcx_save run_mode, image, drawable, filename, raw_filename
FIXME: write help for pcx_save--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize
@end defun
@emph{Francisco Bustamante}

@defun file_pix_load run_mode, filename, raw_filename
loads files of the PIX file format--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Michael Taylor}

@defun file_pix_save run_mode, image, drawable, filename, raw_filename
save file in the Alias|Wavefront pix/matte file format--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@end itemize
@end defun
@emph{Michael Taylor}

@defun file_png_load run_mode, filename, raw_filename
This plug-in loads Portable Network Graphics (PNG) files.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Michael Sweet <mike@@easysw.com>, Daniel Skarda <0rfelyus@@atrey.karlin.mff.cuni.cz>}

@defun file_png_save run_mode, image, drawable, filename, raw_filename, interlace, compression
This plug-in saves Portable Network Graphics (PNG) files.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{interlace} (PDB_INT32)--Save with interlacing option enabled
@item @emph{compression} (PDB_INT32)--Compression level
@end itemize
@end defun
@emph{Michael Sweet <mike@@easysw.com>, Daniel Skarda <0rfelyus@@atrey.karlin.mff.cuni.cz>}

@defun file_pnm_load run_mode, filename, raw_filename
FIXME: write help for pnm_load--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Erik Nygren}

@defun file_pnm_save run_mode, image, drawable, filename, raw_filename, raw
PNM saving handles all image types except those with alpha channels.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw} (PDB_INT32)--Specify non-zero for raw output, zero for ascii output
@end itemize
@end defun
@emph{Erik Nygren}

@defun file_print run_mode, image, drawable, output_to, driver, media_size, output_type, brightness, scaling, orientation, left, top
Prints images to PostScript, PCL, or ESC/P2 printers.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{output_to} (PDB_STRING)--Print command or filename (| to pipe to command)
@item @emph{driver} (PDB_STRING)--Printer driver short name
@item @emph{media_size} (PDB_INT32)--Media size (0 = A/letter, 1 = legal, 2 = B/tabloid, 3 = A4, 4 = A3)
@item @emph{output_type} (PDB_INT32)--Output type (0 = gray, 1 = color)
@item @emph{brightness} (PDB_INT32)--Brightness (0-200%)
@item @emph{scaling} (PDB_INT32)--Output scaling (0-100%)
@item @emph{orientation} (PDB_INT32)--Output orientation (-1 = auto, 0 = portrait, 1 = landscape)
@item @emph{left} (PDB_INT32)--Left offset (10ths inches, -1 = centered)
@item @emph{top} (PDB_INT32)--Top offset (10ths inches, -1 = centered)
@end itemize
@end defun
@emph{Michael Sweet <mike@@easysw.com>}

@defun file_ps_load run_mode, filename, raw_filename
load file of PostScript/PDF file format--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Peter Kirchgessner <pkirchg@@aol.com>}

@defun file_ps_load_setargs resolution, width, height, check_bbox, pages, coloring, TextAlphaBits, GraphicsAlphaBits
set additional parameters for procedure file_ps_load--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{resolution} (PDB_INT32)--Resolution to interprete image (dpi)
@item @emph{width} (PDB_INT32)--Desired width
@item @emph{height} (PDB_INT32)--Desired height
@item @emph{check_bbox} (PDB_INT32)--0: Use width/height, 1: Use BoundingBox
@item @emph{pages} (PDB_STRING)--Pages to load (e.g.: 1,3,5-7)
@item @emph{coloring} (PDB_INT32)--4: b/w, 5: grey, 6: colour image, 7: automatic
@item @emph{TextAlphaBits} (PDB_INT32)--1, 2, or 4
@item @emph{GraphicsAlphaBits} (PDB_INT32)--1, 2, or 4
@end itemize
@end defun
@emph{Peter Kirchgessner <pkirchg@@aol.com>}

@defun file_ps_save run_mode, image, drawable, filename, raw_filename, width, height, x_offset, y_offset, unit, keep_ratio, rotation, eps_flag, preview
PostScript saving handles all image types except those with alpha channels.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{width} (PDB_FLOAT)--Width of the image in PostScript file
@item @emph{height} (PDB_FLOAT)--Height of image in PostScript file
@item @emph{x_offset} (PDB_FLOAT)--X-offset to image from lower left corner
@item @emph{y_offset} (PDB_FLOAT)--Y-offset to image from lower left corner
@item @emph{unit} (PDB_INT32)--Unit for width/height/offset. 0: inches, 1: millimeters
@item @emph{keep_ratio} (PDB_INT32)--0: use width/height, 1: keep aspect ratio
@item @emph{rotation} (PDB_INT32)--0, 90, 180, 270
@item @emph{eps_flag} (PDB_INT32)--0: PostScript, 1: Encapsulated PostScript
@item @emph{preview} (PDB_INT32)--0: no preview, >0: max. size of preview
@end itemize
@end defun
@emph{Peter Kirchgessner <pkirchg@@aol.com>}

@defun file_psd_load run_mode, filename, raw_filename
FIXME: write help for psd_load--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Adam D. Moss & Torsten Martinsen}

@defun file_sgi_load run_mode, filename, raw_filename
This plug-in loads SGI image files.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Michael Sweet <mike@@easysw.com>}

@defun file_sgi_save run_mode, image, drawable, filename, raw_filename, compression
This plug-in saves SGI image files.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{compression} (PDB_INT32)--Compression level (0 = none, 1 = RLE, 2 = ARLE)
@end itemize
@end defun
@emph{Michael Sweet <mike@@easysw.com>}

@defun file_snp_load run_mode, filename, raw_filename
FIXME: write help for snp_load--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Adam D. Moss}

@defun file_sunras_load run_mode, filename, raw_filename
load file of the SunRaster file format--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Peter Kirchgessner}

@defun file_sunras_save run_mode, image, drawable, filename, raw_filename, rle
SUNRAS saving handles all image types except those with alpha channels.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{rle} (PDB_INT32)--Specify non-zero for rle output, zero for standard output
@end itemize
@end defun
@emph{Peter Kirchgessner}

@defun file_tga_load run_mode, filename, raw_filename
FIXME: write help for tga_load--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Raphael FRANCOIS, Gordon Matzigkeit}

@defun file_tga_save run_mode, image, drawable, filename, raw_filename, rle
FIXME: write help for tga_save--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{rle} (PDB_INT32)--Enable RLE compression
@end itemize
@end defun
@emph{Raphael FRANCOIS, Gordon Matzigkeit}

@defun file_tiff_load run_mode, filename, raw_filename
FIXME: write help for tiff_load--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun file_tiff_save run_mode, image, drawable, filename, raw_filename, compression, fillorder
FIXME: write help for tiff_save--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{compression} (PDB_INT32)--Compression type: @{ NONE (0), LZW (1), PACKBITS (2)
@item @emph{fillorder} (PDB_INT32)--Fill Order: @{ MSB to LSB (0), LSB to MSB (1)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun file_url_load run_mode, filename, raw_filename
You need to have GNU Wget installed.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun file_xpm_load run_mode, filename, raw_filename
FIXME: write help for xpm_load--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name entered
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis & Ray Lehtiniemi}

@defun file_xpm_save run_mode, image, drawable, filename, raw_filename, alpha_threshold
FIXME: write help for xpm--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{alpha_threshold} (PDB_FLOAT)--Alpha cutoff threshold
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis & Ray Lehtiniemi}

@defun file_xwd_load run_mode, filename, raw_filename
load file of the XWD file format--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Peter Kirchgessner}

@defun file_xwd_save run_mode, image, drawable, filename, raw_filename
XWD saving handles all image types except those with alpha channels.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@end itemize
@end defun
@emph{Peter Kirchgessner}

@defun gimp_airbrush image, drawable, pressure, num_strokes, strokes
This tool simulates the use of an airbrush.  Paint pressure represents the relative intensity of the paint application.  High pressure results in a thicker layer of paint while low pressure results in a thinner layer.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{pressure} (PDB_FLOAT)--The pressure of the airbrush strokes: 0 <= pressure <= 100
@item @emph{num_strokes} (PDB_INT32)--Number of stroke control points (count each coordinate as 2 points)
@item @emph{strokes} (PDB_FLOATARRAY)--Array of stroke coordinates: @{s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y@}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_blend image, drawable, blend_mode, paint_mode, gradient_type, opacity, offset, repeat, supersample, max_depth, threshold, x1, y1, x2, y2
This tool requires information on the paint application mode, the blend mode, and the gradient type.  It creates the specified variety of blend using the starting and ending coordinates as defined for each gradient type.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The affected drawable
@item @emph{blend_mode} (PDB_INT32)--The type of blend: @{ FG-BG-RGB (0), FG-BG-HSV (1), FG-TRANS (2), CUSTOM (3) @}
@item @emph{paint_mode} (PDB_INT32)--The paint application mode: @{ NORMAL (0), DISSOLVE (1), BEHIND (2), MULTIPLY (3), SCREEN (4), OVERLAY (5) DIFFERENCE (6), ADDITION (7), SUBTRACT (8), DARKEN-ONLY (9), LIGHTEN-ONLY (10), HUE (11), SATURATION (12), COLOR (13), VALUE (14) @}
@item @emph{gradient_type} (PDB_INT32)--The type of gradient: @{ LINEAR (0), BILINEAR (1), RADIAL (2), SQUARE (3), CONICAL-SYMMETRIC (4), CONICAL-ASYMMETRIC (5), SHAPEBURST-ANGULAR (6), SHAPEBURST-SPHERICAL (7), SHAPEBURST-DIMPLED (8) @}
@item @emph{opacity} (PDB_FLOAT)--The opacity of the final blend (0 <= opacity <= 100)
@item @emph{offset} (PDB_FLOAT)--Offset relates to the starting and ending coordinates specified for the blend.  This parameter is mode depndent (0 <= offset)
@item @emph{repeat} (PDB_INT32)--Repeat mode: @{ REPEAT-NONE (0), REPEAT-SAWTOOTH (1), REPEAT-TRIANGULAR (2) @}
@item @emph{supersample} (PDB_INT32)--Do adaptive supersampling (true / false)
@item @emph{max_depth} (PDB_INT32)--Maximum recursion levels for supersampling
@item @emph{threshold} (PDB_FLOAT)--Supersampling threshold
@item @emph{x1} (PDB_FLOAT)--The x coordinate of this blend's starting point
@item @emph{y1} (PDB_FLOAT)--The y coordinate of this blend's starting point
@item @emph{x2} (PDB_FLOAT)--The x coordinate of this blend's ending point
@item @emph{y2} (PDB_FLOAT)--The y coordinate of this blend's ending point
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis & Federico Mena Quintero}

@defun gimp_brightness_contrast image, drawable, brightness, contrast
This procedures allows the brightness and contrast of the specified drawable to be modified.  Both 'brightness' and 'contrast' parameters are defined between -127 and 127.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{brightness} (PDB_INT32)--Brightness adjustment: (-127 <= brightness <= 127)
@item @emph{contrast} (PDB_INT32)--Constrast adjustment: (-127 <= contrast <= 127)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_brushes_get_brush 
This procedure retrieves information about the currently active brush mask.  This includes the brush name, the width and height, and the brush spacing paramter.  All paint operations and stroke operations use this mask to control the application of paint to the image.--@strong{Internal GIMP procedure}

@strong{Outputs}
@itemize @bullet
@item @emph{name} (PDB_STRING)--The brush name
@item @emph{width} (PDB_INT32)--The brush width
@item @emph{height} (PDB_INT32)--The brush height
@item @emph{spacing} (PDB_INT32)--The brush spacing: (% of MAX [width, height])
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_brushes_get_opacity 
This procedure returns the opacity setting for brushes.  This value is set globally and will remain the same even if the brush mask is changed.  The return value is a floating point number between 0 and 100.--@strong{Internal GIMP procedure}

@strong{Outputs}
@itemize @bullet
@item @emph{opacity} (PDB_FLOAT)--The brush opacity: 0 <= opacity <= 100
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_brushes_get_paint_mode 
This procedure returns the paint-mode setting for brushes.  This value is set globally and will not change if a different brush is selected.  The return value is an integer between 0 and 13 which corresponds to the values listed in the argument description.--@strong{Internal GIMP procedure}

@strong{Outputs}
@itemize @bullet
@item @emph{paint_mode} (PDB_INT32)--The paint mode: @{ NORMAL (0), DISSOLVE (1), BEHIND (2), MULTIPLY (3), SCREEN (4), OVERLAY (5) DIFFERENCE (6), ADDITION (7), SUBTRACT (8), DARKEN-ONLY (9), LIGHTEN-ONLY (10), HUE (11), SATURATION (12), COLOR (13), VALUE (14) @}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_brushes_get_spacing 
This procedure returns the spacing setting for brushes.  This value is set per brush and will change if a different brush is selected.  The return value is an integer between 0 and 1000 which represents percentage of the maximum of the width and height of the mask.--@strong{Internal GIMP procedure}

@strong{Outputs}
@itemize @bullet
@item @emph{spacing} (PDB_INT32)--The brush spacing: 0 <= spacing <= 1000
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_brushes_list 
This procedure returns a complete listing of available GIMP brushes.  Each name returned can be used as input to the 'gimp_brushes_set_brush'--@strong{Internal GIMP procedure}

@strong{Outputs}
@itemize @bullet
@item @emph{num_brushes} (PDB_INT32)--The number of brushes in the brush list
@item @emph{brush_list} (PDB_STRINGARRAY)--The list of brush names
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_brushes_refresh 
This procedure retrieves all brushes currently in the user's brush path and updates the brush dialog accordingly.--@strong{Internal GIMP procedure}@end defun
@emph{Seth Burgess<sjburges@@ou.edu>}

@defun gimp_brushes_set_brush name
This procedure allows the active brush mask to be set by specifying its name.  The name is simply a string which corresponds to one of the names of the installed brushes.  If there is no matching brush found, this procedure will return an error.  Otherwise, the specified brush becomes active and will be used in all subsequent paint operations.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{name} (PDB_STRING)--The brush name
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_brushes_set_opacity opacity
This procedure modifies the opacity setting for brushes.  This value is set globally and will remain the same even if the brush mask is changed.  The value should be a floating point number between 0 and 100.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{opacity} (PDB_FLOAT)--The brush opacity: 0 <= opacity <= 100
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_brushes_set_paint_mode paint_mode
This procedure modifies the paint_mode setting for the current brush.  This value is set globally and will not change if a different brush mask is selected.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{paint_mode} (PDB_INT32)--The paint mode: @{ NORMAL (0), DISSOLVE (1), BEHIND (2), MULTIPLY (3), SCREEN (4), OVERLAY (5) DIFFERENCE (6), ADDITION (7), SUBTRACT (8), DARKEN-ONLY (9), LIGHTEN-ONLY (10), HUE (11), SATURATION (12), COLOR (13), VALUE (14) @}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_brushes_set_spacing spacing
This procedure modifies the spacing setting for the current brush.  This value is set on a per-brush basis and will change if a different brush mask is selected.  The value should be a integer between 0 and 1000.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{spacing} (PDB_INT32)--The brush spacing: 0 <= spacing <= 1000
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_bucket_fill image, drawable, fill_mode, paint_mode, opacity, threshold, sample_merged, x, y
This tool requires information on the paint application mode, and the fill mode, which can either be in the foreground color, or in the currently active pattern.  If there is no selection, a seed fill is executed at the specified coordinates and extends outward in keeping with the threshold parameter.  If there is a selection in the target image, the threshold, sample merged, x, and y arguments are unused.  If the sample_merged parameter is non-zero, the data of the composite image will be used instead of that for the specified drawable.  This is equivalent to sampling for colors after merging all visible layers.  In the case of merged sampling, the x,y coordinates are relative to the image's origin; otherwise, they are relative to the drawable's origin.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The affected drawable
@item @emph{fill_mode} (PDB_INT32)--The type of fill: @{ FG-BUCKET-FILL (0), BG-BUCKET-FILL (1), PATTERN-BUCKET-FILL (2) @}
@item @emph{paint_mode} (PDB_INT32)--The paint application mode: @{ NORMAL (0), DISSOLVE (1), BEHIND (2), MULTIPLY (3), SCREEN (4), OVERLAY (5) DIFFERENCE (6), ADDITION (7), SUBTRACT (8), DARKEN-ONLY (9), LIGHTEN-ONLY (10), HUE (11), SATURATION (12), COLOR (13), VALUE (14) @}
@item @emph{opacity} (PDB_FLOAT)--The opacity of the final bucket fill (0 <= opacity <= 100)
@item @emph{threshold} (PDB_FLOAT)--The threshold determines how extensive the seed fill will be.  It's value is specified in terms of intensity levels (0 <= threshold <= 255).  This parameter is only valid when there is no selection in the specified image.
@item @emph{sample_merged} (PDB_INT32)--Use the composite image, not the drawable
@item @emph{x} (PDB_FLOAT)--The x coordinate of this bucket fill's application.  This parameter is only valid when there is no selection in the specified image.
@item @emph{y} (PDB_FLOAT)--The y coordinate of this bucket fill's application.  This parameter is only valid when there is no selection in the specified image.
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_by_color_select image, drawable, color, threshold, operation, antialias, feather, feather_radius, sample_merged
This tool creates a selection over the specified image.  A by-color selection is determined by the supplied color under the constraints of the specified threshold.  Essentially, all pixels (in the drawable) that have color sufficiently close to the specified color (as determined by the threshold value) are included in the selection.  The antialiasing parameter allows the final selection mask to contain intermediate values based on close misses to the threshold bar.  Feathering can be enabled optionally and is controlled with the "feather_radius" paramter.  If the sample_merged parameter is non-zero, the data of the composite image will be used instead of that for the specified drawable.  This is equivalent to sampling for colors after merging all visible layers.  In the case of a merged sampling, the supplied drawable is ignored.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{color} (PDB_COLOR)--The color to select
@item @emph{threshold} (PDB_INT32)--Threshold in intensity levels: 0 <= threshold <= 255
@item @emph{operation} (PDB_INT32)--The selection operation: @{ ADD (0), SUB (1), REPLACE (2), INTERSECT (3) @}
@item @emph{antialias} (PDB_INT32)--Antialiasing On/Off
@item @emph{feather} (PDB_INT32)--Feather option for selections
@item @emph{feather_radius} (PDB_FLOAT)--Radius for feather operation
@item @emph{sample_merged} (PDB_INT32)--Use the composite image, not the drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_copy channel
This procedure copies the specified channel and returns the copy.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The channel to copy
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{channel_copy} (PDB_CHANNEL)--The newly copied channel
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_delete channel
This procedure deletes the specified channel.  This does not need to be done if a gimage containing this channel was already deleted.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The channel to delete
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_get_color channel
This procedure returns the specified channel's compositing color.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The channel
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{color} (PDB_COLOR)--The channel's composite color
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_get_name channel
This procedure returns the specified channel's name.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The channel
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{name} (PDB_STRING)--The channel name
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_get_opacity channel
This procedure returns the specified channel's opacity.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The channel
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{opacity} (PDB_FLOAT)--The channel opacity
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_get_show_masked channel
This procedure returns the specified channel's composite type.  If it is non-zero, then the channel is composited with the image so that masked regions are shown.  Otherwise, selected regions are shown.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The channel
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{show_masked} (PDB_INT32)--Composite method for channel
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_get_visible channel
This procedure returns the specified channel's visibility.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The channel
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{visible} (PDB_INT32)--The channel visibility
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_new image, width, height, name, opacity, color
This procedure creates a new channel with the specified width and height.  Name, opacity, and color are also supplied parameters.  The new channel still needs to be added to the image, as this is not automatic.  Add the new channel with the 'gimp_image_add_channel' command.  Other attributes such as channel show masked, should be set with explicit procedure calls.  The channel's contents are undefined initially.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image to which to add the channel
@item @emph{width} (PDB_INT32)--The channel width: (width > 0)
@item @emph{height} (PDB_INT32)--The channel height: (height > 0)
@item @emph{name} (PDB_STRING)--The channel name
@item @emph{opacity} (PDB_FLOAT)--The channel opacity: (0 <= opacity <= 100)
@item @emph{color} (PDB_COLOR)--The channel compositing color
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The newly created channel
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_ops_duplicate image
This procedure duplicates the specified image, copying all layers, channels, and image information.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{new_image} (PDB_IMAGE)--The new, duplicated image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_ops_offset image, drawable, wrap_around, fill_type, offset_x, offset_y
This procedure offsets the specified drawable by the amounts specified by 'offset_x' and 'offset_y'.  If 'wrap_around' is set to TRUE, then portions of the drawable which are offset out of bounds are wrapped around.  Alternatively, the undefined regions of the drawable can be filled with transparency or the background color, as specified by the 'fill_type' parameter.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable to offset
@item @emph{wrap_around} (PDB_INT32)--Wrap image around or fill vacated regions
@item @emph{fill_type} (PDB_INT32)--Fill vacated regions of drawable with background or transparent: @{ OFFSET_BACKGROUND (0), OFFSET_TRANSPARENT (1) @}
@item @emph{offset_x} (PDB_INT32)--Offset by this amount in X direction
@item @emph{offset_y} (PDB_INT32)--Offset by this amount in Y direction
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_set_color channel, color
This procedure sets the specified channel's compositing color.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The channel
@item @emph{color} (PDB_COLOR)--The composite color
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_set_name channel, name
This procedure sets the specified channel's name to the supplied name.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The channel
@item @emph{name} (PDB_STRING)--The new channel name
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_set_opacity channel, opacity
This procedure sets the specified channel's opacity.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The channel
@item @emph{opacity} (PDB_FLOAT)--The new channel opacity: (0 <= opacity <= 100)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_set_show_masked channel, show_masked
This procedure sets the specified channel's composite type.  If it is non-zero, then the channel is composited with the image so that masked regions are shown.  Otherwise, selected regions are shown.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The channel
@item @emph{show_masked} (PDB_INT32)--The new channel show_masked value
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_channel_set_visible channel, visible
This procedure sets the specified channel's visibility.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The channel
@item @emph{visible} (PDB_INT32)--The new channel visibility
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_clone image, drawable, src_drawable, clone_type, src_x, src_y, num_strokes, strokes
This tool clones (copies) from the source drawable starting at the specified source coordinates to the dest drawable.  If the "clone_type" argument is set to PATTERN-CLONE, then the current pattern is used as the source and the "src_drawable" argument is ignored.  Pattern cloning assumes a tileable pattern and mods the sum of the src coordinates and subsequent stroke offsets with the width and height of the pattern.  For image cloning, if the sum of the src coordinates and subsequent stroke offsets exceeds the extents of the src drawable, then no paint is transferred.  The clone tool is capable of transforming between any image types including RGB->Indexed--although converting from any type to indexed is significantly slower.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{src_drawable} (PDB_DRAWABLE)--The source drawable
@item @emph{clone_type} (PDB_INT32)--The type of clone: @{ IMAGE-CLONE (0), PATTERN-CLONE (1) @}
@item @emph{src_x} (PDB_FLOAT)--The x coordinate in the source image
@item @emph{src_y} (PDB_FLOAT)--The y coordinate in the source image
@item @emph{num_strokes} (PDB_INT32)--Number of stroke control points (count each coordinate as 2 points)
@item @emph{strokes} (PDB_FLOATARRAY)--Array of stroke coordinates: @{s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y@}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_color_balance image, drawable, transfer_mode, preserve_lum, cyan_red, magenta_green, yellow_blue
Modify the color balance of the specified drawable.  There are three axis which can be modified: cyan-red, magenta-green, and yellow-blue.  Negative values increase the amount of the former, positive values increase the amount of the latter.  Color balance can be controlled with the 'transfer_mode' setting, which allows shadows, midtones, and highlights in an image to be affected differently.  The 'preserve_lum' parameter, if non-zero, ensures that the luminosity of each pixel remains fixed.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{transfer_mode} (PDB_INT32)--Transfer mode: @{ SHADOWS (0), MIDTONES (1), HIGHLIGHTS (2) @}
@item @emph{preserve_lum} (PDB_INT32)--Preserve luminosity values at each pixel
@item @emph{cyan_red} (PDB_FLOAT)--Cyan-Red color balance: (-100 <= cyan_red <= 100)
@item @emph{magenta_green} (PDB_FLOAT)--Magenta-Green color balance: (-100 <= magenta_green <= 100)
@item @emph{yellow_blue} (PDB_FLOAT)--Yellow-Blue color balance: (-100 <= yellow_blue <= 100)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_color_picker image, drawable, x, y, sample_merged, save_color
This tool determines the color at the specified coordinates.  The returned color is an RGB triplet even for grayscale and indexed drawables.  If the coordinates lie outside of the extents of the specified drawable, then an error is returned.  If the drawable has an alpha channel, the algorithm examines the alpha value of the drawable at the coordinates.  If the alpha value is completely transparent (0), then an error is returned.  If the sample_merged parameter is non-zero, the data of the composite image will be used instead of that for the specified drawable.  This is equivalent to sampling for colors after merging all visible layers.  In the case of a merged sampling, the supplied drawable is ignored.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{x} (PDB_FLOAT)--X coordinate of upper-left corner of rectangle
@item @emph{y} (PDB_FLOAT)--Y coordinate of upper-left corner of rectangle
@item @emph{sample_merged} (PDB_INT32)--Use the composite image, not the drawable
@item @emph{save_color} (PDB_INT32)--Save the color to the active palette
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{color} (PDB_COLOR)--The return color
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_convert_grayscale image
This procedure converts the specified image to grayscale with 8 bits per pixel (256 intensity levels).  This process requires an image of type RGB or INDEXED.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_convert_indexed image, dither, num_cols
This procedure converts the specified image to indexed color.  This process requires an image of type GRAY or RGB.  The 'num_cols' arguments specifies how many colors the resulting image should be quantized to (1-256).--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{dither} (PDB_INT32)--Floyd-Steinberg dithering
@item @emph{num_cols} (PDB_INT32)--The number of colors to quantize to
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_convert_indexed_palette image, dither, palette_type, num_cols, palette
This procedure converts the specified image to indexed color.  This process requires an image of type GRAY or RGB.  The `palette_type' specifies what kind of palette to use, A type of `0' means to use an optimal palette of `num_cols' generated from the colors in the image.  A type of `1' means to re-use the previous palette.  A type of `2' means to use the WWW-optimized palette.  Type `3' means to use only black and white colors.  A type of `4' means to use a palette from the gimp palettes directories.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{dither} (PDB_INT32)--Floyd-Steinberg dithering
@item @emph{palette_type} (PDB_INT32)--The type of palette to use, (0 optimal) (1 reuse) (2 WWW) (3 Mono) (4 Custom)
@item @emph{num_cols} (PDB_INT32)--The number of colors to quantize to, ignored unless (palette_type == 0)
@item @emph{palette} (PDB_STRING)--The name of the custom palette to use, ignored unless (palette_type == 4)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_convert_rgb image
This procedure converts the specified image to RGB color.  This process requires an image of type GRAY or INDEXED.  No image content is lost in this process aside from the colormap for an indexed image.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_convolve image, drawable, pressure, convolve_type, num_strokes, strokes
This tool convolves the specified drawable with either a sharpening or blurring kernel.  The pressure parameter controls the magnitude of the operation.  Like the paintbrush, this tool linearly interpolates between the specified stroke coordinates.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{pressure} (PDB_FLOAT)--The pressure: 0 <= pressure <= 100
@item @emph{convolve_type} (PDB_INT32)--Convolve type: @{ BLUR (0), SHARPEN (1) @}
@item @emph{num_strokes} (PDB_INT32)--Number of stroke control points (count each coordinate as 2 points)
@item @emph{strokes} (PDB_FLOATARRAY)--Array of stroke coordinates: @{s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y@}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_crop image, new_width, new_height, offx, offy
This procedure crops the image so that it's new width and height are equal to the supplied parameters.  Offsets are also provided which describe the position of the previous image's content.  All channels and layers within the image are cropped to the new image extents; this includes the image selection mask.  If any parameters are out of range, an error is returned.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{new_width} (PDB_INT32)--New image width: (0 < new_width <= width)
@item @emph{new_height} (PDB_INT32)--New image height: (0 < new_height <= height)
@item @emph{offx} (PDB_INT32)--X offset: (0 <= offx <= (width - new_width))
@item @emph{offy} (PDB_INT32)--Y offset: (0 <= offy <= (height - new_height))
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_curves_explicit image, drawable, channel, num_bytes, curve
Modifies the intensity mapping for one channel in the specified drawable.  The drawable must be either grayscale or RGB, and the channel can be either an intensity component, or the value.  The 'curve' parameter is an array of bytes which explicitly defines how each pixel value in the drawable will be modified.  Use the 'gimp_curves_spline' function to modify intensity levels with Catmull Rom splines.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{channel} (PDB_INT32)--The channel to modify: @{ VALUE (0), RED (1), GREEN (2), BLUE (3), GRAY (0) @}
@item @emph{num_bytes} (PDB_INT32)--The number of bytes in the new curve (always 256)
@item @emph{curve} (PDB_INT8ARRAY)--The explicit curve
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_curves_spline image, drawable, channel, num_points, control_pts
Modifies the intensity mapping for one channel in the specified drawable.  The drawable must be either grayscale or RGB, and the channel can be either an intensity component, or the value.  The 'control_pts' parameter is an array of integers which define a set of control points which describe a Catmull Rom spline which yields the final intensity curve.  Use the 'gimp_curves_explicit' function to explicitly modify intensity levels.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{channel} (PDB_INT32)--The channel to modify: @{ VALUE (0), RED (1), GREEN (2), BLUE (3), ALPHA (4), GRAY (0) @}
@item @emph{num_points} (PDB_INT32)--The number of values in the control point array ( 3 < num_points <= 32 )
@item @emph{control_pts} (PDB_INT8ARRAY)--The spline control points: @{ cp1.x, cp1.y, cp2.x, cp2.y, ... @}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_desaturate image, drawable
This procedure desaturates the contents of the specified drawable.  This procedure only works on drawables of type RGB color.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_display_delete display
This procedure removes the specified display.  If this is the last remaining display for the underlying image, then the image is deleted also.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{display} (PDB_DISPLAY)--The display
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_display_new image
Creates a new display for the specified image.  If the image already has a display, another is added.  Multiple displays are handled transparently by the GIMP.  The newly created display is returned and can be subsequently destroyed with a call to 'gimp_display_delete'.  This procedure only makes sense for use with the GIMP UI.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{display} (PDB_DISPLAY)--The new display
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_displays_flush 
This procedure takes no arguments and returns nothing except a success status.  Its purpose is to flush all pending updates of image manipulations to the user interface.  It should be called whenever appropriate.--@strong{Internal GIMP procedure}@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_bytes drawable
This procedure returns the number of bytes per pixel (or the number of channels) for the specified drawable.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{bytes} (PDB_INT32)--Bytes per pixel
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_channel drawable
This procedure returns non-zero if the specified drawable is a channel.  Even though a layer mask is technically considered a channel, this call will return 0 on a layer mask.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{channel} (PDB_INT32)--Non-zero if the drawable is a channel
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_color drawable
This procedure returns non-zero if the specified drawable is of type @{ RGB, RGBA @}.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{color} (PDB_INT32)--Non-zero if the drawable is an RGB type
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_fill drawable, fill_type
This procedure fills the drawable with the fill mode.  If the fill mode is background, the current background color is used.  If the fill type is white, then white is used.  Transparent fill only affects layers with an alpha channel, in which case the alpha channel is set to transparent.  If the drawable has no alpha channel, it is filled to white.  No fill leaves the drawable's contents undefined.  This procedure is unlike the bucket fill tool because it fills regardless of a selection--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{fill_type} (PDB_INT32)--Type of fill: @{ BG-IMAGE-FILL (0), WHITE-IMAGE-FILL (1), TRANS-IMAGE-FILL (2) @}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_get_pixel drawable, x coordinate, y coordinate
This procedure gets the pixel value at the specified coordinates.  The 'num_channels' argument must always be equal to the bytes-per-pixel value for the specified drawable.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{x coordinate} (PDB_INT32)--The x coordinate
@item @emph{y coordinate} (PDB_INT32)--The y coordinate
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{num_channels} (PDB_INT32)--The number of channels for the pixel
@item @emph{pixel} (PDB_INT8ARRAY)--The pixel value
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis & Josh MacDonald}

@defun gimp_drawable_gray drawable
This procedure returns non-zero if the specified drawable is of type @{ Gray, GrayA @}.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{gray} (PDB_INT32)--Non-zero if the drawable is a grayscale type
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_has_alpha drawable
This procedure returns whether the specified drawable has an alpha channel.  This can only be true for layers, and the associated type will be one of: @{ RGBA, GRAYA, INDEXEDA @}.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{has_alpha} (PDB_INT32)--Does the drawable have an alpha channel?
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_height drawable
This procedure returns the height of the specified drawable in pixels--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{height} (PDB_INT32)--Height of drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_image drawable
This procedure returns the drawable's image.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The drawable's image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_indexed drawable
This procedure returns non-zero if the specified drawable is of type @{ Indexed, IndexedA @}.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{indexed} (PDB_INT32)--Non-zero if the drawable is a indexed type
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_layer drawable
This procedure returns non-zero if the specified drawable is a layer.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{layer} (PDB_INT32)--Non-zero if the drawable is a layer
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_layer_mask drawable
This procedure returns non-zero if the specified drawable is a layer mask.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{layer_mask} (PDB_INT32)--Non-zero if the drawable is a layer mask
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_mask_bounds drawable
This procedure returns the whether there is a selection.  If there is one, the upper left and lower righthand corners of its bounding box are returned.  These coordinates are specified relative to the drawable's origin, and bounded by the drawable's extents.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{non-empty} (PDB_INT32)--True if there is a selection
@item @emph{x1} (PDB_INT32)--X coordinate of upper left corner of selection bounds
@item @emph{y1} (PDB_INT32)--Y coordinate of upper left corner of selection bounds
@item @emph{x2} (PDB_INT32)--X coordinate of lower right corner of selection bounds
@item @emph{y2} (PDB_INT32)--Y coordinate of lower right corner of selection bounds
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_merge_shadow drawable, undo
This procedure combines the contents of the image's shadow buffer (for temporary processing) with the specified drawable.  The "undo" parameter specifies whether to add an undo step for the operation.  Requesting no undo is useful for such applications as 'auto-apply'.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{undo} (PDB_INT32)--Push merge to undo stack?
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_offsets drawable
This procedure returns the specified drawable's offsets.  This only makes sense if the drawable is a layer since channels are anchored.  The offsets of a channel will be returned as 0.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{offset_x} (PDB_INT32)--X offset of drawable
@item @emph{offset_y} (PDB_INT32)--Y offset of drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_set_pixel drawable, x coordinate, y coordinate, num_channels, pixel
This procedure sets the pixel value at the specified coordinates.  The 'num_channels' argument must always be equal to the bytes-per-pixel value for the specified drawable.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{x coordinate} (PDB_INT32)--The x coordinate
@item @emph{y coordinate} (PDB_INT32)--The y coordinate
@item @emph{num_channels} (PDB_INT32)--The number of channels for the pixel
@item @emph{pixel} (PDB_INT8ARRAY)--The pixel value
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis & Josh MacDonald}

@defun gimp_drawable_type drawable
This procedure returns the drawable's type.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{type} (PDB_INT32)--The drawable's type: @{ RGB (0), RGBA (1), GRAY (2), GRAYA (3), INDEXED (4), INDEXEDA (5) @}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_type_with_alpha drawable
This procedure returns the drawable's type if an alpha channel were added.  If the type is currently Gray, for instance, the returned type would be GrayA.  If the drawable already has an alpha channel, the drawable's type is simply returned.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{type_with_alpha} (PDB_INT32)--The drawable's type with alpha: @{ RGBA (0), GRAYA (1), INDEXEDA (2) @}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_update drawable, x, y, w, h
This procedure updates the specified region of the drawable.  The (x, y) coordinate pair is relative to the drawable's origin, not to the image origin.  Therefore, the entire drawable can be updated with: @{x->0, y->0, w->width, h->height@}.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{x} (PDB_INT32)--X coordinate of upper left corner of update region
@item @emph{y} (PDB_INT32)--Y coordinate of upper left corner of update region
@item @emph{w} (PDB_INT32)--Width of update region
@item @emph{h} (PDB_INT32)--Height of update region
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_drawable_width drawable
This procedure returns the specified drawable's width in pixels.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{width} (PDB_INT32)--Width of drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_edit_clear image, drawable
This procedure clears the specified drawable.  If the drawable has an alpha channel, the cleared pixels will become transparent.  If the drawable does not have an alpha channel, cleared pixels will be set to the background color.  This procedure only affects regions within a selection if there is a selection active.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable to clear from
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_edit_copy image, drawable
If there is a selection in the image, then the area specified by the selection is copied from the specified drawable and placed in an internal GIMP edit buffer.  It can subsequently be retrieved using the 'gimp-edit-paste' command.  If there is no selection, then the specified drawable's contents will be stored in the internal GIMP edit buffer.  The drawable MUST belong to the specified image, or an error is returned.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable to copy from
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_edit_cut image, drawable
If there is a selection in the image, then the area specified by the selection is cut from the specified drawable and placed in an internal GIMP edit buffer.  It can subsequently be retrieved using the 'gimp-edit-paste' command.  If there is no selection, then the specified drawable will be removed and its contents stored in the internal GIMP edit buffer.  The drawable MUST belong to the specified image, or an error is returned.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable to cut from
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_edit_fill image, drawable
This procedure fills the specified drawable with the background color.  This procedure only affects regions within a selection if there is a selection active.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable to fill from
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_edit_paste image, drawable, paste_into
This procedure pastes a copy of the internal GIMP edit buffer to the specified drawable.  The GIMP edit buffer will be empty unless a call was previously made to either 'gimp-edit-cut' or 'gimp-edit-copy'.  The "paste_into" option specifies whether to clear the current image selection, or to paste the buffer "behind" the selection.  This allows the selection to act as a mask for the pasted buffer.  Anywhere that the selection mask is non-zero, the pasted buffer will show through.  The pasted buffer will be a new layer in the image which is designated as the image floating selection.  If the image has a floating selection at the time of pasting, the old floating selection will be anchored to it's drawable before the new floating selection is added.  This procedure returns the new floating layer.  The resulting floating selection will already be attached to the specified drawable, and a subsequent call to floating_sel_attach is not needed.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable to paste from
@item @emph{paste_into} (PDB_INT32)--Clear selection, or paste behind it?
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{floating_sel} (PDB_LAYER)--The new floating selection
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_edit_stroke image, drawable
This procedure strokes the current selection, painting along the selection boundary with the active brush and foreground color.  The paint is applied to the specified drawable regardless of the active selection.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable to stroke to
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_ellipse_select image, x, y, width, height, operation, antialias, feather, feather_radius
This tool creates an elliptical selection over the specified image.  The elliptical region can be either added to, subtracted from, or replace the contents of the previous selection mask.  If antialiasing is turned on, the edges of the elliptical region will contain intermediate values which give the appearance of a sharper, less pixelized edge.  This should be set as TRUE most of the time.  If the feather option is enabled, the resulting selection is blurred before combining.  The blur is a gaussian blur with the specified feather radius.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{x} (PDB_FLOAT)--X coordinate of upper-left corner of ellipse bounding box
@item @emph{y} (PDB_FLOAT)--Y coordinate of upper-left corner of ellipse bounding box
@item @emph{width} (PDB_FLOAT)--The width of the ellipse: width > 0
@item @emph{height} (PDB_FLOAT)--The height of the ellipse: height > 0
@item @emph{operation} (PDB_INT32)--The selection operation: @{ ADD (0), SUB (1), REPLACE (2), INTERSECT (3) @}
@item @emph{antialias} (PDB_INT32)--Antialiasing On/Off
@item @emph{feather} (PDB_INT32)--Feather option for selections
@item @emph{feather_radius} (PDB_FLOAT)--Radius for feather operation
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_equalize image, drawable, mask_only
This procedure equalizes the contents of the specified drawable.  Each intensity channel is equalizeed independently.  The equalizeed intensity is given as inten' = (255 - inten).  Indexed color drawables are not valid for this operation.  The 'mask_only' option specifies whether to adjust only the area of the image within the selection bounds, or the entire image based on the histogram of the selected area.  If there is no selection, the entire image is adjusted based on the histogram for the entire image.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{mask_only} (PDB_INT32)--Equalization option
@end itemize
@end defun
@emph{Federico Mena Quintero & Spencer Kimball & Peter Mattis}

@defun gimp_eraser image, drawable, num_strokes, strokes
This tool erases using the current brush mask.  If the specified drawable contains an alpha channel, then the erased pixels will become transparent.  Otherwise, the eraser tool replaces the contents of the drawable with the background color.  Like paintbrush, this tool linearly interpolates between the specified stroke coordinates.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{num_strokes} (PDB_INT32)--Number of stroke control points (count each coordinate as 2 points)
@item @emph{strokes} (PDB_FLOATARRAY)--Array of stroke coordinates: @{s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y@}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_file_load run_mode, filename, raw_filename
This procedure invokes the correct file load handler according to the file's extension and/or prefix.  The name of the file to load is typically a full pathname, and the name entered is what the user actually typed before prepending a directory path.  The reason for this is that if the user types http://www.xcf/~gimp he wants to fetch a URL, and the full pathname will not look like a URL.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive.
@item @emph{filename} (PDB_STRING)--The name of the file to load.
@item @emph{raw_filename} (PDB_STRING)--The name entered.
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image.
@end itemize
@end defun
@emph{Josh MacDonald}

@defun gimp_file_save run_mode, image, drawable, filename, raw_filename
This procedure invokes the correct file save handler according to the file's extension and/or prefix.  The name of the file to save is typically a full pathname, and the name entered is what the user actually typed before prepending a directory path.  The reason for this is that if the user types http://www.xcf/~gimp he wants to fetch a URL, and the full pathname will not look like a URL.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to save the image in
@end itemize
@end defun
@emph{Josh MacDonald}

@defun gimp_flip image, drawable, flip_type
This tool flips the specified drawable if no selection exists.  If a selection exists, the portion of the drawable which lies under the selection is cut from the drawable and made into a floating selection which is then flipd by the specified amount.  The return value is the ID of the flipped drawable.  If there was no selection, this will be equal to the drawable ID supplied as input.  Otherwise, this will be the newly created and flipd drawable.  The flip type parameter indicates whether the flip will be applied horizontally or vertically.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The affected drawable
@item @emph{flip_type} (PDB_INT32)--Type of flip: @{ HORIZONTAL (0), VERTICAL (1) @}
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The flipped drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_floating_sel_anchor floating_sel
This procedure anchors the floating selection to its associated drawable.  This is similar to merging with a merge type of ClipToBottomLayer.  The floating selection layer is no longer valid after this operation.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{floating_sel} (PDB_LAYER)--The floating selection
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_floating_sel_remove floating_sel
This procedure removes the floating selection completely, without any side effects.  The associated drawable is then set to active.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{floating_sel} (PDB_LAYER)--The floating selection
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_floating_sel_to_layer floating_sel
This procedure transforms the specified floating selection into a layer with the same offsets and extents.  The composited image will look precisely the same, but the floating selection layer will no longer be clipped to the extents of the drawable it was attached to.  The floating selection will become the active layer.  This procedure will not work if the floating selection has a different base type from the underlying image.  This might be the case if the floating selection is above an auxillary channel or a layer mask.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{floating_sel} (PDB_LAYER)--The floating selection
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_free_select image, num_pts, segs, operation, antialias, feather, feather_radius
This tool creates a polygonal selection over the specified image.  The polygonal region can be either added to, subtracted from, or replace the contents of the previous selection mask.  The polygon is specified through an array of floating point numbers and its length.  The length of array must be 2n, where n is the number of points.  Each point is defined by 2 floating point values which correspond to the x and y coordinates.  If the final point does not connect to the starting point, a connecting segment is automatically added.  If the feather option is enabled, the resulting selection is blurred before combining.  The blur is a gaussian blur with the specified feather radius.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{num_pts} (PDB_INT32)--Number of points (count 1 coordinate as two points)
@item @emph{segs} (PDB_FLOATARRAY)--Array of points: @{ p1.x, p1.y, p2.x, p2.y, ..., pn.x, pn.y@}
@item @emph{operation} (PDB_INT32)--The selection operation: @{ ADD (0), SUB (1), REPLACE (2), INTERSECT (3) @}
@item @emph{antialias} (PDB_INT32)--Antialiasing option for selections
@item @emph{feather} (PDB_INT32)--Feather option for selections
@item @emph{feather_radius} (PDB_FLOAT)--Radius for feather operation
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_fuzzy_select image, drawable, x, y, threshold, operation, antialias, feather, feather_radius, sample_merged
This tool creates a fuzzy selection over the specified image.  A fuzzy selection is determined by a seed fill under the constraints of the specified threshold.  Essentially, the color at the specified coordinates (in the drawable) is measured and the selection expands outwards from that point to any adjacent pixels which are not significantly different (as determined by the threshold value).  This process continues until no more expansion is possible.  The antialiasing parameter allows the final selection mask to contain intermediate values based on close misses to the threshold bar at pixels along the seed fill boundary.  Feathering can be enabled optionally and is controlled with the "feather_radius" paramter.  If the sample_merged parameter is non-zero, the data of the composite image will be used instead of that for the specified drawable.  This is equivalent to sampling for colors after merging all visible layers.  In the case of a merged sampling, the supplied drawable is ignored.  If the sample is merged, the specified coordinates are relative to the image origin; otherwise, they are relative to the drawable's origin.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{x} (PDB_FLOAT)--X coordinate of initial seed fill point: (image coordinates)
@item @emph{y} (PDB_FLOAT)--Y coordinate of initial seed fill point: (image coordinates)
@item @emph{threshold} (PDB_INT32)--Threshold in intensity levels: 0 <= threshold <= 255
@item @emph{operation} (PDB_INT32)--The selection operation: @{ ADD (0), SUB (1), REPLACE (2), INTERSECT (3) @}
@item @emph{antialias} (PDB_INT32)--Antialiasing On/Off
@item @emph{feather} (PDB_INT32)--Feather option for selections
@item @emph{feather_radius} (PDB_FLOAT)--Radius for feather operation
@item @emph{sample_merged} (PDB_INT32)--Use the composite image, not the drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_gimprc_query token
This procedure is used to locate additional information contained in the gimprc file considered extraneous to the operation of the GIMP.  Plug-ins that need configuration information can expect it will be stored in the user's gimprc file and can use this procedure to retrieve it.  This query procedure will return the value associated with the specified token.  This corresponds _only_ to entries with the format: (<token> <value>).  The value must be a string.  Entries not corresponding to this format will cause warnings to be issued on gimprc parsing and will not be queryable.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{token} (PDB_STRING)--The token to query for
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{value} (PDB_STRING)--The value associated with the queried token
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_gradients_get_active 
This procedure returns the name of the active gradient in hte gradient editor.--@strong{Internal GIMP procedure}

@strong{Outputs}
@itemize @bullet
@item @emph{name} (PDB_STRING)--The name of the active gradient
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun gimp_gradients_get_list 
This procedure returns a list of the gradients that are currently loaded in the gradient editor.  You can later use the gimp_gradients_set_active function to set the active gradient.--@strong{Internal GIMP procedure}

@strong{Outputs}
@itemize @bullet
@item @emph{num_gradients} (PDB_INT32)--The number of loaded gradients
@item @emph{gradient_names} (PDB_STRINGARRAY)--The list of gradient names
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun gimp_gradients_sample_custom num_samples, positions
This procedure samples the active gradient from the gradient editor in the specified number of points.  The procedure will sample the gradient in the specified positions from the list.  The left endpoint of the gradient corresponds to position 0.0, and the right endpoint corresponds to 1.0.  The procedure returns a list of floating-point values which correspond to the RGBA values for each sample.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{num_samples} (PDB_INT32)--The number of samples to take
@item @emph{positions} (PDB_FLOATARRAY)--The list of positions to sample along the gradient
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{array_length} (PDB_INT32)--Length of the color_samples array (4 * num_samples)
@item @emph{color_samples} (PDB_FLOATARRAY)--Color samples: @{ R1, G1, B1, A1, ..., Rn, Gn, Bn, An @}
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun gimp_gradients_sample_uniform num_samples
This procedure samples the active gradient from the gradient editor in the specified number of uniform parts.  It returns a list of floating-point values which correspond to the RGBA values for each sample.  The minimum number of samples to take is 2, in which case the returned colors will correspond to the @{ 0.0, 1.0 @} positions in the gradient.  For example, if the number of samples is 3, the procedure will return the colors at positions @{ 0.0, 0.5, 1.0 @}.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{num_samples} (PDB_INT32)--The number of samples to take
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{array_length} (PDB_INT32)--Length of the color_samples array (4 * num_samples)
@item @emph{color_samples} (PDB_FLOATARRAY)--Color samples: @{ R1, G1, B1, A1, ..., Rn, Gn, Bn, An @}
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun gimp_gradients_set_active name
This procedure lets you set the specified gradient as the active or "current" one.  The name is simply a string which corresponds to one of the loaded gradients in the gradient editor.  If no matching gradient is found, this procedure will return an error. Otherwise, the specified gradient will become active and will be used for subsequent custom gradient operations.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{name} (PDB_STRING)--The name of the gradient to set
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun gimp_histogram image, drawable, channel, start_range, end_range
This tool makes it possible to gather information about the intensity histogram of a drawable.  A channel to examine is first specified.  This can be either value, red, green, or blue, depending on whether the drawable is of type color or grayscale.  The drawable may not be indexed.  Second, a range of intensities are specified.  The gimp_histogram function returns statistics based on the pixels in the drawable that fall under this range of values.  Mean, standard deviation, median, number of pixels, and percentile are all returned.  Additionally, the total count of pixels in the image is returned.  Counts of pixels are weighted by any associated alpha values and by the current selection mask.  That is, pixels that lie outside an active selection mask will not be counted.  Similarly, pixels with transparent alpha values will not be counted.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{channel} (PDB_INT32)--The channel to modify: @{ VALUE (0), RED (1), GREEN (2), BLUE (3), GRAY (0) @}
@item @emph{start_range} (PDB_INT32)--Start of the intensity measurement range
@item @emph{end_range} (PDB_INT32)--End of the intensity measurement range
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{mean} (PDB_FLOAT)--Mean intensity value
@item @emph{std_dev} (PDB_FLOAT)--Standard deviation of intensity values
@item @emph{median} (PDB_FLOAT)--Median intensity value
@item @emph{pixels} (PDB_FLOAT)--Alpha-weighted pixel count for entire image
@item @emph{count} (PDB_FLOAT)--Alpha-weighted pixel count for range
@item @emph{percentile} (PDB_FLOAT)--Percentile that range falls under
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_hue_saturation image, drawable, hue_range, hue_offset, lightness, saturation
This procedures allows the hue, lightness, and saturation in the specified drawable to be modified.  The 'hue_range' parameter provides the capability to limit range of affected hues.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{hue_range} (PDB_INT32)--Range of affected hues: @{ ALL_HUES (0), RED_HUES (1), YELLOW_HUES (2), GREEN_HUES (3), CYAN_HUES (4), BLUE_HUES (5), MAGENTA_HUES (6)
@item @emph{hue_offset} (PDB_FLOAT)--Hue offset in degrees: (-180 <= hue_offset <= 180)
@item @emph{lightness} (PDB_FLOAT)--Lightness modification: (-100 <= lightness <= 100)
@item @emph{saturation} (PDB_FLOAT)--Saturation modification: (-100 <= saturation <= 100)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_active_drawable image
This procedure returns the ID of the image's active drawable.  This can be either a layer, a channel, or a layer mask.  The active drawable is specified by the active image channel.  If that is -1, then by the active image layer.  If the active image layer has a layer mask and the layer mask is in edit mode, then the layer mask is the active drawable.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The active drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_add_channel image, channel, position
This procedure adds the specified channel to the gimage.  The position channel is not currently used, so the channel is always inserted at the top of the channel stack.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{channel} (PDB_CHANNEL)--The channel
@item @emph{position} (PDB_INT32)--The channel position
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_add_layer image, layer, position
This procedure adds the specified layer to the gimage at the given position.  If the position is specified as -1, then the layer is inserted at the top of the layer stack.  If the layer to be added has no alpha channel, it must be added at position 0.  The layer type must be compatible with the image base type.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{layer} (PDB_LAYER)--The layer
@item @emph{position} (PDB_INT32)--The layer position
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_add_layer_mask image, layer, mask
This procedure adds a layer mask to the specified layer.  Layer masks serve as an additional alpha channel for a layer.  This procedure will fail if a number of prerequisites aren't met.  The layer cannot already have a layer mask.  The specified mask must exist and have the same dimensions as the layer.  Both the mask and the layer must have been created for use with the specified image.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The layer's image
@item @emph{layer} (PDB_LAYER)--The layer to receive the mask
@item @emph{mask} (PDB_CHANNEL)--The mask to add to the layer
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_base_type image
This procedure returns the image's base type, which is one of: @{ RGB-CHANNEL, GRAY-CHANNEL, INDEXED-CHANNEL @}.  Layers in the image must be of this subtype, but can have an optional alpha channel.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{base_type} (PDB_INT32)--The image's base type: @{ RGB (0), GRAY (1), INDEXED (2) @}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_clean_all image
This procedure sets the specified image's dirty count to 0, allowing operations to occur without having a 'dirtied' image.  This is especially useful for creating and loading images which should not initially be considered dirty, even though layers must be created, filled, and installed in the image.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_delete image
If there are no other references to this image it will be deleted.  Other references are possible when more than one view to an image exists.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image ID
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_disable_undo image
This procedure disables the image's undo stack, allowing subsequent operations to ignore their undo steps.  This is generally called in conjunction with 'gimp_image_enable_undo' to temporarily disable an image undo stack.  This is advantageous because saving undo steps can be time and memory intensive.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{disabled} (PDB_INT32)--True if the image undo has been disabled
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_enable_undo image
This procedure enables the image's undo stack, allowing subsequent operations to store their undo steps.  This is generally called in conjunction with 'gimp_image_disable_undo' to temporarily disable an image undo stack.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{enabled} (PDB_INT32)--True if the image undo has been enabled
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_flatten image
This procedure combines the visible layers in a manner analogous to merging with the ClipToImage merge type.  Non-visible layers are discarded, and the resulting image is stripped of its alpha channel.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The resulting layer
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_floating_selection image
This procedure returns the image's floating_sel, if it exists.  If it doesn't exist, -1 is returned as the layer ID.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{floating_sel} (PDB_LAYER)--The image's floating selection
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_free_shadow image
This procedure is intended as a memory saving device.  If any shadow memory has been allocated, it will be freed automatically on a call to 'gimp_image_delete'.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image ID
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_get_active_channel image
If there is an active channel, this will return the channel ID, otherwise, -1.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{channel ID} (PDB_CHANNEL)--The ID of the active channel
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_get_active_layer image
If there is an active layer, its ID will be returned, otherwise, -1.  If a channel is currently active, then no layer will be.  If a layer mask is active, then this will return the associated layer.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{layer_ID} (PDB_LAYER)--The ID of the active layer
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_get_channels image
This procedure returns the list of channels contained in the specified image.  This does not include the selection mask, or layer masks.  The order is from topmost to bottommost.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{num_channels} (PDB_INT32)--The number of channels contained in the image
@item @emph{channel_ids} (PDB_INT32ARRAY)--The list of channels contained in the image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_get_cmap image
This procedure returns an actual pointer to the image's colormap, as well as the number of bytes contained in the colormap.  The actual number of colors in the transmitted colormap will be "num_bytes" / 3.  If the image is not of base type INDEXED, this pointer will be NULL.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{num_bytes} (PDB_INT32)--Number of bytes in the colormap array: 0 <= num_bytes <= 768
@item @emph{cmap} (PDB_INT8ARRAY)--The image's colormap
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_get_component_active image, component
This procedure returns information on whether the specified image component (ie. red, green, blue intensity channels in an RGB image) is active or inactive--whether or not it can be modified.  If the specified component is not valid for the image type, an error is returned.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{component} (PDB_INT32)--The image component: @{ RED-CHANNEL (0), GREEN-CHANNEL (1), BLUE-CHANNEL (2), GRAY-CHANNEL (3), INDEXED-CHANNEL (4) @}
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{active} (PDB_INT32)--1 for active, 0 for inactive
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_get_component_visible image, component
This procedure returns information on whether the specified image component (ie. Red, Green, Blue intensity channels in an RGB image) is visible or invisible--whether or not it can be modified.  If the specified component is not valid for the image type, an error is returned.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{component} (PDB_INT32)--The image component: @{RED-CHANNEL (0), GREEN-CHANNEL (1), BLUE-CHANNEL (2), GRAY-CHANNEL (3), INDEXED-CHANNEL (4) @}
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{visible} (PDB_INT32)--1 for visible, 0 for invisible
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_get_filename image
This procedure returns the image's filename--if it was loaded or has since been saved.  Otherwise, returns NULL.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{filename} (PDB_STRING)--The image's filename
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_get_layers image
This procedure returns the list of layers contained in the specified image.  The order of layers is from topmost to bottommost.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{num_layers} (PDB_INT32)--The number of layers contained in the image
@item @emph{layer_ids} (PDB_INT32ARRAY)--The list of layers contained in the image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_get_selection image
This will always return a valid ID for a selection--which is represented as a channel internally.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{selection mask ID} (PDB_SELECTION)--The ID of the selection channel
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_height image
This procedure returns the image's height.  This value is independent of any of the layers in this image.  This is the "canvas" height.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{height} (PDB_INT32)--The image's height
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_lower_channel image, channel
This procedure lowers the specified channel one step in the existing channel stack.  It will not move the channel if there is no channel below it.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{channel} (PDB_CHANNEL)--The channel to lower
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_lower_layer image, layer
This procedure lowers the specified layer one step in the existing layer stack.  It will not move the layer if there is no layer below it, or the layer has no alpha channel.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{layer} (PDB_LAYER)--The layer to lower
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_merge_visible_layers image, merge_type
This procedure combines the visible layers into a single layer using the specified merge type.  A merge type of EXPAND-AS-NECESSARY expands the final layer to encompass the areas of the visible layers.  A merge type of CLIP-TO-IMAGE clips the final layer to the extents of the image.  A merge type of CLIP-TO-BOTTOM-LAYER clips the final layer to the size of the bottommost layer.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{merge_type} (PDB_INT32)--The type of merge: @{ EXPAND-AS-NECESSARY (0), CLIP-TO-IMAGE (1), CLIP-TO-BOTTOM-LAYER (2) @}
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The resulting layer
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_new width, height, type
Creates a new image, undisplayed with the specified extents and type.  A layer should be created and added before this image is displayed, or subsequent calls to 'gimp_display_new' with this image as an argument will fail.  Layers can be created using the 'gimp_layer_new' commands.  They can be added to an image using the 'gimp_image_add_layer' command.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{width} (PDB_INT32)--The width of the image
@item @emph{height} (PDB_INT32)--The height of the image
@item @emph{type} (PDB_INT32)--The type of image: @{ RGB (0), GRAY (1), INDEXED (2) @}
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The ID of the newly created image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_pick_correlate_layer image, x, y
This procedure finds the layer which is visible at the specified coordinates.  Layers which do not qualify are those whose extents do not pass within the specified coordinates, or which are transparent at the specified coordinates.  This procedure will return -1 if no layer is found.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{x} (PDB_INT32)--The x coordinate for the pick
@item @emph{y} (PDB_INT32)--The y coordinate for the pick
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer found at the specified coordinates
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_raise_channel image, channel
This procedure raises the specified channel one step in the existing channel stack.  It will not move the channel if there is no channel above it.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{channel} (PDB_CHANNEL)--The channel to raise
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_raise_layer image, layer
This procedure raises the specified layer one step in the existing layer stack.  It will not move the layer if there is no layer above it, or the layer has no alpha channel.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{layer} (PDB_LAYER)--The layer to raise
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_remove_channel image, channel
This procedure removes the specified channel from the image.  If the channel doesn't exist, an error is returned.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{channel} (PDB_CHANNEL)--The channel
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_remove_layer image, layer
This procedure removes the specified layer from the image.  If the layer doesn't exist, an error is returned.  If there are no layers left in the image, this call will fail.  If this layer is the last layer remaining, the image will become empty and have no active layer.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{layer} (PDB_LAYER)--The layer
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_remove_layer_mask image, layer, mode
This procedure removes the specified layer mask from the layer.  If the mask doesn't exist, an error is returned.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The layer's image
@item @emph{layer} (PDB_LAYER)--The layer from which to remove mask
@item @emph{mode} (PDB_INT32)--Removal mode: @{ APPLY (0), DISCARD (1) @}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_resize image, new_width, new_height, offx, offy
This procedure resizes the image so that it's new width and height are equal to the supplied parameters.  Offsets are also provided which describe the position of the previous image's content.  No bounds checking is currently provided, so don't supply parameters that are out of bounds.  All channels within the image are resized according to the specified parameters; this includes the image selection mask.  All layers within the image are repositioned according to the specified offsets.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{new_width} (PDB_INT32)--New image width: (new_width > 0)
@item @emph{new_height} (PDB_INT32)--New image height: (new_height > 0)
@item @emph{offx} (PDB_INT32)--X offset between upper left corner of old and new images: (new - old)
@item @emph{offy} (PDB_INT32)--Y offset between upper left corner of old and new images: (new - old)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_scale image, new_width, new_height
This procedure scales the image so that it's new width and height are equal to the supplied parameters.  Offsets are also provided which describe the position of the previous image's content.  No bounds checking is currently provided, so don't supply parameters that are out of bounds.  All channels within the image are scaled according to the specified parameters; this includes the image selection mask.  All layers within the image are repositioned according to the specified offsets.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{new_width} (PDB_INT32)--New image width: (new_width > 0)
@item @emph{new_height} (PDB_INT32)--New image height: (new_height > 0)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_set_active_channel image, channel
If the channel exists, it is set as the active channel in the image.  Any previous active channel or channel is set to inactive.  An exception is a previously existing floating selection, in which case this procedure will return an execution error.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{channel} (PDB_CHANNEL)--The channel to be set active
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_set_active_layer image, layer
If the layer exists, it is set as the active layer in the image.  Any previous active layer or channel is set to inactive.  An exception is a previously existing floating selection, in which case this procedure will return an execution error.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{layer} (PDB_LAYER)--The layer to be set active
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_set_cmap image, num_bytes, cmap
This procedure sets the entries in the specified image's colormap.  The number of entries is specified by the "num_bytes" parameter and corresponds the the number of INT8 triples that must be contained in the "cmap" array.  The actual number of colors in the transmitted colormap is "num_bytes" / 3.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{num_bytes} (PDB_INT32)--Number of bytes in the new colormap: 0 <= num_colors <= 768
@item @emph{cmap} (PDB_INT8ARRAY)--The new colormap values
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_set_component_active image, component, active
This procedure sets whether the specified component is active or inactive--that is, whether it can be affected during painting operations.  If the specified component is not valid for the image type, an error is returned.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{component} (PDB_INT32)--The image component: @{ RED-CHANNEL (0), GREEN-CHANNEL (1), BLUE-CHANNEL (2), GRAY-CHANNEL (3), INDEXED-CHANNEL (4) @}
@item @emph{active} (PDB_INT32)--Active? 1 for true, 0 for false
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_set_component_visible image, component, visible
This procedure sets whether the specified component is visible or invisible.  If the specified component is not valid for the image type, an error is returned.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{component} (PDB_INT32)--The image component: @{ RED-CHANNEL (0), GREEN-CHANNEL (1), BLUE-CHANNEL (2), GRAY-CHANNEL (3), INDEXED-CHANNEL (4) @}
@item @emph{visible} (PDB_INT32)--Visible? 1 for true, 0 for false
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_set_filename image, filename
This procedure sets the image's filename.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{filename} (PDB_STRING)--The image's filename
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_unset_active_channel image
If an active channel exists, it is unset.  There then exists no active channel, and if desired, one can be set through a call to 'Set Active Channel'.  No error is returned in the case of no existing active channel.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_image_width image
This procedure returns the image's width.  This value is independent of any of the layers in this image.  This is the "canvas" width.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{width} (PDB_INT32)--The image's width
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_invert image, drawable
This procedure inverts the contents of the specified drawable.  Each intensity channel is inverted independently.  The inverted intensity is given as inten' = (255 - inten).  Indexed color drawables are not valid for this operation.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_add_alpha layer
This procedure adds an additional component to the specified layer if it does not already possess an alpha channel.  An alpha channel makes it possible to move a layer from the bottom of the layer stack and to clear and erase to transparency, instead of the background color.  This transforms images of type RGB to RGBA, Gray to GrayA, and Indexed to IndexedA.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_copy layer, add_apha
This procedure copies the specified layer and returns the copy.  The newly copied layer is for use within the original layer's image.  It should not be subsequently added to any other image.  The copied layer can optionally have an added alpha channel.  This is useful if the background layer in an image is being copied and added to the same image.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer to copy
@item @emph{add_apha} (PDB_INT32)--Add an alpha channel to the copied layer
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{layer_copy} (PDB_LAYER)--The newly copied layer
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_create_mask layer, mask_type
This procedure creates a layer mask for the specified layer.  Layer masks serve as an additional alpha channel for a layer.  Three different types of masks are allowed initially: completely white masks (which will leave the layer fully visible), completely black masks (which will give the layer complete transparency), and the layer's already existing alpha channel (which will leave the layer fully visible, but which may be more useful than a white mask).  The layer mask still needs to be added to the layer.  This can be done with a call to 'gimage_add_layer_mask'.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer to which to add the mask
@item @emph{mask_type} (PDB_INT32)--The type of mask: @{ WHITE-MASK (0), BLACK-MASK (1), ALPHA-MASK (2) @}
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{mask} (PDB_CHANNEL)--The newly created mask
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_delete layer
This procedure deletes the specified layer.  This does not need to be done if a gimage containing this layer was already deleted.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer to delete
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_get_apply_mask layer
This procedure returns the specified layer's apply mask setting.  If the return value is non-zero, then the layer mask for this layer is currently being composited with the layer's alpha channel.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{apply_mask} (PDB_INT32)--The layer's apply mask setting
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_get_edit_mask layer
This procedure returns the specified layer's edit mask setting.  If the value is non-zero, then the layer's mask is currently active, and not the layer.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{edit_mask} (PDB_INT32)--The layer's edit mask setting
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_get_mode layer
This procedure returns the specified layer's combination mode.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{mode} (PDB_INT32)--The layer combination mode: @{ NORMAL (0), DISSOLVE (1), MULTIPLY (3), SCREEN (4), OVERLAY (5) DIFFERENCE (6), ADDITION (7), SUBTRACT (8), DARKEN-ONLY (9), LIGHTEN-ONLY (10), HUE (11), SATURATION (12), COLOR (13), VALUE (14) @}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_get_name layer
This procedure returns the specified layer's name.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{name} (PDB_STRING)--The layer name
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_get_opacity layer
This procedure returns the specified layer's opacity.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{opacity} (PDB_FLOAT)--The layer opacity
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_get_preserve_trans layer
This procedure returns the specified layer's preserve transparency setting.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{preserve_trans} (PDB_INT32)--The layer's preserve transparency setting
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_get_show_mask layer
This procedure returns the specified layer's show mask setting.  If the value is non-zero, then the layer's mask is currently being shown instead of the layer.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{show_mask} (PDB_INT32)--The layer's show mask setting
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_get_visible layer
This procedure returns the specified layer's visibility.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{visible} (PDB_INT32)--The layer visibility
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_is_floating_sel layer
This procedure returns whether the layer is a floating selection.  Floating selections are special cases of layers which are attached to a specific drawable.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{is_floating_sel} (PDB_CHANNEL)--Non-zero if the layer is a floating selection
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_mask layer
This procedure returns the specified layer's mask, or -1 if none exists.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{mask} (PDB_CHANNEL)--The layer mask
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_new image, width, height, type, name, opacity, mode
This procedure creates a new layer with the specified width, height, and type.  Name, opacity, and mode are also supplied parameters.  The new layer still needs to be added to the image, as this is not automatic.  Add the new layer with the 'gimp_image_add_layer' command.  Other attributes such as layer mask modes, and offsets should be set with explicit procedure calls.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image to which to add the layer
@item @emph{width} (PDB_INT32)--The layer width: (width > 0)
@item @emph{height} (PDB_INT32)--The layer height: (height > 0)
@item @emph{type} (PDB_INT32)--The layer type: @{ RGB_IMAGE (0), RGBA_IMAGE (1), GRAY_IMAGE (2), GRAYA_IMAGE (3), INDEXED_IMAGE (4), INDEXEDA_IMAGE (5) @}
@item @emph{name} (PDB_STRING)--The layer name
@item @emph{opacity} (PDB_FLOAT)--The layer opacity: (0 <= opacity <= 100)
@item @emph{mode} (PDB_INT32)--The layer combination mode: @{ NORMAL (0), DISSOLVE (1), MULTIPLY (3), SCREEN (4), OVERLAY (5) DIFFERENCE (6), ADDITION (7), SUBTRACT (8), DARKEN-ONLY (9), LIGHTEN-ONLY (10), HUE (11), SATURATION (12), COLOR (13), VALUE (14) @}
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The newly created layer
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_resize layer, new_width, new_height, offx, offy
This procedure resizes the layer so that it's new width and height are equal to the supplied parameters.  Offsets are also provided which describe the position of the previous layer's content.  No bounds checking is currently provided, so don't supply parameters that are out of bounds.  This operation on works if the layer has been added to an image.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@item @emph{new_width} (PDB_INT32)--New layer width: (new_width > 0)
@item @emph{new_height} (PDB_INT32)--New layer height: (new_height > 0)
@item @emph{offx} (PDB_INT32)--X offset between upper left corner of old and new layers: (new - old)
@item @emph{offy} (PDB_INT32)--Y offset between upper left corner of old and new layers: (new - old)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_scale layer, new_width, new_height, local_origin
This procedure scales the layer so that it's new width and height are equal to the supplied parameters.  The "local_origin" parameter specifies whether to scale from the center of the layer, or from the image origin.  This operation only works if the layer has been added to an image.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@item @emph{new_width} (PDB_INT32)--New layer width: (new_width > 0)
@item @emph{new_height} (PDB_INT32)--New layer height: (new_height > 0)
@item @emph{local_origin} (PDB_INT32)--Use a local origin, or the image origin?
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_set_apply_mask layer, apply_mask
This procedure sets the specified layer's apply mask parameter.  This controls whether the layer's mask is currently affecting the alpha channel.  If there is no layer mask, this function will return an error--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@item @emph{apply_mask} (PDB_INT32)--The new layer apply mask setting
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_set_edit_mask layer, edit_mask
This procedure sets the specified layer's edit mask parameter.  This setting controls whether the layer or it's mask is currently active for editing.  If the specified layer has no layer mask, then this procedure will return an error.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@item @emph{edit_mask} (PDB_INT32)--The new layer edit mask setting
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_set_mode layer, mode
This procedure sets the specified layer's combination mode.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@item @emph{mode} (PDB_INT32)--The new layer combination mode
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_set_name layer, name
This procedure sets the specified layer's name to the supplied name.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@item @emph{name} (PDB_STRING)--The new layer name
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_set_offsets layer, offx, offy
This procedure sets the offsets for the specified layer.  The offsets are relative to the image origin and can be any values.  This operation is valid only on layers which have been added to an image.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@item @emph{offx} (PDB_INT32)--Offset in x direction
@item @emph{offy} (PDB_INT32)--Offset in y direction
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_set_opacity layer, opacity
This procedure sets the specified layer's opacity.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@item @emph{opacity} (PDB_FLOAT)--The new layer opacity: (0 <= opacity <= 100)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_set_preserve_trans layer, preserve_trans
This procedure sets the specified layer's preserve transparency option.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@item @emph{preserve_trans} (PDB_INT32)--The new layer preserve transparency setting
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_set_show_mask layer, show_mask
This procedure sets the specified layer's show mask parameter.  This setting controls whether the layer or it's mask is visible.  Non-zero values indicate that the mask should be visible.  If the layer has no mask, then this function returns an error.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@item @emph{show_mask} (PDB_INT32)--The new layer show mask setting
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_set_visible layer, visible
This procedure sets the specified layer's visibility.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@item @emph{visible} (PDB_INT32)--The new layer visibility
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_layer_translate layer, offx, offy
This procedure translates the layer by the amounts specified in the x and y arguments.  These can be negative, and are considered offsets from the current position.  This command only works if the layer has been added to an image.  All additional layers contained in the image which have the linked flag set to TRUE will also be translated by the specified offsets.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The layer
@item @emph{offx} (PDB_INT32)--Offset in x direction
@item @emph{offy} (PDB_INT32)--Offset in y direction
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_levels image, drawable, channel, low_input, high_input, gamma, low_output, high_output
This tool allows intensity levels in the specified drawable to be remapped according to a set of parameters.  The low/high input levels specify an initial mapping from the source intensities.  The gamma value determines how intensities between the low and high input intensities are interpolated.  A gamma value of 1.0 results in a linear interpolation.  Higher gamma values result in more high-level intensities.  Lower gamma values result in more low-level intensities.  The low/high output levels constrain the final intensity mapping--that is, no final intensity will be lower than the low output level and no final intensity will be higher than the high output level.  This tool is only valid on RGB color and grayscale images.  It will not operate on indexed drawables.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{channel} (PDB_INT32)--The channel to modify: @{ VALUE (0), RED (1), GREEN (2), BLUE (3), GRAY (0) @}
@item @emph{low_input} (PDB_INT32)--Intensity of lowest input: (0 <= low_input <= 255)
@item @emph{high_input} (PDB_INT32)--Intensity of highest input: (0 <= high_input <= 255)
@item @emph{gamma} (PDB_FLOAT)--Gamma correction factor: (0.1 <= gamma <= 10)
@item @emph{low_output} (PDB_INT32)--Intensity of lowest output: (0 <= low_input <= 255)
@item @emph{high_output} (PDB_INT32)--Intensity of highest output: (0 <= high_input <= 255)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_list_images 
This procedure returns the list of images currently open in the GIMP.--@strong{Internal GIMP procedure}

@strong{Outputs}
@itemize @bullet
@item @emph{num_images} (PDB_INT32)--The number of images currently open
@item @emph{image_ids} (PDB_INT32ARRAY)--The list of images currently open
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_paintbrush image, drawable, fade_out, num_strokes, strokes
This tool is the standard paintbrush.  It draws linearly interpolated lines through the specified stroke coordinates.  It operates on the specified drawable in the foreground color with the active brush.  The "fade_out" parameter is measured in pixels and allows the brush stroke to linearly fall off.  The pressure is set to the maximum at the beginning of the stroke.  As the distance of the stroke nears the fade_out value, the pressure will approach zero.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{fade_out} (PDB_FLOAT)--Fade out parameter: fade_out > 0
@item @emph{num_strokes} (PDB_INT32)--Number of stroke control points (count each coordinate as 2 points)
@item @emph{strokes} (PDB_FLOATARRAY)--Array of stroke coordinates: @{s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y@}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_palette_get_background 
This procedure retrieves the current GIMP background color.  The background color is used in a variety of tools such as blending, erasing (with non-apha images), and image filling.--@strong{Internal GIMP procedure}

@strong{Outputs}
@itemize @bullet
@item @emph{background} (PDB_COLOR)--The background color
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_palette_get_foreground 
This procedure retrieves the current GIMP foreground color.  The foreground color is used in a variety of tools such as paint tools, blending, and bucket fill.--@strong{Internal GIMP procedure}

@strong{Outputs}
@itemize @bullet
@item @emph{foreground} (PDB_COLOR)--The foreground color
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_palette_set_background background
This procedure sets the current GIMP background color.  After this is set, operations which use background such as blending, filling images, clearing, and erasing (in non-alpha images) will use the new value.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{background} (PDB_COLOR)--The background color
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_palette_set_foreground foreground
This procedure sets the current GIMP foreground color.  After this is set, operations which use foreground such as paint tools, blending, and bucket fill will use the new value.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{foreground} (PDB_COLOR)--The foreground color
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_patterns_get_pattern 
This procedure retrieves information about the currently active pattern.  This includes the pattern name, and the pattern extents (width and height).  All clone and bucket-fill operations with patterns will use this pattern to control the application of paint to the image.--@strong{Internal GIMP procedure}

@strong{Outputs}
@itemize @bullet
@item @emph{name} (PDB_STRING)--The pattern name
@item @emph{width} (PDB_INT32)--The pattern width
@item @emph{height} (PDB_INT32)--The pattern height
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_patterns_list 
This procedure returns a complete listing of available GIMP patterns.  Each name returned can be used as input to the 'gimp_patterns_set_pattern'--@strong{Internal GIMP procedure}

@strong{Outputs}
@itemize @bullet
@item @emph{num_patterns} (PDB_INT32)--The number of patterns in the pattern list
@item @emph{pattern_list} (PDB_STRINGARRAY)--The list of pattern names
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_patterns_set_pattern name
This procedure allows the active pattern mask to be set by specifying its name.  The name is simply a string which corresponds to one of the names of the installed patterns.  If there is no matching pattern found, this procedure will return an error.  Otherwise, the specified pattern becomes active and will be used in all subsequent paint operations.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{name} (PDB_STRING)--The pattern name
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_pencil image, drawable, num_strokes, strokes
This tool is the standard pencil.  It draws linearly interpolated lines through the specified stroke coordinates.  It operates on the specified drawable in the foreground color with the active brush.  The brush mask is treated as though it contains only black and white values.  Any value below half is treated as black; any above half, as white.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{num_strokes} (PDB_INT32)--Number of stroke control points (count each coordinate as 2 points)
@item @emph{strokes} (PDB_FLOATARRAY)--Array of stroke coordinates: @{s1.x, s1.y, s2.x, s2.y, ..., sn.x, sn.y@}
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_perspective image, drawable, interpolation, x0, y0, x1, y1, x2, y2, x3, y3
This tool performs a possibly non-affine transformation on the specified drawable by allowing the corners of the original bounding box to be arbitrarily remapped to any values.  The specified drawable is remapped if no selection exists.  However, if a selection exists, the portion of the drawable which lies under the selection is cut from the drawable and made into a floating selection which is then remapped as specified.  The interpolation parameter can be set to TRUE to indicate that either linear or cubic interpolation should be used to smooth the resulting remapped drawable.  The return value is the ID of the remapped drawable.  If there was no selection, this will be equal to the drawable ID supplied as input.  Otherwise, this will be the newly created and remapped drawable.  The 4 coordinates specify the new locations of each corner of the original bounding box.  By specifying these values, any affine transformation (rotation, scaling, translation) can be affected.  Additionally, these values can be specified such that the resulting transformed drawable will appear to have been projected via a perspective transform.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The affected drawable
@item @emph{interpolation} (PDB_INT32)--Whether to use interpolation
@item @emph{x0} (PDB_FLOAT)--The new x coordinate of upper-left corner of original bounding box
@item @emph{y0} (PDB_FLOAT)--The new y coordinate of upper-left corner of original bounding box
@item @emph{x1} (PDB_FLOAT)--The new x coordinate of upper-right corner of original bounding box
@item @emph{y1} (PDB_FLOAT)--The new y coordinate of upper-right corner of original bounding box
@item @emph{x2} (PDB_FLOAT)--The new x coordinate of lower-left corner of original bounding box
@item @emph{y2} (PDB_FLOAT)--The new y coordinate of lower-left corner of original bounding box
@item @emph{x3} (PDB_FLOAT)--The new x coordinate of lower-right corner of original bounding box
@item @emph{y3} (PDB_FLOAT)--The new y coordinate of lower-right corner of original bounding box
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The newly mapped drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_posterize image, drawable, levels
This procedures reduces the number of shades allows in each intensity channel to the specified 'levels' parameter.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{levels} (PDB_INT32)--Levels of posterization: (2 <= levels <= 255)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_procedural_db_dump filename
This procedure dumps the contents of the procedural database to the specified file.  The file will contain all of the information provided for each registered procedure.  This file is in a format appropriate for use with the supplied "pdb_self_doc.el" Elisp script, which generates a texinfo document.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{filename} (PDB_STRING)--The dump filename
@end itemize
@end defun
@emph{Spencer Kimball & Josh MacDonald}

@defun gimp_procedural_db_get_data identifier
This procedure returns any data which may have been associated with the specified identifier.  The data is a variable length array of bytes.  If no data has been associated with the identifier, an error is returned.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{identifier} (PDB_STRING)--The identifier associated with data
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{bytes} (PDB_INT32)--The number of bytes in the data
@item @emph{data} (PDB_INT8ARRAY)--A byte array containing data
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_procedural_db_proc_arg procedure, arg_num
This procedure returns information on the specified procedure's argument.  The argument type, name, and a description are retrieved.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{procedure} (PDB_STRING)--The procedure name
@item @emph{arg_num} (PDB_INT32)--The argument number
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{arg_type} (PDB_INT32)--The type of argument @{ PDB_INT32 (0), PDB_INT16 (1), PDB_INT8 (2), PDB_FLOAT (3), PDB_STRING (4), PDB_INT32ARRAY (5), PDB_INT16ARRAY (6), PDB_INT8ARRAY (7), PDB_FLOATARRAY (8), PDB_STRINGARRAY (9), PDB_COLOR (10), PDB_REGION (11), PDB_DISPLAY (12), PDB_IMAGE (13), PDB_LAYER (14), PDB_CHANNEL (15), PDB_DRAWABLE (16), PDB_SELECTION (17), PDB_BOUNDARY (18), PDB_PATH (19), PDB_STATUS (20) @}
@item @emph{arg_name} (PDB_STRING)--The name of the argument
@item @emph{arg_desc} (PDB_STRING)--A description of the argument
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_procedural_db_proc_info procedure
This procedure returns information on the specified procedure.  A short blurb, detailed help, author(s), copyright information, procedure type, number of input, and number of return values are returned.  For specific information on each input argument and return value, use the 'gimp_procedural_db_query_proc_arg' and 'gimp_procedural_db_query_proc_val' procedures--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{procedure} (PDB_STRING)--The procedure name
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{blurb} (PDB_STRING)--A short blurb
@item @emph{help} (PDB_STRING)--Detailed procedure help
@item @emph{author} (PDB_STRING)--Author(s) of the procedure
@item @emph{copyright} (PDB_STRING)--The copyright
@item @emph{date} (PDB_STRING)--Copyright date
@item @emph{proc_type} (PDB_INT32)--The procedure type: @{ INTERNAL (0), PLUGIN (1), EXTENSION (2) @}
@item @emph{num_args} (PDB_INT32)--The number of input arguments
@item @emph{num_rvals} (PDB_INT32)--The number of return values
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_procedural_db_proc_val procedure, val_num
This procedure returns information on the specified procedure's return value.  The return value type, name, and a description are retrieved.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{procedure} (PDB_STRING)--The procedure name
@item @emph{val_num} (PDB_INT32)--The return value number
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{val_type} (PDB_INT32)--The type of return value @{ PDB_INT32 (0), PDB_INT16 (1), PDB_INT8 (2), PDB_FLOAT (3), PDB_STRING (4), PDB_INT32ARRAY (5), PDB_INT16ARRAY (6), PDB_INT8ARRAY (7), PDB_FLOATARRAY (8), PDB_STRINGARRAY (9), PDB_COLOR (10), PDB_REGION (11), PDB_DISPLAY (12), PDB_IMAGE (13), PDB_LAYER (14), PDB_CHANNEL (15), PDB_DRAWABLE (16), PDB_SELECTION (17), PDB_BOUNDARY (18), PDB_PATH (19), PDB_STATUS (20) @}
@item @emph{val_name} (PDB_STRING)--The name of the return value
@item @emph{val_desc} (PDB_STRING)--A description of the return value
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_procedural_db_query name, blurb, help, author, copyright, date, proc_type
This procedure queries the contents of the procedural database.  It is supplied with seven arguments matching procedures on @{name, blurb, help, author, copyright, date, procedure type@}.  This is accomplished using regular expression matching.  For instance, to find all procedures with "jpeg" listed in the blurb, all seven arguments can be supplied as ".*", except for the second, which can be supplied as ".*jpeg.*".  There are two return arguments for this procedure.  The first is the number of procedures matching the query.  The second is a concatenated list of procedure names corresponding to those matching the query.  If no matching entries are found, then the returned string is NULL and the number of entries is 0.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{name} (PDB_STRING)--The regex for procedure name
@item @emph{blurb} (PDB_STRING)--The regex for procedure blurb
@item @emph{help} (PDB_STRING)--The regex for procedure help
@item @emph{author} (PDB_STRING)--The regex for procedure author
@item @emph{copyright} (PDB_STRING)--The regex for procedure copyright
@item @emph{date} (PDB_STRING)--The regex for procedure date
@item @emph{proc_type} (PDB_STRING)--The regex for procedure type: @{'Internal GIMP procedure', 'GIMP Plug-In', 'GIMP Extension'@}
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{num_matches} (PDB_INT32)--The number of matching procedures
@item @emph{procedure_names} (PDB_STRINGARRAY)--The list of procedure names
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_procedural_db_set_data identifier, bytes, data
This procedure associates the supplied data with the provided identifier.  The data may be subsequently retrieved by a call to 'procedural_db_get_data'.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{identifier} (PDB_STRING)--The identifier for association with data
@item @emph{bytes} (PDB_INT32)--The number of bytes in data
@item @emph{data} (PDB_INT8ARRAY)--The data
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_progress_init message
Initializes the progress bar for the current plug-in. It is only valid to call this procedure from a plug-in.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{message} (PDB_STRING)--Message to use in the progress dialog.
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_progress_update percentage
Updates the progress bar for the current plug-in. It is only valid to call this procedure from a plug-in.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{percentage} (PDB_FLOAT)--Percentage of progress completed
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_quit kill
The internal procedure which can either be used to make the gimp quit normally, or to have the gimp clean up its resources and exit immediately. The normaly shutdown process allows for querying the user to save any dirty images.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{kill} (PDB_INT32)--Flag specifying whether to kill the gimp process or exit normally
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_rect_select image, x, y, width, height, operation, feather, feather_radius
This tool creates a rectangular selection over the specified image.  The rectangular region can be either added to, subtracted from, or replace the contents of the previous selection mask.  If the feather option is enabled, the resulting selection is blurred before combining.  The blur is a gaussian blur with the specified feather radius.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{x} (PDB_FLOAT)--X coordinate of upper-left corner of rectangle
@item @emph{y} (PDB_FLOAT)--Y coordinate of upper-left corner of rectangle
@item @emph{width} (PDB_FLOAT)--The width of the rectangle: width > 0
@item @emph{height} (PDB_FLOAT)--The height of the rectangle: height > 0
@item @emph{operation} (PDB_INT32)--The selection operation: @{ ADD (0), SUB (1), REPLACE (2), INTERSECT (3) @}
@item @emph{feather} (PDB_INT32)--Feather option for selections
@item @emph{feather_radius} (PDB_FLOAT)--Radius for feather operation
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_register_load_handler procedure_name, extensions, prefixes
Registers a procedural database procedure to be called to load files of a particular file format.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{procedure_name} (PDB_STRING)--The name of the procedure to be used for loading
@item @emph{extensions} (PDB_STRING)--Comma separated list of extensions this handler can load (ie. "jpeg,jpg")
@item @emph{prefixes} (PDB_STRING)--Comma separated list of prefixes this handler can load (ie. "http:,ftp:")
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_register_magic_load_handler procedure_name, extensions, prefixes
Registers a procedural database procedure to be called to load files of a particular file format using magic file information.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{procedure_name} (PDB_STRING)--The name of the procedure to be used for loading
@item @emph{extensions} (PDB_STRING)--Comma separated list of extensions this handler can load (ie. "jpeg,jpg")
@item @emph{prefixes} (PDB_STRING)--Comma separated list of prefixes this handler can load (ie. "http:,ftp:")
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_register_save_handler procedure_name, extensions, prefixes
Registers a procedural database procedure to be called to save files in a particular file format.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{procedure_name} (PDB_STRING)--The name of the procedure to be used for saving
@item @emph{extensions} (PDB_STRING)--Comma separated list of extensions this handler can save (ie. "jpeg,jpg")
@item @emph{prefixes} (PDB_STRING)--Comma separated list of prefixes this handler can save (ie. "http:,ftp:")
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_rotate image, drawable, interpolation, angle
This tool rotates the specified drawable if no selection exists.  If a selection exists, the portion of the drawable which lies under the selection is cut from the drawable and made into a floating selection which is then rotated by the specified amount.  The interpolation parameter can be set to TRUE to indicate that either linear or cubic interpolation should be used to smooth the resulting rotated drawable.  The return value is the ID of the rotated drawable.  If there was no selection, this will be equal to the drawable ID supplied as input.  Otherwise, this will be the newly created and rotated drawable.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The affected drawable
@item @emph{interpolation} (PDB_INT32)--Whether to use interpolation
@item @emph{angle} (PDB_FLOAT)--The angle of rotation (radians)
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The rotated drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_scale image, drawable, interpolation, x1, y1, x2, y2
This tool scales the specified drawable if no selection exists.  If a selection exists, the portion of the drawable which lies under the selection is cut from the drawable and made into a floating selection which is then scaled by the specified amount.  The interpolation parameter can be set to TRUE to indicate that either linear or cubic interpolation should be used to smooth the resulting scaled drawable.  The return value is the ID of the scaled drawable.  If there was no selection, this will be equal to the drawable ID supplied as input.  Otherwise, this will be the newly created and scaled drawable.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The affected drawable
@item @emph{interpolation} (PDB_INT32)--Whether to use interpolation
@item @emph{x1} (PDB_FLOAT)--The x coordinate of the upper-left corner of newly scaled region
@item @emph{y1} (PDB_FLOAT)--The y coordinate of the upper-left corner of newly scaled region
@item @emph{x2} (PDB_FLOAT)--The x coordinate of the lower-right corner of newly scaled region
@item @emph{y2} (PDB_FLOAT)--The y coordinate of the lower-right corner of newly scaled region
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The scaled drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_all image
This procedure sets the selection mask to completely encompass the image.  Every pixel in the selection channel is set to 255.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_border image, radius
This procedure borders the selection.  Bordering creates a new selection which is defined along the boundary of the previous selection at every point within the specified radius.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{radius} (PDB_INT32)--Radius of border (pixels)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_bounds image
This procedure returns whether there is a selection for the specified image.  If there is one, the upper left and lower right corners of the bounding box are returned.  These coordinates are relative to the image.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{non-empty} (PDB_INT32)--True if there is a selection
@item @emph{x1} (PDB_INT32)--X coordinate of upper left corner of selection bounds
@item @emph{y1} (PDB_INT32)--Y coordinate of upper left corner of selection bounds
@item @emph{x2} (PDB_INT32)--X coordinate of lower right corner of selection bounds
@item @emph{y2} (PDB_INT32)--Y coordinate of lower right corner of selection bounds
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_clear image
This procedure sets the selection mask to empty, assigning the value 0 to every pixel in the selection channel.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_feather image, radius
This procedure feathers the selection.  Feathering is implemented using a gaussian blur.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{radius} (PDB_FLOAT)--Radius of feather (in pixels)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_float image, drawable, offset_x, offset_y
This procedure determines the region of the specified drawable that lies beneath the current selection.  The region is then cut from the drawable and the resulting data is made into a new layer which is instantiated as a floating selection.  The offsets allow initial positioning of the new floating selection.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable from which to float selection
@item @emph{offset_x} (PDB_INT32)--X offset for translation
@item @emph{offset_y} (PDB_INT32)--Y offset for translation
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{layer} (PDB_LAYER)--The floated layer
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_grow image, steps
This procedure grows the selection.  Growing involves expanding the boundary in all directions by the specified pixel amount.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{steps} (PDB_INT32)--Steps of grow (pixels)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_invert image
This procedure inverts the selection mask.  For every pixel in the selection channel, its new value is calculated as (255 - old_value).--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_is_empty image
This procedure returns non-zero if the selection for the specified image is not empty.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{is_empty} (PDB_INT32)--Is the selection empty?
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_layer_alpha image, layer
This procedure requires a layer with an alpha channel.  The alpha channel information is used to create a selection mask such that for any pixel in the image defined in the specified layer, that layer pixel's alpha value is transferred to the selection mask.  If the layer is undefined at a particular image pixel, the associated selection mask value is set to 0.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{layer} (PDB_LAYER)--Layer with alpha
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_load image, channel
This procedure loads the specified channel into the selection mask.  This essentially involves a copy of the channel's content in to the selection mask.  Therefore, the channel must have the same width and height of the image, or an error is returned.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{channel} (PDB_CHANNEL)--The channel
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_none image
This procedure deselects the entire image.  Every pixel in the selection channel is set to 0.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_save image
This procedure copies the selection mask and stores the content in a new channel.  The new channel is automatically inserted into the image's list of channels.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{channel} (PDB_CHANNEL)--The new channel
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_sharpen image
This procedure sharpens the selection mask.  For every pixel in the selection channel, if the value is > 0, the new pixel is assigned a value of 255.  This removes any "anti-aliasing" that might exist in the selection mask's boundary.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_shrink image, radius
This procedure shrinks the selection.  Shrinking invovles trimming the existing selection boundary on all sides by the specified number of pixels.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{radius} (PDB_INT32)--Radius of shrink (pixels)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_translate image, offset_x, offset_y
This procedure actually translates the selection for the specified image by the specified offsets.  Regions that are translated from beyond the bounds of the image are set to empty.  Valid regions of the selection which are translated beyond the bounds of the image because of this call are lost.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{offset_x} (PDB_INT32)--X offset for translation
@item @emph{offset_y} (PDB_INT32)--Y offset for translation
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_selection_value image, x, y
This procedure returns the value of the selection at the specified coordinates.  If the coordinates lie out of bounds, 0 is returned.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{x} (PDB_INT32)--X coordinate of value
@item @emph{y} (PDB_INT32)--Y coordinate of value
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{value} (PDB_INT32)--Value of the selection: (0 <= value <= 255)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_shear image, drawable, interpolation, shear_type, magnitude
This tool shears the specified drawable if no selection exists.  If a selection exists, the portion of the drawable which lies under the selection is cut from the drawable and made into a floating selection which is then sheard by the specified amount.  The interpolation parameter can be set to TRUE to indicate that either linear or cubic interpolation should be used to smooth the resulting sheard drawable.  The return value is the ID of the sheard drawable.  If there was no selection, this will be equal to the drawable ID supplied as input.  Otherwise, this will be the newly created and sheard drawable.  The shear type parameter indicates whether the shear will be applied horizontally or vertically.  The magnitude can be either positive or negative and indicates the extent (in pixels) to shear by.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The affected drawable
@item @emph{interpolation} (PDB_INT32)--Whether to use interpolation
@item @emph{shear_type} (PDB_INT32)--Type of shear: @{ HORIZONTAL (0), VERTICAL (1) @}
@item @emph{magnitude} (PDB_FLOAT)--The magnitude of the shear
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{drawable} (PDB_DRAWABLE)--The sheard drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_temp_name extension
Generates a unique filename using the temp path supplied in the user's gimprc.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{extension} (PDB_STRING)--The extension the file will have.
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{name} (PDB_STRING)--The temp name.
@end itemize
@end defun
@emph{Josh MacDonald}

@defun gimp_text image, drawable, x, y, text, border, antialias, size, size_type, foundry, family, weight, slant, set_width, spacing
This tool requires font information in the form of seven parameters: @{size, foundry, family, weight, slant, set_width, spacing@}.  The font size can either be specified in units of pixels or points, and the appropriate metric is specified using the size
_type argument.  The x and y parameters together control the placement of the new text by specifying the upper left corner of the text bounding box.  If the antialias parameter is non-zero, the generated text will blend more smoothly with underlying layer
s.  This option requires more time and memory to compute than non-antialiased text; the resulting floating selection or layer, however, will require the same amount of memory with or without antialiasing.  If the specified drawable parameter is valid, the
 text will be created as a floating selection attached to the drawable.  If the drawable parameter is not valid (-1), the text will appear as a new layer.  Finally, a border can be specified around the final rendered text.  The border is measured in pixel
s.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The affected drawable: (-1 for a new text layer)
@item @emph{x} (PDB_FLOAT)--The x coordinate for the left side of text bounding box
@item @emph{y} (PDB_FLOAT)--The y coordinate for the top of text bounding box
@item @emph{text} (PDB_STRING)--The text to generate
@item @emph{border} (PDB_INT32)--The size of the border: border >= 0
@item @emph{antialias} (PDB_INT32)--Generate antialiased text
@item @emph{size} (PDB_FLOAT)--The size of text in either pixels or points
@item @emph{size_type} (PDB_INT32)--The units of the specified size: @{ PIXELS (0), POINTS (1) @}
@item @emph{foundry} (PDB_STRING)--The font foundry, "*" for any
@item @emph{family} (PDB_STRING)--The font family, "*" for any
@item @emph{weight} (PDB_STRING)--The font weight, "*" for any
@item @emph{slant} (PDB_STRING)--The font slant, "*" for any
@item @emph{set_width} (PDB_STRING)--The font set-width parameter, "*" for any
@item @emph{spacing} (PDB_STRING)--The font spacing, "*" for any
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{text_layer} (PDB_LAYER)--The new text layer
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_text_get_extents text, size, size_type, foundry, family, weight, slant, set_width, spacing
This tool returns the width and height of a bounding box for the specified text string with the specified font information.  Ascent and descent for the specified font are returned as well.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{text} (PDB_STRING)--The text to generate
@item @emph{size} (PDB_FLOAT)--The size of text in either pixels or points
@item @emph{size_type} (PDB_INT32)--The units of the specified size: @{ PIXELS (0), POINTS (1) @}
@item @emph{foundry} (PDB_STRING)--The font foundry, "*" for any
@item @emph{family} (PDB_STRING)--The font family, "*" for any
@item @emph{weight} (PDB_STRING)--The font weight, "*" for any
@item @emph{slant} (PDB_STRING)--The font slant, "*" for any
@item @emph{set_width} (PDB_STRING)--The font set-width parameter, "*" for any
@item @emph{spacing} (PDB_STRING)--The font spacing, "*" for any
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{width} (PDB_INT32)--The width of the specified text
@item @emph{height} (PDB_INT32)--The height of the specified text
@item @emph{ascent} (PDB_INT32)--The ascent of the specified font
@item @emph{descent} (PDB_INT32)--The descent of the specified font
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_threshold image, drawable, low_threshold, high_threshold
This procedures generates a threshold map of the specified drawable.  All pixels between the values of 'low_threshold' and 'high_threshold' are replaced with white, and all other pixels with black.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The image
@item @emph{drawable} (PDB_DRAWABLE)--The drawable
@item @emph{low_threshold} (PDB_INT32)--The low threshold value: (0 <= low_threshold <= 255)
@item @emph{high_threshold} (PDB_INT32)--The high threshold value: (0 <= high_threshold <= 255)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_undo_push_group_end image
This function must be called once for each undo_push_group call that is made.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The ID of the image in which to pop an undo group
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_undo_push_group_start image
This function is used to start a group undo--necessary for logically combining two or more undo operations into a single operation.  This call must be used in conjunction with a 'gimp_undo_push_group_end' call.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--The ID of the image in which to pop an undo group
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_xcf_load dummy_param, filename, raw_filename
The xcf file format has been designed specifically for loading and saving tiled and layered images in the GIMP. This procedure will load the specified file.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{dummy_param} (PDB_INT32)--Dummy parameter
@item @emph{filename} (PDB_STRING)--The name of the file to load
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun gimp_xcf_save dummy_param, image, drawable, filename, raw_filename
The xcf file format has been designed specifically for loading and saving tiled and layered images in the GIMP. This procedure will save the specified image in the xcf file format.--@strong{Internal GIMP procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{dummy_param} (PDB_INT32)--Dummy parameter
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Active drawable of input image
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{raw_filename} (PDB_STRING)--The name of the file to load
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun plug_in_CML_explorer run_mode, image, drawable, parameter_file_name
Make an image of Coupled-Map Lattice (CML). CML is a kind of Cellula Automata on continuous (value) domain. In RUN_NONINTERACTIVE, the name of a prameter file is passed as the 4th arg. You can control CML_explorer via parameter file.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (not used)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{parameter_file_name} (PDB_STRING)--The name of paremter file. CML_explorer makes an image with its settings.
@end itemize
@end defun
@emph{Shuji Narazaki (narazaki@@InetQ.or.jp); http://www.inetq.or.jp/~narazaki/TheGIMP/}

@defun plug_in_CentralReflection run_mode, image, drawable, circle_radius, keep_surroundings, set_background, set_transparent, use_antialias, flip
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{circle_radius} (PDB_FLOAT)--Radius of the reflecting circle
@item @emph{keep_surroundings} (PDB_INT32)--Keep Central-Reflection surroundings
@item @emph{set_background} (PDB_INT32)--Set Central-Reflection surroundings to bkgr value
@item @emph{set_transparent} (PDB_INT32)--Set Central-Reflection surroundings transparent (Only on Image w/ Alpha-Layer)
@item @emph{use_antialias} (PDB_INT32)--Use antialias for better and smoother results
@item @emph{flip} (PDB_INT32)--Flip the image vertically
@end itemize
@end defun
@emph{Daniel Cotting (cotting@@mygale.org, http://www.mygale.org/~cotting)}

@defun plug_in_Twist run_mode, image, drawable, a1, a2, a3, a4, a5, a6, a7, a8, lettering01, lettering02, lettering03, lettering04, lettering05, lettering06, lettering07, lettering08, use_cutoff, r, dr, current_function
Twist - Geometric image distortion--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{a1} (PDB_FLOAT)--Float parameter #1
@item @emph{a2} (PDB_FLOAT)--Float parameter #2
@item @emph{a3} (PDB_FLOAT)--Float parameter #3
@item @emph{a4} (PDB_FLOAT)--Float parameter #4
@item @emph{a5} (PDB_FLOAT)--Float parameter #5
@item @emph{a6} (PDB_FLOAT)--Float parameter #6
@item @emph{a7} (PDB_FLOAT)--Float parameter #7
@item @emph{a8} (PDB_FLOAT)--Float parameter #8
@item @emph{lettering01} (PDB_STRING)--Lettering #1
@item @emph{lettering02} (PDB_STRING)--Lettering #2
@item @emph{lettering03} (PDB_STRING)--Lettering #3
@item @emph{lettering04} (PDB_STRING)--Lettering #4
@item @emph{lettering05} (PDB_STRING)--Lettering #5
@item @emph{lettering06} (PDB_STRING)--Lettering #6
@item @emph{lettering07} (PDB_STRING)--Lettering #7
@item @emph{lettering08} (PDB_STRING)--Lettering #8
@item @emph{use_cutoff} (PDB_INT32)--Use cutoff or not
@item @emph{r} (PDB_FLOAT)--The cutoff radius
@item @emph{dr} (PDB_FLOAT)--The falloff radius
@item @emph{current_function} (PDB_INT32)--The current function
@end itemize
@end defun
@emph{Peter Uray}

@defun plug_in_alienmap run_mode, image, drawable, redstretch, greenstretch, bluestretch, redmode, greenmode, bluemode
No help yet. Just try it and you'll see!--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{redstretch} (PDB_INT8)--Red component stretching factor (0-128)
@item @emph{greenstretch} (PDB_INT8)--Green component stretching factor (0-128)
@item @emph{bluestretch} (PDB_INT8)--Blue component stretching factor (0-128)
@item @emph{redmode} (PDB_INT8)--Red application mode (0:SIN;1:COS;2:NONE)
@item @emph{greenmode} (PDB_INT8)--Green application mode (0:SIN;1:COS;2:NONE)
@item @emph{bluemode} (PDB_INT8)--Blue application mode (0:SIN;1:COS;2:NONE)
@end itemize
@end defun
@emph{Daniel Cotting (cotting@@mygale.org, http://www.mygale.org/~cotting)}

@defun plug_in_align_layers run_mode, image, drawable, link-afteer-alignment, use-bottom
align visible layers--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable (not used)
@item @emph{link-afteer-alignment} (PDB_INT32)--Link the visible layers after alignment
@item @emph{use-bottom} (PDB_INT32)--Use the bottom layer as the base of alignment
@end itemize
@end defun
@emph{Shuji Narazaki (narazaki@@InetQ.or.jp)}

@defun plug_in_anamorphose run_mode, image, drawable, cone_radius, base_angle, keep_surroundings, set_background, set_transparent, use_antialias, flip, double
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{cone_radius} (PDB_FLOAT)--Radius of the reflecting cone in the center
@item @emph{base_angle} (PDB_FLOAT)--Base angle of the reflecting cone (in degrees)
@item @emph{keep_surroundings} (PDB_INT32)--Keep anamorphose surroundings
@item @emph{set_background} (PDB_INT32)--Set anamorphose surroundings to bkgr value
@item @emph{set_transparent} (PDB_INT32)--Set anamorphose surroundings transparent (Only on Image w/ Alpha-Layer)
@item @emph{use_antialias} (PDB_INT32)--Use antialias for better and smoother results
@item @emph{flip} (PDB_INT32)--Flip the image vertically
@item @emph{double} (PDB_INT32)--Use double reflection algorithm
@end itemize
@end defun
@emph{Daniel Cotting (cotting@@mygale.org, http://www.mygale.org/~cotting)}

@defun plug_in_animationplay run_mode, image, drawable
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable (unused)
@end itemize
@end defun
@emph{Adam D. Moss <adam@@gimp.org>}

@defun plug_in_applylens run_mode, image, drawable, refraction, keep_surroundings, set_background, set_transparent
This plug-in uses Snell's law to draw an ellipsoid lens over the image--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{refraction} (PDB_FLOAT)--Lens refraction index
@item @emph{keep_surroundings} (PDB_INT32)--Keep lens surroundings
@item @emph{set_background} (PDB_INT32)--Set lens surroundings to bkgr value
@item @emph{set_transparent} (PDB_INT32)--Set lens surroundings transparent
@end itemize
@end defun
@emph{Morten Eriksen}

@defun plug_in_autocrop run_mode, image, drawable
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Tim Newsome}

@defun plug_in_autostretch_hsv run_mode, image, drawable
This simple plug-in does an automatic contrast stretch.  For each channel in the image, it finds the minimum and maximum values... it uses those values to stretch the individual histograms to the full contrast range.  For some images it may do just what you want; for others it may be total crap :).  This version differs from Contrast Autostretch in that it works in HSV space, and preserves hue.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Scott Goehring and Federico Mena Quintero}

@defun plug_in_blinds run_mode, image, drawable, angle_dsp, number_of_segments, orientation, backgndg_trans
More here later--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{angle_dsp} (PDB_INT32)--Angle of Displacement 
@item @emph{number_of_segments} (PDB_INT32)--Number of segments in blinds
@item @emph{orientation} (PDB_INT32)--Orientation; 0 = Horizontal, 1 = Vertical
@item @emph{backgndg_trans} (PDB_INT32)--Background transparent; FALSE,TRUE
@end itemize
@end defun
@emph{Andy Thomas}

@defun plug_in_blur run_mode, image, drawable
This function applies a 3x3 blurring convolution kernel to the specified drawable.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun plug_in_blur2 run_mode, image, drawable, mask_size
This function applies a NxN blurring convolution kernel to the specified drawable.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{mask_size} (PDB_INT32)--Blur mask size
@end itemize
@end defun
@emph{Torsten Martinsen}

@defun plug_in_bump_map run_mode, image, drawable, bumpmap, azimuth, elevation, depth, xofs, yofs, waterlevel, ambient, compensate, invert, type
This plug-in uses the algorithm described by John Schlag, "Fast Embossing Effects on Raster Image Data" in Graphics GEMS IV (ISBN 0-12-336155-9). It takes a grayscale image to be applied as a bump map to another image and produces a nice embossing effect.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{bumpmap} (PDB_DRAWABLE)--Bump map drawable
@item @emph{azimuth} (PDB_FLOAT)--Azimuth
@item @emph{elevation} (PDB_FLOAT)--Elevation
@item @emph{depth} (PDB_INT32)--Depth
@item @emph{xofs} (PDB_INT32)--X offset
@item @emph{yofs} (PDB_INT32)--Y offset
@item @emph{waterlevel} (PDB_INT32)--Level that full transparency should represent
@item @emph{ambient} (PDB_INT32)--Ambient lighting factor
@item @emph{compensate} (PDB_INT32)--Compensate for darkening
@item @emph{invert} (PDB_INT32)--Invert bumpmap
@item @emph{type} (PDB_INT32)--Type of map (LINEAR (0), SPHERICAL (1), SINUOSIDAL (2))
@end itemize
@end defun
@emph{Federico Mena Quintero and Jens Lautenbacher}

@defun plug_in_c_astretch run_mode, image, drawable
This simple plug-in does an automatic contrast stretch.  For each channel in the image, it finds the minimum and maximum values... it uses those values to stretch the individual histograms to the full contrast range.  For some images it may do just what you want; for others it may be total crap :)--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun plug_in_checkerboard run_mode, image, drawable, check_mode, check_size
More here later--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{check_mode} (PDB_INT32)--Regular or Physcobilly
@item @emph{check_size} (PDB_INT32)--Size of the checks
@end itemize
@end defun
@emph{Brent Burton & the Edward Blevins}

@defun plug_in_compose run_mode, image, drawable, image, image, image, compose_type
This function creates a new image from different channel informations kept in gray images--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--First input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable (not used)
@item @emph{image} (PDB_IMAGE)--Second input image
@item @emph{image} (PDB_IMAGE)--Third input image
@item @emph{image} (PDB_IMAGE)--Fourth input image
@item @emph{compose_type} (PDB_STRING)--What to compose: RGB, RGBA, HSV, CMY, CMYK
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{new_image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Peter Kirchgessner}

@defun plug_in_convmatrix run_mode, image, drawable
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Lauri Alanko}

@defun plug_in_coordmap run_mode, image, dst_drawable, src_drawable, x_drawable, y_drawable
Maps a source image to a destination image. For each position in the destination image, the luminosity of of the X map and the Y map at the same position are interpreted as coordinates. The pixel that is found at these coordinates in the source image is copied to the destination image.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{dst_drawable} (PDB_DRAWABLE)--Destination drawable
@item @emph{src_drawable} (PDB_DRAWABLE)--Source drawable, size must be 256x256
@item @emph{x_drawable} (PDB_DRAWABLE)--X drawable, size must be equal to dst_drawable.
@item @emph{y_drawable} (PDB_DRAWABLE)--Y drawable, size must be equal to dst_drawable.
@end itemize
@end defun
@emph{Michael Schubart}

@defun plug_in_cubism run_mode, image, drawable, tile_size, tile_saturation, bg_color
Help not yet written for this plug-in--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{tile_size} (PDB_FLOAT)--Average diameter of each tile (in pixels)
@item @emph{tile_saturation} (PDB_FLOAT)--Expand tiles by this amount
@item @emph{bg_color} (PDB_INT32)--Background color: @{ BLACK (0), BG (1) @}
@end itemize
@end defun
@emph{Spencer Kimball & Tracy Scott}

@defun plug_in_curtain run_mode, image, drawable, horizontal, vertical
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{horizontal} (PDB_INT32)--Horizontal curtain flag (TRUE/FALSE)
@item @emph{vertical} (PDB_INT32)--Vertical curtain flag (TRUE/FALSE)
@end itemize
@end defun
@emph{Daniel Cotting (cotting@@mygale.org, http://www.mygale.org/~cotting)}

@defun plug_in_decompose run_mode, image, drawable, decompose_type
This function creates new gray images with different channel information in each of them--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{decompose_type} (PDB_STRING)--What to decompose: RGB, Red, Green, Blue, HSV, Hue, Saturation, Value, CMY, Cyan, Magenta, Yellow, CMYK, Cyan_K, Magenta_K, Yellow_K, Alpha
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{new_image} (PDB_IMAGE)--Output gray image
@item @emph{new_image} (PDB_IMAGE)--Output gray image (N/A for single channel extract)
@item @emph{new_image} (PDB_IMAGE)--Output gray image (N/A for single channel extract)
@item @emph{new_image} (PDB_IMAGE)--Output gray image (N/A for single channel extract)
@end itemize
@end defun
@emph{Peter Kirchgessner}

@defun plug_in_deinterlace run_mode, image, drawable, evenodd
Deinterlace is useful for processing images from video capture cards. When only the odd or even fields get captured, deinterlace can be used to interpolate between the existing fields to correct this.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{evenodd} (PDB_INT32)--0 = keep odd, 1 = keep even
@end itemize
@end defun
@emph{Andrew Kieschnick}

@defun plug_in_depth_merge run_mode, image, result, source1, source2, depthMap1, depthMap2, overlap, offset, scale1, scale2
Taking as input two full-colour, full-alpha images and two corresponding grayscale depth maps, this plug-in combines the images based on which is closer (has a lower depth map value) at each point.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{result} (PDB_DRAWABLE)--Result
@item @emph{source1} (PDB_DRAWABLE)--Source 1
@item @emph{source2} (PDB_DRAWABLE)--Source 2
@item @emph{depthMap1} (PDB_DRAWABLE)--Depth map 1
@item @emph{depthMap2} (PDB_DRAWABLE)--Depth map 2
@item @emph{overlap} (PDB_FLOAT)--Overlap
@item @emph{offset} (PDB_FLOAT)--Depth relative offset
@item @emph{scale1} (PDB_FLOAT)--Depth relative scale 1
@item @emph{scale2} (PDB_FLOAT)--Depth relative scale 2
@end itemize
@end defun
@emph{Sean Cier}

@defun plug_in_despeckle run_mode, image, drawable, radius, type
This plug-in selectively performs a median or adaptive box filter on an image.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{radius} (PDB_INT32)--Filter box radius (default = 3)
@item @emph{type} (PDB_INT32)--Filter type (0 = median, 1 = adaptive, 2 = recursive-median, 3 = recursive-adaptive)
@end itemize
@end defun
@emph{Michael Sweet <mike@@easysw.com>}

@defun plug_in_destripe run_mode, image, drawable, avg_width
This plug-in selectively performs a median or adaptive box filter on an image.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{avg_width} (PDB_INT32)--Averaging filter width (default = 36)
@end itemize
@end defun
@emph{Marc Lehmann}

@defun plug_in_diffraction run_mode, image, drawable, lam_r, lam_g, lam_b, contour_r, contour_g, contour_b, edges_r, edges_g, edges_b, brightness, scattering, polarization
Help?  What help?  Real men do not need help :-)--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{lam_r} (PDB_FLOAT)--Light frequency (red)
@item @emph{lam_g} (PDB_FLOAT)--Light frequency (green)
@item @emph{lam_b} (PDB_FLOAT)--Light frequency (blue)
@item @emph{contour_r} (PDB_FLOAT)--Number of contours (red)
@item @emph{contour_g} (PDB_FLOAT)--Number of contours (green)
@item @emph{contour_b} (PDB_FLOAT)--Number of contours (blue)
@item @emph{edges_r} (PDB_FLOAT)--Number of sharp edges (red)
@item @emph{edges_g} (PDB_FLOAT)--Number of sharp edges (green)
@item @emph{edges_b} (PDB_FLOAT)--Number of sharp edges (blue)
@item @emph{brightness} (PDB_FLOAT)--Brightness and shifting/fattening of contours
@item @emph{scattering} (PDB_FLOAT)--Scattering (Speed vs. quality)
@item @emph{polarization} (PDB_FLOAT)--Polarization
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun plug_in_displace run_mode, image, drawable, amount_x, amount_y, do_x, do_y, displace_map_x, displace_map_y, displace_type
Displaces the contents of the specified drawable by the amounts specified by 'amount_x' and 'amount_y' multiplied by the intensity of corresponding pixels in the 'displace_map' drawables.  Both 'displace_map' drawables must be of type GRAY_IMAGE for this operation to succeed.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{amount_x} (PDB_FLOAT)--Displace multiplier for X direction
@item @emph{amount_y} (PDB_FLOAT)--Displace multiplier for Y direction
@item @emph{do_x} (PDB_INT32)--Displace in X direction?
@item @emph{do_y} (PDB_INT32)--Displace in Y direction?
@item @emph{displace_map_x} (PDB_DRAWABLE)--Displacement map for X direction
@item @emph{displace_map_y} (PDB_DRAWABLE)--Displacement map for Y direction
@item @emph{displace_type} (PDB_INT32)--Edge behavior: @{ WRAP (0), SMEAR (1), BLACK (2) @}
@end itemize
@end defun
@emph{Stephen Robert Norris & (ported to 1.0 by) Spencer Kimball}

@defun plug_in_edge run_mode, image, drawable, amount, wrapmode
 Perform edge detection on the contents of the specified drawable. It applies, I think, convolusion with 3x3 kernel. AMOUNT is an arbitrary constant, WRAPMODE is like displace plug-in (useful for tilable image).--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{amount} (PDB_FLOAT)--Edge detection amount
@item @emph{wrapmode} (PDB_INT32)--Edge detection behavior: @{ WRAP (0), SMEAR (1), BLACK (2) @}
@end itemize
@end defun
@emph{Peter Mattis & (ported to 1.0 by) Eiichi Takamori}

@defun plug_in_emboss run_mode, img, drw, azimuth, elevation, depth, embossp
Emboss or Bumpmap the given drawable, specifying the angle and elevation for the light source.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{img} (PDB_IMAGE)--The Image
@item @emph{drw} (PDB_DRAWABLE)--The Drawable
@item @emph{azimuth} (PDB_FLOAT)--The Light Angle (degrees)
@item @emph{elevation} (PDB_FLOAT)--The Elevation Angle (degrees)
@item @emph{depth} (PDB_INT32)--The Filter Width
@item @emph{embossp} (PDB_INT32)--Emboss or Bumpmap
@end itemize
@end defun
@emph{Eric L. Hernes, John Schlag}

@defun plug_in_encrypt run_mode, image, drawable, password, warning, compatibility, remember
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{password} (PDB_STRING)--Password (used to encrypt and decrypt)
@item @emph{warning} (PDB_INT8)--Disable warning message toggle (only in RUN_INTERACTIVE)
@item @emph{compatibility} (PDB_INT8)--Use version 1.0x compatibility mode
@item @emph{remember} (PDB_INT8)--Remember the password after execution
@end itemize
@end defun
@emph{Daniel Cotting (cotting@@mygale.org, http://www.mygale.org/~cotting)}

@defun plug_in_engrave run_mode, image, drawable, height, limit
More help--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{height} (PDB_INT32)--Resolution in pixels
@item @emph{limit} (PDB_INT32)--If true, limit line width
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis, Eiichi Takamori, Torsten Martinsen}

@defun plug_in_exchange run_mode, image, drawable, fromred, fromgreen, fromblue, tored, togreen, toblue, threshold
Exchange one color with another, optionally setting a threshold to convert from one shade to another--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{fromred} (PDB_INT8)--Red value (from)
@item @emph{fromgreen} (PDB_INT8)--Green value (from)
@item @emph{fromblue} (PDB_INT8)--Blue value (from)
@item @emph{tored} (PDB_INT8)--Red value (to)
@item @emph{togreen} (PDB_INT8)--Green value (to)
@item @emph{toblue} (PDB_INT8)--Blue value (to)
@item @emph{threshold} (PDB_INT8)--Threshold
@end itemize
@end defun
@emph{robert@@experimental.net}

@defun plug_in_figures run_mode, image, drawable, density, min_width, max_width, min_height, max_height
Can be nice to use as "textures".--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{density} (PDB_FLOAT)--Density
@item @emph{min_width} (PDB_INT32)--Min. width
@item @emph{max_width} (PDB_INT32)--Max. width
@item @emph{min_height} (PDB_INT32)--Min. height
@item @emph{max_height} (PDB_INT32)--Max. height
@end itemize
@end defun
@emph{Tim Newsome}

@defun plug_in_film run_mode, image, drawable, film_height, film_color, number_start, number_fontf, number_color, at_top, at_bottom, num_images, image_ids
Compose several images to a roll film--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (only used as default image in interactive mode)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable (not used)
@item @emph{film_height} (PDB_INT32)--Height of film (0: fit to images)
@item @emph{film_color} (PDB_COLOR)--Color of the film
@item @emph{number_start} (PDB_INT32)--Start index for numbering
@item @emph{number_fontf} (PDB_STRING)--Font family for drawing numbers
@item @emph{number_color} (PDB_COLOR)--Color for numbers
@item @emph{at_top} (PDB_INT32)--Flag for drawing numbers at top of film
@item @emph{at_bottom} (PDB_INT32)--Flag for drawing numbers at bottom of film
@item @emph{num_images} (PDB_INT32)--Number of images to be used for film
@item @emph{image_ids} (PDB_INT32ARRAY)--Num_images image IDs to be used for film
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{new_image} (PDB_IMAGE)--Output image
@end itemize
@end defun
@emph{Peter Kirchgessner}

@defun plug_in_filter_pack run_mode, image, drawable
Then something else here--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (used for indexed images)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Pavel Grinfeld (pavel@@ml.com)}

@defun plug_in_flame run_mode, image, drawable
use Smooth Palette to make colormaps--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Scott Draves}

@defun plug_in_fractal_trace run_mode, image, drawable, xmin, xmax, ymin, ymax, ymax, depth, outside_type
transform image with the Mandelbrot Fractal--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive / non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (not used)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{xmin} (PDB_FLOAT)--Xmin fractal image delimiter
@item @emph{xmax} (PDB_FLOAT)--Xmax fractal image delimiter
@item @emph{ymin} (PDB_FLOAT)--Ymin fractal image delimiter
@item @emph{ymax} (PDB_FLOAT)--Ymax fractal image delimiter
@item @emph{ymax} (PDB_FLOAT)--Ymax fractal image delimiter
@item @emph{depth} (PDB_INT32)--Trace depth
@item @emph{outside_type} (PDB_INT32)--Outside type(0=WRAP/1=TRANS/2=BLACK/3=WHITE)
@end itemize
@end defun
@emph{Hirotsuna Mizuno <s1041150@@u-aizu.ac.jp>}

@defun plug_in_fractalexplorer run_mode, image, drawable, fractaltype, xmin, xmax, ymin, ymax, iter, cx, cy, colormode, redstretch, greenstretch, bluestretch, redmode, greenmode, bluemode, redinvert, greeninvert, blueinvert
No help yet.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{fractaltype} (PDB_INT8)--0: Mandelbrot; 1: Julia; 2: Barnsley 1; 3: Barnsley 2; 4: Barnsley 3; 5: Spider; 6: ManOWar; 7: Lambda; 8: Sierpinski
@item @emph{xmin} (PDB_FLOAT)--Xmin fractal image delimiter
@item @emph{xmax} (PDB_FLOAT)--Xmax fractal image delimiter
@item @emph{ymin} (PDB_FLOAT)--Ymin fractal image delimiter
@item @emph{ymax} (PDB_FLOAT)--Ymax fractal image delimiter
@item @emph{iter} (PDB_FLOAT)--Iteration value
@item @emph{cx} (PDB_FLOAT)--Cx value ( only Julia)
@item @emph{cy} (PDB_FLOAT)--Cy value ( only Julia)
@item @emph{colormode} (PDB_INT8)--0: Apply colormap as specified by the parameters below; 1: Apply active gradient to final image
@item @emph{redstretch} (PDB_FLOAT)--Red stretching factor
@item @emph{greenstretch} (PDB_FLOAT)--Green stretching factor
@item @emph{bluestretch} (PDB_FLOAT)--Blue stretching factor
@item @emph{redmode} (PDB_INT8)--Red application mode (0:SIN;1:COS;2:NONE)
@item @emph{greenmode} (PDB_INT8)--Green application mode (0:SIN;1:COS;2:NONE)
@item @emph{bluemode} (PDB_INT8)--Blue application mode (0:SIN;1:COS;2:NONE)
@item @emph{redinvert} (PDB_INT8)--Red inversion mode (1: enabled; 0: disabled)
@item @emph{greeninvert} (PDB_INT8)--Green inversion mode (1: enabled; 0: disabled)
@item @emph{blueinvert} (PDB_INT8)--Green inversion mode (1: enabled; 0: disabled)
@end itemize
@end defun
@emph{Daniel Cotting (cotting@@mygale.org, www.mygale.org/~cotting)}

@defun plug_in_fuse run_mode, image, drawable
uhm, image dissociation--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Scott Draves}

@defun plug_in_gauss_iir run_mode, image, drawable, radius, horizontal, vertical
Applies a gaussian blur to the drawable, with specified radius of affect.  The standard deviation of the normal distribution used to modify pixel values is calculated based on the supplied radius.  Horizontal and vertical blurring can be independently invoked by specifying only one to run.  The IIR gaussian blurring works best for large radius values and for images which are not computer-generated.  Values for radius less than 1.0 are invalid as they will generate spurious results.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{radius} (PDB_FLOAT)--Radius of gaussian blur (in pixels > 1.0)
@item @emph{horizontal} (PDB_INT32)--Blur in horizontal direction
@item @emph{vertical} (PDB_INT32)--Blur in vertical direction
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun plug_in_gauss_rle run_mode, image, drawable, radius, horizontal, vertical
Applies a gaussian blur to the drawable, with specified radius of affect.  The standard deviation of the normal distribution used to modify pixel values is calculated based on the supplied radius.  Horizontal and vertical blurring can be independently invoked by specifying only one to run.  The RLE gaussian blurring performs most efficiently on computer-generated images or images with large areas of constant intensity.  Values for radii less than 1.0 are invalid as they will generate spurious results.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{radius} (PDB_FLOAT)--Radius of gaussian blur (in pixels > 1.0)
@item @emph{horizontal} (PDB_INT32)--Blur in horizontal direction
@item @emph{vertical} (PDB_INT32)--Blur in vertical direction
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun plug_in_gfig run_mode, image, drawable, dummy
More here later--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{dummy} (PDB_INT32)--Dummy
@end itemize
@end defun
@emph{Andy Thomas}

@defun plug_in_gflare run_mode, image, drawable, gflare_name, xcenter, ycenter, radius, rotation, hue, vangle, vlength, use_asupsample, asupsample_max_depth, asupsample_threshold
 This plug-in produces a lense flare effect using custom gradients. In interactive call, the user can edit his/her own favorite lense flare (GFlare) and render it. Edited gflare is saved automatically to the directory in gflare-path, if it is defined in gimprc. In non-interactive call, the user can only render one of GFlare which has been stored in gflare-path already.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{gflare_name} (PDB_STRING)--The name of GFlare
@item @emph{xcenter} (PDB_INT32)--X coordinate of center of GFlare
@item @emph{ycenter} (PDB_INT32)--Y coordinate of center of GFlare
@item @emph{radius} (PDB_FLOAT)--Radius of GFlare (pixel)
@item @emph{rotation} (PDB_FLOAT)--Rotation of GFlare (degree)
@item @emph{hue} (PDB_FLOAT)--Hue rotation of GFlare (degree)
@item @emph{vangle} (PDB_FLOAT)--Vector angle for second flares (degree)
@item @emph{vlength} (PDB_FLOAT)--Vector length for second flares (percentage to Radius)
@item @emph{use_asupsample} (PDB_INT32)--Whether it uses or not adaptive supersampling while rendering (boolean)
@item @emph{asupsample_max_depth} (PDB_INT32)--Max depth for adaptive supersampling
@item @emph{asupsample_threshold} (PDB_FLOAT)--Threshold for adaptive supersampling
@end itemize
@end defun
@emph{Eiichi Takamori}

@defun plug_in_glasstile run_mode, image, drawable, tilex, tiley
More here later--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{tilex} (PDB_INT32)--Tile width (10 - 50)
@item @emph{tiley} (PDB_INT32)--Tile height (10 - 50)
@end itemize
@end defun
@emph{Karl-Johan Andersson}

@defun plug_in_gradmap run_mode, image, drawable
 This plug-in maps the contents of the specified drawable with active gradient. It calculates luminosity of each pixel and replaces the pixel by the sample of active gradient at the position proportional to that luminosity. Complete black pixel becomes the leftmost color of the gradient, and complete white becomes the rightmost. Works on both Grayscale and RGB image with/without alpha channel.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Eiichi Takamori}

@defun plug_in_grid run_mode, image, drawable, width, height, x_offset, y_offset
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{width} (PDB_INT32)--Width
@item @emph{height} (PDB_INT32)--Height
@item @emph{x_offset} (PDB_INT32)--X Offset
@item @emph{y_offset} (PDB_INT32)--Y Offset
@end itemize
@end defun
@emph{Tim Newsome}

@defun plug_in_holes run_mode, image, drawable, density, shape, size, flag
makes holes in the alpha channel of an image, with a density depending on the actual transparency of this image. (so the image must have an alpha channel...)--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{density} (PDB_FLOAT)--Density (actually the log of the density)
@item @emph{shape} (PDB_INT32)--Shape (0= square, 1= round, 2= diamond)
@item @emph{size} (PDB_INT32)--Size (in pixels)
@item @emph{flag} (PDB_INT32)--Clear it if you want to make holes in your image, or set it if you want to keep the painted (I mean opaque) regions.
@end itemize
@end defun
@emph{Xavier Bouchoux}

@defun plug_in_hot run_mode, image, drawable
hot scans an image for pixels that will give unsave values of chrominance or composite signale amplitude when encoded into an NTSC or PAL signal.  Three actions can be performed on these ``hot'' pixels. (0) reduce luminance, (1) reduce saturation, or (2) Blacken.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--The Image
@item @emph{drawable} (PDB_DRAWABLE)--The Drawable
@end itemize
@end defun
@emph{Eric L. Hernes, Alan Wm Paeth}

@defun plug_in_ifs_compose run_mode, image, drawable
Interactively create an Iterated Function System fractal.Use the window on the upper left to adjust the componenttransformations of the fractal. The operation that is performedis selected by the buttons underneath the window, or from amenu popped up by the right mouse button. The fractal will berendered with a transparent background if the current image hasa transparent background.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Owen Taylor}

@defun plug_in_illusion run_mode, image, drawable, division
produce illusion--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive / non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{division} (PDB_INT32)--The number of divisions
@end itemize
@end defun
@emph{Hirotsuna Mizuno <s1041150@@u-aizu.ac.jp>}

@defun plug_in_image_rot270 run_mode, image, drawable
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Adam D. Moss (adam@@gimp.org)}

@defun plug_in_image_rot90 run_mode, image, drawable
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Adam D. Moss (adam@@gimp.org)}

@defun plug_in_iwarp run_mode, image, drawable
Interactive warping of the specified drawable --@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Norbert Schmitz}

@defun plug_in_julia run_mode, image, drawable, xmin, xmax, ymin, ymax, iter, cx, cy, colormode, redstretch, greenstretch, bluestretch, redmode, greenmode, bluemode
Fills the active painting area with a Julia fractal.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{xmin} (PDB_FLOAT)--Xmin fractal image delimiter
@item @emph{xmax} (PDB_FLOAT)--Xmax fractal image delimiter
@item @emph{ymin} (PDB_FLOAT)--Ymin fractal image delimiter
@item @emph{ymax} (PDB_FLOAT)--Ymax fractal image delimiter
@item @emph{iter} (PDB_FLOAT)--Iteration value
@item @emph{cx} (PDB_FLOAT)--Cx value
@item @emph{cy} (PDB_FLOAT)--Cy value
@item @emph{colormode} (PDB_INT8)--0: Apply colormap as specified by the parameters below; 1: Apply active gradient to final image
@item @emph{redstretch} (PDB_FLOAT)--Red stretching factor
@item @emph{greenstretch} (PDB_FLOAT)--Green stretching factor
@item @emph{bluestretch} (PDB_FLOAT)--Blue stretching factor
@item @emph{redmode} (PDB_INT8)--Red application mode (0:SIN;1:COS;2:NONE)
@item @emph{greenmode} (PDB_INT8)--Green application mode (0:SIN;1:COS;2:NONE)
@item @emph{bluemode} (PDB_INT8)--Blue application mode (0:SIN;1:COS;2:NONE)
@end itemize
@end defun
@emph{Daniel Cotting (cotting@@mygale.org, www.mygale.org/~cotting)}

@defun plug_in_laplace run_mode, image, drawable
This plugin creates one-pixel wide edges from the image, with the value proportional to the gradient. It uses the Laplace operator (a 3x3 kernel with -8 in the middle)The image has to be laplacered to get usefull results, a gauss_iir with 1.5 - 5.0 depending on the noise in the image is best--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Thorsten Schnier}

@defun plug_in_layer_rot270 run_mode, image, drawable
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Adam D. Moss (adam@@gimp.org)}

@defun plug_in_layer_rot90 run_mode, image, drawable
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Adam D. Moss (adam@@gimp.org)}

@defun plug_in_lic run_mode, image, drawable
No help yet--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Tom Bech & Federico Mena Quintero}

@defun plug_in_magic_eye run_mode, image, drawable, mapimage
Create a stereogram--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{mapimage} (PDB_INT32)--Map Image
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{new_image} (PDB_IMAGE)--Output image
@item @emph{new_layer} (PDB_IMAGE)--Output layer
@end itemize
@end defun
@emph{Alexander Schulz}

@defun plug_in_mail_image run_mode, image, drawable, filename, receipt, subject, comment, encapsulation
You need to have uuencode and mail installed--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to save
@item @emph{filename} (PDB_STRING)--The name of the file to save the image in
@item @emph{receipt} (PDB_STRING)--The email address to send to
@item @emph{subject} (PDB_STRING)--The subject
@item @emph{comment} (PDB_STRING)--The Comment
@item @emph{encapsulation} (PDB_INT32)--Uuencode, MIME
@end itemize
@end defun
@emph{Adrian Likins, Reagan Blundell}

@defun plug_in_mandelbrot run_mode, image, drawable, xmin, xmax, ymin, ymax, iter, colormode, redstretch, greenstretch, bluestretch, redmode, greenmode, bluemode
Fills the active painting area with a Mandelbrot fractal.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{xmin} (PDB_FLOAT)--Xmin fractal image delimiter
@item @emph{xmax} (PDB_FLOAT)--Xmax fractal image delimiter
@item @emph{ymin} (PDB_FLOAT)--Ymin fractal image delimiter
@item @emph{ymax} (PDB_FLOAT)--Ymax fractal image delimiter
@item @emph{iter} (PDB_FLOAT)--Iteration value
@item @emph{colormode} (PDB_INT8)--0: Apply colormap as specified by the parameters below; 1: Apply active gradient to final image
@item @emph{redstretch} (PDB_FLOAT)--Red stretching factor
@item @emph{greenstretch} (PDB_FLOAT)--Green stretching factor
@item @emph{bluestretch} (PDB_FLOAT)--Blue stretching factor
@item @emph{redmode} (PDB_INT8)--Red application mode (0:SIN;1:COS;2:NONE)
@item @emph{greenmode} (PDB_INT8)--Green application mode (0:SIN;1:COS;2:NONE)
@item @emph{bluemode} (PDB_INT8)--Blue application mode (0:SIN;1:COS;2:NONE)
@end itemize
@end defun
@emph{Daniel Cotting (cotting@@mygale.org, www.mygale.org/~cotting)}

@defun plug_in_map_object run_mode, image, drawable, maptype, viewpoint_x, viewpoint_y, viewpoint_z, position_x, position_y, position_z, firstaxis_x, firstaxis_y, firstaxis_z, secondaxis_x, secondaxis_y, secondaxis_z, rotationangle_x, rotationangle_y, rotationangle_z, lighttype, lightcolor, lightposition_x, lightposition_y, lightposition_z, lightdirection_x, lightdirection_y, lightdirection_z, ambient_intensity, diffuse_intensity, diffuse_reflectivity, specular_reflectivity, highlight, antialiasing, tiled, newimage, transparentbackground, radius
No help yet--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive (0), non-interactive (1)
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{maptype} (PDB_INT32)--Type of mapping (0=plane,1=sphere)
@item @emph{viewpoint_x} (PDB_FLOAT)--Position of viewpoint (x,y,z)
@item @emph{viewpoint_y} (PDB_FLOAT)--Position of viewpoint (x,y,z)
@item @emph{viewpoint_z} (PDB_FLOAT)--Position of viewpoint (x,y,z)
@item @emph{position_x} (PDB_FLOAT)--Object position (x,y,z)
@item @emph{position_y} (PDB_FLOAT)--Object position (x,y,z)
@item @emph{position_z} (PDB_FLOAT)--Object position (x,y,z)
@item @emph{firstaxis_x} (PDB_FLOAT)--First axis of object [x,y,z]
@item @emph{firstaxis_y} (PDB_FLOAT)--First axis of object [x,y,z]
@item @emph{firstaxis_z} (PDB_FLOAT)--First axis of object [x,y,z]
@item @emph{secondaxis_x} (PDB_FLOAT)--Second axis of object [x,y,z]
@item @emph{secondaxis_y} (PDB_FLOAT)--Second axis of object [x,y,z]
@item @emph{secondaxis_z} (PDB_FLOAT)--Second axis of object [x,y,z]
@item @emph{rotationangle_x} (PDB_FLOAT)--Axis rotation (xy,xz,yz) in degrees
@item @emph{rotationangle_y} (PDB_FLOAT)--Axis rotation (xy,xz,yz) in degrees
@item @emph{rotationangle_z} (PDB_FLOAT)--Axis rotation (xy,xz,yz) in degrees
@item @emph{lighttype} (PDB_INT32)--Type of lightsource (0=point,1=directional,3=none)
@item @emph{lightcolor} (PDB_COLOR)--Lightsource color (r,g,b)
@item @emph{lightposition_x} (PDB_FLOAT)--Lightsource position (x,y,z)
@item @emph{lightposition_y} (PDB_FLOAT)--Lightsource position (x,y,z)
@item @emph{lightposition_z} (PDB_FLOAT)--Lightsource position (x,y,z)
@item @emph{lightdirection_x} (PDB_FLOAT)--Lightsource direction [x,y,z]
@item @emph{lightdirection_y} (PDB_FLOAT)--Lightsource direction [x,y,z]
@item @emph{lightdirection_z} (PDB_FLOAT)--Lightsource direction [x,y,z]
@item @emph{ambient_intensity} (PDB_FLOAT)--Material ambient intensity (0..1)
@item @emph{diffuse_intensity} (PDB_FLOAT)--Material diffuse intensity (0..1)
@item @emph{diffuse_reflectivity} (PDB_FLOAT)--Material diffuse reflectivity (0..1)
@item @emph{specular_reflectivity} (PDB_FLOAT)--Material specular reflectivity (0..1)
@item @emph{highlight} (PDB_FLOAT)--Material highlight (0..->), note: it's expotential
@item @emph{antialiasing} (PDB_INT32)--Apply antialiasing (TRUE/FALSE)
@item @emph{tiled} (PDB_INT32)--Tile source image (TRUE/FALSE)
@item @emph{newimage} (PDB_INT32)--Create a new image (TRUE/FALSE)
@item @emph{transparentbackground} (PDB_INT32)--Make background transparent (TRUE/FALSE)
@item @emph{radius} (PDB_FLOAT)--Sphere radius (only used when maptype=1)
@end itemize
@end defun
@emph{Tom Bech & Federico Mena Quintero}

@defun plug_in_max_rgb run_mode, image, drawable, max_p
the help is not yet written for this plug-in--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (not used)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{max_p} (PDB_INT32)--1 for maximizing, 0 for minimizing
@end itemize
@end defun
@emph{Shuji Narazaki (narazaki@@InetQ.or.jp)}

@defun plug_in_maze run_mode, image, drawable, mazep_size, maze_rseed, maze_multiple, maze_offset
Generates a maze using the depth-first search method.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{mazep_size} (PDB_INT32)--Size of the passages
@item @emph{maze_rseed} (PDB_INT32)--Random Seed
@item @emph{maze_multiple} (PDB_INT32)--Multiple (use 57)
@item @emph{maze_offset} (PDB_INT32)--Offset (use 1)
@end itemize
@end defun
@emph{Kevin Turner <kevint@@poboxes.com>}

@defun plug_in_mblur run_mode, image, drawable, type, length, angle
This plug-in simulates the effect seen when photographing amoving object at a slow shutter speed.Done by adding multiple displaced copies.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{type} (PDB_INT32)--Type of motion blur (0 - linear, 1 - radial, 2 - zoom)
@item @emph{length} (PDB_INT32)--Length
@item @emph{angle} (PDB_INT32)--Angle
@end itemize
@end defun
@emph{Torsten Martinsen, Federico Mena Quintero and Daniel Skarda}

@defun plug_in_mosaic run_mode, image, drawable, tile_size, tile_height, tile_spacing, tile_neatness, light_dir, color_variation, antialiasing, color_averaging, tile_type, tile_surface, grout_color
Help not yet written for this plug-in--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{tile_size} (PDB_FLOAT)--Average diameter of each tile (in pixels)
@item @emph{tile_height} (PDB_FLOAT)--Apparent height of each tile (in pixels)
@item @emph{tile_spacing} (PDB_FLOAT)--Inter-tile spacing (in pixels)
@item @emph{tile_neatness} (PDB_FLOAT)--Deviation from perfectly formed tiles (0.0 - 1.0)
@item @emph{light_dir} (PDB_FLOAT)--Direction of light-source (in degrees)
@item @emph{color_variation} (PDB_FLOAT)--Magnitude of random color variations (0.0 - 1.0)
@item @emph{antialiasing} (PDB_INT32)--Enables smoother tile output at the cost of speed
@item @emph{color_averaging} (PDB_INT32)--Tile color based on average of subsumed pixels
@item @emph{tile_type} (PDB_INT32)--Tile geometry: @{ SQUARES (0), HEXAGONS (1), OCTAGONS (2) @}
@item @emph{tile_surface} (PDB_INT32)--Surface characteristics: @{ SMOOTH (0), ROUGH (1) @}
@item @emph{grout_color} (PDB_INT32)--Grout color (black/white or fore/background): @{ BW (0), FG_BG (1) @}
@end itemize
@end defun
@emph{Spencer Kimball}

@defun plug_in_nlfilt run_mode, img, drw, alpha, radius, filter
This is the pnmnlfilt, in gimp's clothing.  See the pnmnlfilt manpage for details.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{img} (PDB_IMAGE)--The Image to Filter
@item @emph{drw} (PDB_DRAWABLE)--The Drawable
@item @emph{alpha} (PDB_FLOAT)--The amount of the filter to apply
@item @emph{radius} (PDB_FLOAT)--The filter radius
@item @emph{filter} (PDB_INT32)--The Filter to Run, 0 - alpha trimmed mean; 1 - optimal estimation (alpha controls noise variance); 2 - edge enhancement
@end itemize
@end defun
@emph{Graeme W. Gill, gimp 0.99 plugin by Eric L. Hernes}

@defun plug_in_noisify run_mode, image, drawable, independent, noise_1, noise_2, noise_3, noise_4
More here later--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{independent} (PDB_INT32)--Noise in channels independent
@item @emph{noise_1} (PDB_FLOAT)--Noise in the first channel (red, gray)
@item @emph{noise_2} (PDB_FLOAT)--Noise in the second channel (green, gray_alpha)
@item @emph{noise_3} (PDB_FLOAT)--Noise in the third channel (blue)
@item @emph{noise_4} (PDB_FLOAT)--Noise in the fourth channel (alpha)
@end itemize
@end defun
@emph{Torsten Martinsen}

@defun plug_in_normalize run_mode, image, drawable
This plugin performs almost the same operation as the 'contrast autostretch' plugin, except that it won't allow the colour channels to normalize independently.  This is actually what most people probably want instead of contrast-autostretch; use c-a only if you wish to remove an undesirable colour-tint from a source image which is supposed to contain pure-white and pure-black.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Adam D. Moss, Federico Mena Quintero}

@defun plug_in_nova run_mode, image, drawable, xcenter, ycenter, color, radius, nspoke
 This plug-in produces an effect like a supernova burst. The amount of the light effect is approximately in proportion to 1/r, where r is the distance from the center of the star. It works with RGB*, GRAY* image.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{xcenter} (PDB_INT32)--X coordinates of the center of supernova
@item @emph{ycenter} (PDB_INT32)--Y coordinates of the center of supernova
@item @emph{color} (PDB_COLOR)--Color of supernova
@item @emph{radius} (PDB_INT32)--Radius of supernova
@item @emph{nspoke} (PDB_INT32)--Number of spokes
@end itemize
@end defun
@emph{Eiichi Takamori}

@defun plug_in_oilify run_mode, image, drawable, mask_size
This function performs the well-known oil-paint effect on the specified drawable.  The size of the input mask is specified by 'mask_size'.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{mask_size} (PDB_INT32)--Oil paint mask size
@end itemize
@end defun
@emph{Torsten Martinsen}

@defun plug_in_paper_tile run_mode, image, drawable, width, height, slide_length, bg_type
cut and slide image--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive / non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{width} (PDB_INT32)--Tile width
@item @emph{height} (PDB_INT32)--Tile height
@item @emph{slide_length} (PDB_INT32)--Slide length
@item @emph{bg_type} (PDB_INT32)--Background color (0=transparent, 1=black, 2=white )
@end itemize
@end defun
@emph{Hirotsuna Mizuno <s1041150@@u-aizu.ac.jp>}

@defun plug_in_pixelize run_mode, image, drawable, pixelwidth
Pixelize the contents of the specified drawable with speficied pixelizing width.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{pixelwidth} (PDB_INT32)--Pixel width	 (the decrease in resolution)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis, Tracy Scott, (ported to 1.0 by) Eiichi Takamori}

@defun plug_in_plasma run_mode, image, drawable, seed, turbulence
More help--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{seed} (PDB_INT32)--Random seed
@item @emph{turbulence} (PDB_FLOAT)--Turbulence of plasma
@end itemize
@end defun
@emph{Stephen Norris & (ported to 1.0 by) Eiichi Takamori}

@defun plug_in_polar_coords run_mode, image, drawable, circle, angle, backwards, inverse, polrec
Remaps and image from rectangular coordinates to polar coordinats or vice versa--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{circle} (PDB_FLOAT)--Circle depth in %
@item @emph{angle} (PDB_FLOAT)--Offset angle
@item @emph{backwards} (PDB_INT8)--Map backwards?
@item @emph{inverse} (PDB_INT8)--Map from top?
@item @emph{polrec} (PDB_INT8)--Polar to rectangular?
@end itemize
@end defun
@emph{Daniel Dunbar and Federico Mena Quintero}

@defun plug_in_qbist run_mode, image, drawable
This Plug-in is based on an article by Jrn Loviscach. It generates modern art pictures from a random genetic formula.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Jrn Loviscach, Jens Ch. Restemeier}

@defun plug_in_randomize run_mode, image, drawable, rndm_type, rndm_pct, rndm_rcount
This function randomly ``blurs'' the specified drawable, using either a 3x3 blur, picking a nearby pixel, slurring (cheezy melting), or hurling (spewing colors).  The type and percentage are user selectable.  Blurring is not supported for indexed images.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{rndm_type} (PDB_INT32)--Randomization type
@item @emph{rndm_pct} (PDB_FLOAT)--Randomization percentage
@item @emph{rndm_rcount} (PDB_FLOAT)--Repeat count
@end itemize
@end defun
@emph{Miles O'Neal  <meo@@rru.com>  http://www.rru.com/~meo/}

@defun plug_in_refract run_mode, image, drawable, lensmap, thick, dist, na, nb, edge, newl, xofs, yofs
Distorts the image by refracting it through a height field 'lens' with a specified index of refraction.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{lensmap} (PDB_DRAWABLE)--Lens map drawable
@item @emph{thick} (PDB_INT32)--Lens thickness
@item @emph{dist} (PDB_INT32)--Lens distance from image
@item @emph{na} (PDB_FLOAT)--Index of Refraction A
@item @emph{nb} (PDB_FLOAT)--Index of Refraction B
@item @emph{edge} (PDB_INT32)--Background (0), Outside (1), Wrap (2)
@item @emph{newl} (PDB_INT32)--New layer?
@item @emph{xofs} (PDB_INT32)--X offset
@item @emph{yofs} (PDB_INT32)--Y offset
@end itemize
@end defun
@emph{Kevin Turner <kevint@@poboxes.com>}

@defun plug_in_ripple run_mode, image, drawable, period, amplitude, orientation, edges, waveform, antialias, tile
Ripples the pixels of the specified drawable. Each row or colum will be displaced a certain number of pixels coinciding with the given wave form--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{period} (PDB_INT32)--Period; number of pixels for one wave to complete
@item @emph{amplitude} (PDB_INT32)--Amplitude; maximum displacement of wave
@item @emph{orientation} (PDB_INT32)--Orientation; 0 = Horizontal, 1 = Vertical
@item @emph{edges} (PDB_INT32)--Edges; 0 = smear, 1 =  wrap, 2 = black
@item @emph{waveform} (PDB_INT32)--0 = sawtooth, 1 = sine wave
@item @emph{antialias} (PDB_INT32)--Antialias; True or False
@item @emph{tile} (PDB_INT32)--Tile; if this is true, the image will retain it's tilability
@end itemize
@end defun
@emph{Brian Degenhardt <bdegenha@@ucsd.edu>}

@defun plug_in_rotate run_mode, image, drawable, angle, everything
This plug-in does rotate the active layer or the whole image clockwise by multiples of 90 degrees. When the whole image is choosen, the image is resized if necessary.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{angle} (PDB_INT32)--Angle @{ 90 (1), 180 (2), 270 (3) @}
@item @emph{everything} (PDB_INT32)--Rotate the whole image? @{ TRUE, FALSE @}
@end itemize
@end defun
@emph{Sven Neumann (neumanns@@uni-duesseldorf.de)}

@defun plug_in_scatter_hsv run_mode, image, drawable, holdness, hue_distance, saturation_distance, value_distance
Scattering pixel values in HSV space--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (not used)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{holdness} (PDB_INT32)--Convolution strength
@item @emph{hue_distance} (PDB_INT32)--Distribution distance on hue axis [0,255]
@item @emph{saturation_distance} (PDB_INT32)--Distribution distance on saturation axis [0,255]
@item @emph{value_distance} (PDB_INT32)--Distribution distance on value axis [0,255]
@end itemize
@end defun
@emph{Shuji Narazaki (narazaki@@InetQ.or.jp)}

@defun plug_in_sharpen run_mode, image, drawable, percent
This plug-in selectively performs a convolution filter on an image.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{percent} (PDB_INT32)--Percent sharpening (default = 10)
@end itemize
@end defun
@emph{Michael Sweet <mike@@easysw.com>}

@defun plug_in_shift run_mode, image, drawable, shift_amount, orientation
Shifts the pixels of the specified drawable. Each row will be displaced a random value of pixels.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{shift_amount} (PDB_INT32)--Shift amount (0 <= shift_amount_x <= 200)
@item @emph{orientation} (PDB_INT32)--Vertical, horizontal orientation
@end itemize
@end defun
@emph{Spencer Kimball and Peter Mattis, ported by Brian Degenhardt and Federico Mena Quintero}

@defun plug_in_signature run_mode, image, drawable, signature[50], e-mail[30], homepage[50], date[20], mode, licence, contents
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{signature[50]} (PDB_STRING)--Signature (Name of author, company etc.)
@item @emph{e-mail[30]} (PDB_STRING)--E-mail address
@item @emph{homepage[50]} (PDB_STRING)--Address of the homepage
@item @emph{date[20]} (PDB_STRING)--Date of creation
@item @emph{mode} (PDB_INT8)--FALSE: Write signature; TRUE: Read signature
@item @emph{licence} (PDB_INT8)--FALSE: Freely distributable; TRUE: Restricted distribution
@item @emph{contents} (PDB_INT8)--TRUE: Adult only contents
@end itemize
@end defun
@emph{Daniel Cotting (cotting@@mygale.org, http://www.mygale.org/~cotting)}

@defun plug_in_sinus run_mode, image, drawable, xscale, yscale, complex, seed, tiling, perturb, colors, alpha1, alpha2, blend, blend_power
FIX ME: sinus help--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{xscale} (PDB_FLOAT)--Scale value for x axis
@item @emph{yscale} (PDB_FLOAT)--Scale value dor y axis
@item @emph{complex} (PDB_FLOAT)--Complexity factor
@item @emph{seed} (PDB_INT32)--Seed value for random number generator
@item @emph{tiling} (PDB_INT32)--If set, the pattern generated will tile
@item @emph{perturb} (PDB_INT32)--If set, the pattern is a little more distorted...
@item @emph{colors} (PDB_INT32)--Where to take the colors (0= B&W,  1= fg/bg, 2= col1/col2)
@item @emph{alpha1} (PDB_FLOAT)--Alpha for the first color (used if the drawable has an alpha chanel)
@item @emph{alpha2} (PDB_FLOAT)--Alpha for the second color (used if the drawable has an alpha chanel)
@item @emph{blend} (PDB_INT32)--0= linear, 1= bilinear, 2= sinusoidal
@item @emph{blend_power} (PDB_FLOAT)--Power used to strech the blend
@end itemize
@end defun
@emph{Xavier Bouchoux}

@defun plug_in_smooth_palette run_mode, image, drawable
help!--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Scott Draves}

@defun plug_in_sobel run_mode, image, drawable, horizontal, vertical, keep_sign
This plugin calculates the gradient with a sobel operator. The user can specify which direction to use. When both directions are used, the result is the RMS of the two gradients; if only one direction is used, the result either the absolut value of the gradient, or 127 + gradient (if the 'keep sign' switch is on). This way, information about the direction of the gradient is preserved. Resulting images are not autoscaled.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{horizontal} (PDB_INT32)--Sobel in horizontal direction
@item @emph{vertical} (PDB_INT32)--Sobel in vertical direction
@item @emph{keep_sign} (PDB_INT32)--Keep sign of result (one direction only)
@end itemize
@end defun
@emph{Thorsten Schnier}

@defun plug_in_solid_noise run_mode, image, drawable, tilable, turbulent, seed, detail, xsize, ysize
Generates 2D textures using Perlin's classic solid noise function.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{tilable} (PDB_INT32)--Create a tilable output (n=0/y=1)
@item @emph{turbulent} (PDB_INT32)--Make a turbulent noise (n=0/y=1)
@item @emph{seed} (PDB_INT32)--Random seed
@item @emph{detail} (PDB_INT32)--Detail level (0 - 15)
@item @emph{xsize} (PDB_FLOAT)--Horizontal texture size
@item @emph{ysize} (PDB_FLOAT)--Vertical texture size
@end itemize
@end defun
@emph{Marcelo de Gomensoro Malheiros}

@defun plug_in_sparkle run_mode, image, drawable, lum_threshold, flare_inten, spike_len, spike_pts, spike_angle
More here later--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{lum_threshold} (PDB_FLOAT)--Luminosity threshold (0.0 - 1.0)
@item @emph{flare_inten} (PDB_FLOAT)--Flare intensity (0.0 - 1.0)
@item @emph{spike_len} (PDB_FLOAT)--Spike length (in pixels)
@item @emph{spike_pts} (PDB_INT32)--# of spike points
@item @emph{spike_angle} (PDB_FLOAT)--Spike angle (0.0-360.0 degrees)
@end itemize
@end defun
@emph{John Beale, & (ported to GIMP v0.54) Michael J. Hammel & (ported to GIMP v1.0) Spencer Kimball}

@defun plug_in_spread run_mode, image, drawable, spread_amount_x, spread_amount_y
Spreads the pixels of the specified drawable.  Pixels are randomly moved to another location whose distance varies from the original by the horizontal and vertical spread amounts --@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{spread_amount_x} (PDB_FLOAT)--Horizontal spread amount (0 <= spread_amount_x <= 200)
@item @emph{spread_amount_y} (PDB_FLOAT)--Vertical spread amount (0 <= spread_amount_y <= 200)
@end itemize
@end defun
@emph{Spencer Kimball and Peter Mattis, ported by Brian Degenhardt and Federico Mena Quintero}

@defun plug_in_stegano run_mode, image, drawable, mode, filename[128]
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{mode} (PDB_INT8)--FALSE: Hide file in image; TRUE: Get hidden file
@item @emph{filename[128]} (PDB_STRING)--Name of the file to hide in an image (only of importance if mode=FALSE
@end itemize
@end defun
@emph{Daniel Cotting (cotting@@mygale.org, http://www.mygale.org/~cotting)}

@defun plug_in_stereogram run_mode, image, heightmap, type, pat
Based on the Stereogram FAQ--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input Image
@item @emph{heightmap} (PDB_DRAWABLE)--Height Map
@item @emph{type} (PDB_INT32)--Type of stereogram
@item @emph{pat} (PDB_DRAWABLE)--Pattern to use for stereogram
@end itemize
@end defun
@emph{Francisco Bustamante}

@defun plug_in_struc run_mode, image, drawable, direction, depth
This function applies a canvas texture map to the drawable.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{direction} (PDB_INT32)--Light direction (0 - 3)
@item @emph{depth} (PDB_INT32)--Texture depth (1 - 50)
@end itemize
@end defun
@emph{Karl-Johan Andersson}

@defun plug_in_threshold_alpha run_mode, image, drawable
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (not used)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Shuji Narazaki (narazaki@@InetQ.or.jp)}

@defun plug_in_tile run_mode, image, drawable, new_width, new_height, new_image
This function creates a new image with a single layer sized to the specified 'new_width' and 'new_height' parameters.  The specified drawable is tiled into this layer.  The new layer will have the same type as the specified drawable and the new image will have a corresponding base type--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{new_width} (PDB_INT32)--New (tiled) image width
@item @emph{new_height} (PDB_INT32)--New (tiled) image height
@item @emph{new_image} (PDB_INT32)--Create a new image?
@end itemize


@strong{Outputs}
@itemize @bullet
@item @emph{new_image} (PDB_IMAGE)--Output image (N/A if new_image == TRUE)
@item @emph{new_layer} (PDB_IMAGE)--Output layer (N/A if new_image == TRUE)
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@defun plug_in_tileit run_mode, image, drawable, number_of_tiles
More here later--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{number_of_tiles} (PDB_INT32)--Number of tiles to make
@end itemize
@end defun
@emph{Andy Thomas}

@defun plug_in_tiler run_mode, image, drawable
This plugin creates a seamless tileable from the input image--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Tim Rowley}

@defun plug_in_universal_filter run_mode, image, drawable, matrix(0,0), matrix(0,1), matrix(0,2), matrix(1,0), matrix(1,1), matrix(1,2), matrix(2,0), matrix(2,1), matrix(2,2), auto, norm, bias
Filter the image by usage of convolution--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{matrix(0,0)} (PDB_INT32)--Filter Matrix (0,0)
@item @emph{matrix(0,1)} (PDB_INT32)--Filter Matrix (0,1)
@item @emph{matrix(0,2)} (PDB_INT32)--Filter Matrix (0,2)
@item @emph{matrix(1,0)} (PDB_INT32)--Filter Matrix (1,0)
@item @emph{matrix(1,1)} (PDB_INT32)--Filter Matrix (1,1)
@item @emph{matrix(1,2)} (PDB_INT32)--Filter Matrix (1,2)
@item @emph{matrix(2,0)} (PDB_INT32)--Filter Matrix (2,0)
@item @emph{matrix(2,1)} (PDB_INT32)--Filter Matrix (2,1)
@item @emph{matrix(2,2)} (PDB_INT32)--Filter Matrix (2,2)
@item @emph{auto} (PDB_INT32)--Automatic Normalisation (n/y)
@item @emph{norm} (PDB_INT32)--Normalisation value
@item @emph{bias} (PDB_INT32)--Bias value
@end itemize
@end defun
@emph{O. Steinfatt}

@defun plug_in_video run_mode, image, drawable, pattern_number, additive, rotated
This function simulates the degradation of being on an old low-dotpitch RGB video monitor to the specified drawable.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{pattern_number} (PDB_INT32)--Type of RGB pattern to use
@item @emph{additive} (PDB_INT32)--Whether the function adds the result to the original image
@item @emph{rotated} (PDB_INT32)--Whether to rotate the RGB pattern by ninety degrees
@end itemize
@end defun
@emph{Adam D. Moss (adam@@foxbox.org)}

@defun plug_in_vinvert run_mode, image, drawable
This function takes an indexed/RGB image and inverts its 'value' in HSV space.  The upshot of this is that the colour and saturation at any given point remains the same, but its brightness is effectively inverted.  Quite strange.  Tends to produce unpleasant colour artifacts on images from lossy sources (ie. JPEG).--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (used for indexed images)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Adam D. Moss (adam@@foxbox.org)}

@defun plug_in_vpropagate run_mode, image, drawable, propagate-mode, propagating-channel, propagating-rate, direction-mask, lower-limit, upper-limit
Propagate values of the layer--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (not used)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{propagate-mode} (PDB_INT32)--Propagate 0:white, 1:black, 2:middle value 3:foreground to peak, 4:foreground, 5:background, 6:opaque, 7:transparent
@item @emph{propagating-channel} (PDB_INT32)--Channels which values are propagated
@item @emph{propagating-rate} (PDB_FLOAT)--0.0 <= propagatating_rate <= 1.0
@item @emph{direction-mask} (PDB_INT32)--0 <= direction-mask <= 15
@item @emph{lower-limit} (PDB_INT32)--0 <= lower-limit <= 255
@item @emph{upper-limit} (PDB_INT32)--0 <= upper-limit <= 255
@end itemize
@end defun
@emph{Shuji Narazaki (narazaki@@InetQ.or.jp)}

@defun plug_in_warp run_mode, image, drawable, amount, angle, iter, dither, warp_map, wrap_type, mag_map, mag_option
Smears an image along vector paths calculated as the gradient of a separate control matrix. The effect can look like brushstrokes of acrylic or watercolor paint, in some cases.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image (unused)
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{amount} (PDB_FLOAT)--Pixel displacement multiplier
@item @emph{angle} (PDB_FLOAT)--Angle of gradient vector rotation
@item @emph{iter} (PDB_FLOAT)--Iteration count
@item @emph{dither} (PDB_FLOAT)--Random dither amount
@item @emph{warp_map} (PDB_DRAWABLE)--Displacement control map
@item @emph{wrap_type} (PDB_INT32)--Edge behavior: @{ WRAP (0), SMEAR (1), BLACK (2), COLOR (3) @}
@item @emph{mag_map} (PDB_DRAWABLE)--Magnitude control map
@item @emph{mag_option} (PDB_INT32)--Use magnitude map: @{ FALSE (0), TRUE (1) @}
@end itemize
@end defun
@emph{John P. Beale}

@defun plug_in_waves run_mode, image, drawable, amplitude, phase, wavelength, type, reflective
none yet--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--The Image
@item @emph{drawable} (PDB_DRAWABLE)--The Drawable
@item @emph{amplitude} (PDB_FLOAT)--The Amplitude of the Waves
@item @emph{phase} (PDB_FLOAT)--The Phase of the Waves
@item @emph{wavelength} (PDB_FLOAT)--The Wavelength of the Waves
@item @emph{type} (PDB_INT32)--Type of waves, black/smeared
@item @emph{reflective} (PDB_INT32)--Use Reflection
@end itemize
@end defun
@emph{Eric L. Hernes, Stephen Norris}

@defun plug_in_whirl_pinch run_mode, image, drawable, whirl, pinch, radius
Distorts the image by whirling and pinching, which are two common center-based, circular distortions.  Whirling is like projecting the image onto the surface of water in a toilet and flushing.  Pinching is similar to projecting the image onto an elastic surface and pressing or pulling on the center of the surface.--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@item @emph{whirl} (PDB_FLOAT)--Whirl angle (degrees)
@item @emph{pinch} (PDB_FLOAT)--Pinch amount
@item @emph{radius} (PDB_FLOAT)--Radius (1.0 is the largest circle that fits in the image, and 2.0 goes all the way to the corners)
@end itemize
@end defun
@emph{Federico Mena Quintero and Scott Goehring}

@defun plug_in_zealouscrop run_mode, image, drawable
--@strong{GIMP Plug-In}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input image
@item @emph{drawable} (PDB_DRAWABLE)--Input drawable
@end itemize
@end defun
@emph{Adam D. Moss}

@defun script-fu-3dtruchet run_mode, value, value, color, color, color, value, value, value
3D Truchet pattern--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Block Size
@item @emph{value} (PDB_STRING)--Thickness
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{color} (PDB_COLOR)--Begin Blend
@item @emph{color} (PDB_COLOR)--End Blend
@item @emph{value} (PDB_STRING)--Supersample
@item @emph{value} (PDB_STRING)--Number of Xtiles
@item @emph{value} (PDB_STRING)--Number of Ytiles
@end itemize
@end defun
@emph{Adrian Likins <aklikins@@eos.ncsu.edu>}

@defun script-fu-add-bevel run_mode, image, drawable, value, toggle, toggle
Add a bevel to an image.--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Thickness
@item @emph{toggle} (PDB_INT32)--Work on copy
@item @emph{toggle} (PDB_INT32)--Keep bump layer
@end itemize
@end defun
@emph{Andrew Donkin (ard@@cs.waikato.ac.nz)}

@defun script-fu-addborder run_mode, image, drawable, value, value, color, value
Add a border around an image--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input Image
@item @emph{drawable} (PDB_DRAWABLE)--Input Drawable
@item @emph{value} (PDB_STRING)--Border x size
@item @emph{value} (PDB_STRING)--Border y size
@item @emph{color} (PDB_COLOR)--Border Colour
@item @emph{value} (PDB_STRING)--Delta value on colour
@end itemize
@end defun
@emph{Andy Thomas <alt@@picnic.demon.co.uk>}

@defun script-fu-alien-glow-bullet run_mode, value, color, color, toggle
Create a Bullet with an Alien Glow them for web pages--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Radius
@item @emph{color} (PDB_COLOR)--Glow Color
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{toggle} (PDB_INT32)--Flatten Image?
@end itemize
@end defun
@emph{Adrian Likins}

@defun script-fu-alien-glow-button run_mode, value, value, value, value, value, value, value, value, color, color, color, value, value, toggle
Button with an eerie glow--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text
@item @emph{value} (PDB_STRING)--Size
@item @emph{value} (PDB_STRING)--Foundry
@item @emph{value} (PDB_STRING)--Family
@item @emph{value} (PDB_STRING)--Weight
@item @emph{value} (PDB_STRING)--Slant
@item @emph{value} (PDB_STRING)--Set width
@item @emph{value} (PDB_STRING)--Spacing
@item @emph{color} (PDB_COLOR)--Text color
@item @emph{color} (PDB_COLOR)--Glow Color
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{value} (PDB_STRING)--Padding
@item @emph{value} (PDB_STRING)--Glow Radius
@item @emph{toggle} (PDB_INT32)--Flatten Image?
@end itemize
@end defun
@emph{Adrian Likins}

@defun script-fu-alien-glow-horizontal-ruler run_mode, value, value, color, color, toggle
Create an Hrule with the Alien Glow look--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Bar length
@item @emph{value} (PDB_STRING)--Bar Height
@item @emph{color} (PDB_COLOR)--Glow Color
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{toggle} (PDB_INT32)--Flatten Image
@end itemize
@end defun
@emph{Adrian Likins}

@defun script-fu-alien-glow-logo run_mode, value, value, value, color
Create an X-Files-esque logo with the specified glow color--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Glow Color
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-alien-glow-right-arrow run_mode, value, value, color, color, toggle
Create aan X-file deal--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Size
@item @emph{value} (PDB_STRING)--Orientation
@item @emph{color} (PDB_COLOR)--Glow Color
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{toggle} (PDB_INT32)--Flatten Image
@end itemize
@end defun
@emph{Adrian Likins}

@defun script-fu-basic1-logo run_mode, value, value, value, color, color
Creates a simple logo with a drop shadow--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{color} (PDB_COLOR)--Text Color
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-basic2-logo run_mode, value, value, value, color, color
Creates a simple logo with a shadow and a highlight--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{color} (PDB_COLOR)--Text Color
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-beveled-pattern-arrow run_mode, value, value, value
Beveled pattern arrow--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Size
@item @emph{value} (PDB_STRING)--Orientation
@item @emph{value} (PDB_STRING)--Pattern
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun script-fu-beveled-pattern-bullet run_mode, value, value, toggle
Beveled pattern bullet--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Diameter
@item @emph{value} (PDB_STRING)--Pattern
@item @emph{toggle} (PDB_INT32)--Transparent background
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun script-fu-beveled-pattern-button run_mode, value, value, value, value, value, value, value, value, color, value, toggle
Beveled pattern button--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text
@item @emph{value} (PDB_STRING)--Text size
@item @emph{value} (PDB_STRING)--Foundry
@item @emph{value} (PDB_STRING)--Family
@item @emph{value} (PDB_STRING)--Weight
@item @emph{value} (PDB_STRING)--Slant
@item @emph{value} (PDB_STRING)--Set width
@item @emph{value} (PDB_STRING)--Spacing
@item @emph{color} (PDB_COLOR)--Text color
@item @emph{value} (PDB_STRING)--Pattern
@item @emph{toggle} (PDB_INT32)--Pressed?
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun script-fu-beveled-pattern-heading run_mode, value, value, value, value, value, value, value, value, value, toggle
Beveled pattern heading--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text
@item @emph{value} (PDB_STRING)--Text size
@item @emph{value} (PDB_STRING)--Foundry
@item @emph{value} (PDB_STRING)--Family
@item @emph{value} (PDB_STRING)--Weight
@item @emph{value} (PDB_STRING)--Slant
@item @emph{value} (PDB_STRING)--Set width
@item @emph{value} (PDB_STRING)--Spacing
@item @emph{value} (PDB_STRING)--Pattern
@item @emph{toggle} (PDB_INT32)--Transparent background
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun script-fu-beveled-pattern-hrule run_mode, value, value, value
Beveled pattern hrule--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Width
@item @emph{value} (PDB_STRING)--Height
@item @emph{value} (PDB_STRING)--Pattern
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun script-fu-big-header-gimp-org run_mode, value, value, value, color, color, color, color, toggle, toggle, toggle, value
Big Gimp.org Header--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font
@item @emph{value} (PDB_STRING)--Font size
@item @emph{color} (PDB_COLOR)--Text Color
@item @emph{color} (PDB_COLOR)--Higlight Color
@item @emph{color} (PDB_COLOR)--Dark Color
@item @emph{color} (PDB_COLOR)--Shadow Color
@item @emph{toggle} (PDB_INT32)--AutoCrop?
@item @emph{toggle} (PDB_INT32)--Remove Background
@item @emph{toggle} (PDB_INT32)--Index image?
@item @emph{value} (PDB_STRING)--# of colors
@end itemize
@end defun
@emph{Adrian Likins & Jens Lautenbacher}

@defun script-fu-blend-anim run_mode, image, drawable, value, value, toggle
Blend two or more layers over a background, so that an 
                     animation can be saved--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Intermediate Frames
@item @emph{value} (PDB_STRING)--Max. Blur Radius
@item @emph{toggle} (PDB_INT32)--Looped
@end itemize
@end defun
@emph{Sven Neumann (neumanns@@uni-duesseldorf.de)}

@defun script-fu-blended-logo run_mode, value, value, value, value, color, color, color, color
Creates logos with blended backgrounds, highlights, and shadows--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Blend Mode
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{color} (PDB_COLOR)--Text Color
@item @emph{color} (PDB_COLOR)--Starting Blend
@item @emph{color} (PDB_COLOR)--Ending Blend
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-button00 run_mode, value, value, value, value, value, value, value, value, color, color, color, value, value, value
Simple beveled button--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text
@item @emph{value} (PDB_STRING)--Size
@item @emph{value} (PDB_STRING)--Foundry
@item @emph{value} (PDB_STRING)--Family
@item @emph{value} (PDB_STRING)--Weight
@item @emph{value} (PDB_STRING)--Slant
@item @emph{value} (PDB_STRING)--Set width
@item @emph{value} (PDB_STRING)--Spacing
@item @emph{color} (PDB_COLOR)--Upper-left color
@item @emph{color} (PDB_COLOR)--Lower-right color
@item @emph{color} (PDB_COLOR)--Text color
@item @emph{value} (PDB_STRING)--Padding
@item @emph{value} (PDB_STRING)--Bevel width
@item @emph{value} (PDB_STRING)--Pressed?
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun script-fu-carve-it run_mode, image, drawable, drawable, toggle
Use the specified [GRAY] drawable as a stencil to carve from the specified image--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Mask Image
@item @emph{drawable} (PDB_DRAWABLE)--Mask Drawable
@item @emph{drawable} (PDB_DRAWABLE)--Image to Carve
@item @emph{toggle} (PDB_INT32)--Carve White Areas
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-carved-logo run_mode, value, value, value, value, toggle
Carve the text from the specified image.  The image will be automatically tiled to accomodate the rendered text string.  The "Carve Raised Text" parameter determines whether to carve the text itself, or around the text.--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{value} (PDB_STRING)--Background Img
@item @emph{toggle} (PDB_INT32)--Carve Raised Text
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-chalk-logo run_mode, value, value, value, color, color
Chalk scribbled logos--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{color} (PDB_COLOR)--Chalk Color
@end itemize
@end defun
@emph{Manish Singh <msingh@@uclink4.berkeley.edu>}

@defun script-fu-chrome-logo run_mode, value, value, value, color
Somewhat simplistic, but cool chromed logos--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Background Color
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-circle-logo run_mode, value, value, value, value, value, value, value, toggle
Render the specified text along the perimeter of a circle--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text
@item @emph{value} (PDB_STRING)--Radius
@item @emph{value} (PDB_STRING)--Start-angle
@item @emph{value} (PDB_STRING)--Fill-angle
@item @emph{value} (PDB_STRING)--Family
@item @emph{value} (PDB_STRING)--Font Size (pixel)
@item @emph{value} (PDB_STRING)--Slant
@item @emph{toggle} (PDB_INT32)--Antialias
@end itemize
@end defun
@emph{Shuji Narazaki (narazaki@@InetQ.or.jp)}

@defun script-fu-circuit run_mode, image, drawable, value, value, toggle, toggle, toggle
Fills the current selection with something that looks 
                     vaguely like a circuit board.--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Oilify mask size
@item @emph{value} (PDB_STRING)--Circuit seed
@item @emph{toggle} (PDB_INT32)--No background? (only for seperate layer)
@item @emph{toggle} (PDB_INT32)--Keep Selection?
@item @emph{toggle} (PDB_INT32)--Seperate Layer?
@end itemize
@end defun
@emph{Adrian Likins <adrian@@gimp.org>}

@defun script-fu-clothify run_mode, image, drawable, value, value, value, value, value
Render the specified text along the perimeter of a circle--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Input Image
@item @emph{drawable} (PDB_DRAWABLE)--Input Drawable
@item @emph{value} (PDB_STRING)--X Blur
@item @emph{value} (PDB_STRING)--Y Blur
@item @emph{value} (PDB_STRING)--Azimuth
@item @emph{value} (PDB_STRING)--Elevation
@item @emph{value} (PDB_STRING)--Depth
@end itemize
@end defun
@emph{Tim Newsome <drz@@froody.bloke.com>}

@defun script-fu-colorcycling-anim run_mode, image, drawable, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value
Creates an animation with the help of the alienmap plug-in--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Number of frames
@item @emph{value} (PDB_STRING)--Start: red intensity factor (max. 128)
@item @emph{value} (PDB_STRING)--Start: green intensity factor (max. 128)
@item @emph{value} (PDB_STRING)--Start: blue intensity factor (max. 128)
@item @emph{value} (PDB_STRING)--End: red intensity factor (max. 128)
@item @emph{value} (PDB_STRING)--End: green intensity factor (max. 128)
@item @emph{value} (PDB_STRING)--End: blue intensity factor (max. 128)
@item @emph{value} (PDB_STRING)--Red color mode (sin:0/cos:1/none:2)
@item @emph{value} (PDB_STRING)--Green color mode (sin:0/cos:1/none:2)
@item @emph{value} (PDB_STRING)--Blue color mode (sin:0/cos:1/none:2)
@item @emph{value} (PDB_STRING)--Red inversion before transformation
@item @emph{value} (PDB_STRING)--Green inversion before transformation
@item @emph{value} (PDB_STRING)--Blue inversion before transformation
@item @emph{value} (PDB_STRING)--Start: red phase displacement (RAD)
@item @emph{value} (PDB_STRING)--Start: green phase displacement (RAD)
@item @emph{value} (PDB_STRING)--Start: blue phase displacement (RAD)
@item @emph{value} (PDB_STRING)--End: red phase displacement (RAD)
@item @emph{value} (PDB_STRING)--End: green phase displacement (RAD)
@item @emph{value} (PDB_STRING)--End: blue phase displacement (RAD)
@item @emph{value} (PDB_STRING)--Start: red frequency (> 0)
@item @emph{value} (PDB_STRING)--Start: green frequency (> 0)
@item @emph{value} (PDB_STRING)--Start: blue frequency (> 0)
@item @emph{value} (PDB_STRING)--End: red frequency (> 0)
@item @emph{value} (PDB_STRING)--End: green frequency (> 0)
@item @emph{value} (PDB_STRING)--End: blue frequency (> 0)
@item @emph{value} (PDB_STRING)--Red inversion after transformation
@item @emph{value} (PDB_STRING)--Green inversion after transformation
@item @emph{value} (PDB_STRING)--Blue inversion after transformation
@end itemize
@end defun
@emph{Daniel Cotting (cotting@@mygale.org)}

@defun script-fu-cool-metal-logo run_mode, value, value, value, color, toggle
Metallic logos with reflections and perspective shadows--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{toggle} (PDB_INT32)--Seascape
@end itemize
@end defun
@emph{Spencer Kimball & Rob Malda}

@defun script-fu-copy-visible run_mode, image, drawable
Copy the visible selction--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@end itemize
@end defun
@emph{Sven Neumann (neumanns@@uni-duesseldorf.de), Adrian Likins <adrian@@gimp.org>}

@defun script-fu-crystal-logo run_mode, value, value, value, value, value, value
Crystal/Gel effect which displaces the image underneath--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Chrome Factor
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{value} (PDB_STRING)--Background Img
@item @emph{value} (PDB_STRING)--Environment Map
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-drop-shadow run_mode, image, drawable, value, value, value, color, value, toggle
Add a drop-shadow of the current selection or 
                     alpha-channel--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--X offset
@item @emph{value} (PDB_STRING)--Y offset
@item @emph{value} (PDB_STRING)--Blur Radius
@item @emph{color} (PDB_COLOR)--Color
@item @emph{value} (PDB_STRING)--Opacity
@item @emph{toggle} (PDB_INT32)--Allow Resizing
@end itemize
@end defun
@emph{Sven Neumann (neumanns@@uni-duesseldorf.de)}

@defun script-fu-erase-rows run_mode, image, drawable, value, value
Erase every other row/column with the background color--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Rows/cols
@item @emph{value} (PDB_STRING)--Even/odd
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun script-fu-flatland run_mode, value, value, value, value, value, value
A Land Pattern--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Image Width
@item @emph{value} (PDB_STRING)--Image Height
@item @emph{value} (PDB_STRING)--Random Seed
@item @emph{value} (PDB_STRING)--Detail Level
@item @emph{value} (PDB_STRING)--X Scale
@item @emph{value} (PDB_STRING)--Y Scale
@end itemize
@end defun
@emph{Adrian Likins <aklikins@@eos.ncsu.edu>}

@defun script-fu-font-map run_mode, value, value, value
Generate a listing of the specified fonts--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Fonts
@item @emph{value} (PDB_STRING)--Font Size
@item @emph{value} (PDB_STRING)--Border
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-frosty-logo run_mode, value, value, value, color
Frozen logos with drop shadows--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Background Color
@end itemize
@end defun
@emph{Spencer Kimball & Ed Mackey}

@defun script-fu-glowing-logo run_mode, value, value, value, color
Glowing hot logos--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Background Color
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-gradient-example run_mode, value, value
Create an example image of a custom gradient--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Width
@item @emph{value} (PDB_STRING)--Height
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun script-fu-grid-system run_mode, image, drawable, value, value
Draw grid as specified by X-DIVIDES (list of propotions relative to the drawable) and Y-DIVIDES. The color and width of grid is detemined by the current settings of brush.--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image to use
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to draw grid
@item @emph{value} (PDB_STRING)--Grids: X
@item @emph{value} (PDB_STRING)--Grids: Y
@end itemize
@end defun
@emph{Shuji Narazaki <narazaki@@InetQ.or.jp>}

@defun script-fu-hsv-graph run_mode, image, drawable, value, value, toggle, toggle, value, value, value, value
Draph the graph of H/S/V values on the drawable--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image to analyze
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to analyze
@item @emph{value} (PDB_STRING)--Graph Scale
@item @emph{value} (PDB_STRING)--BG Opacity
@item @emph{toggle} (PDB_INT32)--Use Selection Bounds instead of belows
@item @emph{toggle} (PDB_INT32)--From Top-Left to Bottom-Right
@item @emph{value} (PDB_STRING)--Start X
@item @emph{value} (PDB_STRING)--Start Y
@item @emph{value} (PDB_STRING)--End X
@item @emph{value} (PDB_STRING)--End Y
@end itemize
@end defun
@emph{Shuji Narazaki (narazaki@@InetQ.or.jp)}

@defun script-fu-labels-gimp-org run_mode, value, value, value, value, value, value, color, color, color, toggle, toggle, value, value, value, value, value
Tube Button Label Header for gimp.org--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font
@item @emph{value} (PDB_STRING)--Font Size
@item @emph{value} (PDB_STRING)--Weight
@item @emph{value} (PDB_STRING)--Slant
@item @emph{value} (PDB_STRING)--Width
@item @emph{color} (PDB_COLOR)--Text Color
@item @emph{color} (PDB_COLOR)--Shadow Color
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{toggle} (PDB_INT32)--Remove Background
@item @emph{toggle} (PDB_INT32)--Index Image
@item @emph{value} (PDB_STRING)--# of colors
@item @emph{value} (PDB_STRING)--Select-by-color threshold
@item @emph{value} (PDB_STRING)--Y-Offset
@item @emph{value} (PDB_STRING)--X-Offset
@item @emph{value} (PDB_STRING)--Height
@end itemize
@end defun
@emph{Adrian Likins & Jens Lautenbacher}

@defun script-fu-land run_mode, value, value, value, value, value, value, value, value
A Topgraphic Map  pattern--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Image Width
@item @emph{value} (PDB_STRING)--Image Height
@item @emph{value} (PDB_STRING)--Random Seed
@item @emph{value} (PDB_STRING)--Detail Level
@item @emph{value} (PDB_STRING)--Land height
@item @emph{value} (PDB_STRING)--Sea depth
@item @emph{value} (PDB_STRING)--X Scale
@item @emph{value} (PDB_STRING)--Y Scale
@end itemize
@end defun
@emph{Adrian Likins <aklikins@@eos.ncsu.edu>}

@defun script-fu-lava run_mode, image, drawable, value, value, value, value, toggle, toggle, toggle
Fills the current selection with lava.--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Seed
@item @emph{value} (PDB_STRING)--Size
@item @emph{value} (PDB_STRING)--Roughness
@item @emph{value} (PDB_STRING)--Gradient
@item @emph{toggle} (PDB_INT32)--Keep Selection?
@item @emph{toggle} (PDB_INT32)--Seperate Layer?
@item @emph{toggle} (PDB_INT32)--Use current Gradient?
@end itemize
@end defun
@emph{Adrian Likins <adrian@@gimp.org>}

@defun script-fu-line-nova run_mode, image, drawable, value, value, value, value
Line Nova. You can't undo the output.--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image to use
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to draw line
@item @emph{value} (PDB_STRING)--Number of lines
@item @emph{value} (PDB_STRING)--Sharpness (deg.)
@item @emph{value} (PDB_STRING)--Offset
@item @emph{value} (PDB_STRING)--- randomness
@end itemize
@end defun
@emph{Shuji Narazaki <narazaki@@InetQ.or.jp>}

@defun script-fu-make-brush-elliptical run_mode, value, value, value, value
Create size of brush--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Description
@item @emph{value} (PDB_STRING)--Width
@item @emph{value} (PDB_STRING)--Height
@item @emph{value} (PDB_STRING)--Spacing
@end itemize
@end defun
@emph{Seth Burgess <sjburges@@ou.edu>}

@defun script-fu-make-brush-elliptical-feathered run_mode, value, value, value, value, value
Create size of brush--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Description
@item @emph{value} (PDB_STRING)--Width
@item @emph{value} (PDB_STRING)--Height
@item @emph{value} (PDB_STRING)--Feathering
@item @emph{value} (PDB_STRING)--Spacing
@end itemize
@end defun
@emph{Seth Burgess <sjburges@@ou.edu>}

@defun script-fu-make-brush-rectangular run_mode, value, value, value, value
Create size of brush--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Description
@item @emph{value} (PDB_STRING)--Width
@item @emph{value} (PDB_STRING)--Height
@item @emph{value} (PDB_STRING)--Spacing
@end itemize
@end defun
@emph{Seth Burgess <sjburges@@ou.edu>}

@defun script-fu-make-brush-rectangular-feathered run_mode, value, value, value, value, value
Create size of brush--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Description
@item @emph{value} (PDB_STRING)--Width
@item @emph{value} (PDB_STRING)--Height
@item @emph{value} (PDB_STRING)--Feathering
@item @emph{value} (PDB_STRING)--Spacing
@end itemize
@end defun
@emph{Seth Burgess <sjburges@@ou.edu>}

@defun script-fu-neon-logo run_mode, value, value, value, color, color, toggle
Neon logos--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{color} (PDB_COLOR)--Glow Color
@item @emph{toggle} (PDB_INT32)--Create Shadow
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-perspective-shadow run_mode, image, drawable, value, value, value, value, color, value, toggle, toggle
Add a perspective shadow--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Angle
@item @emph{value} (PDB_STRING)--Relative horizon distance
@item @emph{value} (PDB_STRING)--Relative shadow length
@item @emph{value} (PDB_STRING)--Blur Radius
@item @emph{color} (PDB_COLOR)--Color
@item @emph{value} (PDB_STRING)--Opacity
@item @emph{toggle} (PDB_INT32)--Interpolate
@item @emph{toggle} (PDB_INT32)--Allow Resizing
@end itemize
@end defun
@emph{Sven Neumann (neumanns@@uni-duesseldorf.de)}

@defun script-fu-predator run_mode, image, drawable, value, toggle, value, toggle, toggle
Fills the current selection with test--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Edge-amount
@item @emph{toggle} (PDB_INT32)--Pixelize?
@item @emph{value} (PDB_STRING)--Pixel amount
@item @emph{toggle} (PDB_INT32)--Keep Selection?
@item @emph{toggle} (PDB_INT32)--Seperate Layer?
@end itemize
@end defun
@emph{Adrian Likins <adrian@@gimp.org>}

@defun script-fu-ripply-anim run_mode, image, drawable, value, value
Ripple any image by creating animation frames as layers--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image to Animage
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to Animate
@item @emph{value} (PDB_STRING)--Rippling Strength
@item @emph{value} (PDB_STRING)--Number of Frames
@end itemize
@end defun
@emph{Adam D. Moss (adam@@foxbox.org)}

@defun script-fu-round-corners run_mode, image, drawable, value, toggle, value, value, value, toggle, toggle
Round the corners of an image and optionally adds a drop-shadow and a background--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Radius of Edges
@item @emph{toggle} (PDB_INT32)--Add drop-shadow
@item @emph{value} (PDB_STRING)--Shadow x
@item @emph{value} (PDB_STRING)--Shadow y
@item @emph{value} (PDB_STRING)--Blur Radius
@item @emph{toggle} (PDB_INT32)--Add background
@item @emph{toggle} (PDB_INT32)--Work on copy
@end itemize
@end defun
@emph{Sven Neumann (neumanns@@uni-duesseldorf.de)}

@defun script-fu-selection-round run_mode, image, drawable, value
Rounds the active selection. The selection should be 
                     rectangular.--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Relative Radius
@end itemize
@end defun
@emph{Sven Neumann (neumanns@@uni-duesseldorf.de)}

@defun script-fu-selection-to-brush run_mode, image, drawable, value, value, value
Convert a selection to a brush--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Description
@item @emph{value} (PDB_STRING)--Filename
@item @emph{value} (PDB_STRING)--Spacing
@end itemize
@end defun
@emph{Adrian Likins <adrian@@gimp.org>}

@defun script-fu-selection-to-image run_mode, image, drawable
Convert a selection to image--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@end itemize
@end defun
@emph{Adrian Likins <adrian@@gimp.org>}

@defun script-fu-show-image-structure run_mode, image, drawable, value, value, value, toggle, toggle, toggle, color, value, toggle, color
Show the layer structure of the image DESTRACTIVELY(the original image was modified)--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable (unused)
@item @emph{value} (PDB_STRING)--Space between layers
@item @emph{value} (PDB_STRING)--Shear length (> 0)
@item @emph{value} (PDB_STRING)--Outer Border (>= 0)
@item @emph{toggle} (PDB_INT32)--Apply layer mask (otherwise discard)
@item @emph{toggle} (PDB_INT32)--Insert layer names
@item @emph{toggle} (PDB_INT32)--Padding for transparent regions
@item @emph{color} (PDB_COLOR)--Pad Color
@item @emph{value} (PDB_STRING)--Pad Opacity [0:100]
@item @emph{toggle} (PDB_INT32)--Make New Background
@item @emph{color} (PDB_COLOR)--Background Color
@end itemize
@end defun
@emph{Shuji Narazaki (narazaki@@InetQ.or.jp)}

@defun script-fu-slide run_mode, image, drawable, value, value, value, color, toggle
Gives the image the look of a slide--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Text
@item @emph{value} (PDB_STRING)--Number
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Font Color
@item @emph{toggle} (PDB_INT32)--Work on copy
@end itemize
@end defun
@emph{Sven Neumann (neumanns@@uni-duesseldorf.de)}

@defun script-fu-small-header-gimp-org run_mode, value, value, value, color, color, color, color, toggle, toggle, toggle, value, value
Small Gimp.org Header--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font
@item @emph{value} (PDB_STRING)--Font size
@item @emph{color} (PDB_COLOR)--Text Color
@item @emph{color} (PDB_COLOR)--Higlight Color
@item @emph{color} (PDB_COLOR)--Dark Color
@item @emph{color} (PDB_COLOR)--Shadow Color
@item @emph{toggle} (PDB_INT32)--AutoCrop?
@item @emph{toggle} (PDB_INT32)--Remove Background
@item @emph{toggle} (PDB_INT32)--Index image?
@item @emph{value} (PDB_STRING)--# of colors
@item @emph{value} (PDB_STRING)--Select-by-color threshold
@end itemize
@end defun
@emph{Adrian Likins & Jens Lautenbacher}

@defun script-fu-sota-chrome-it run_mode, image, drawable, value, value, value, value, color, color, toggle
Use the specified [GRAY] drawable as a stencil to run the chrome effect on.--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Chrome Image
@item @emph{drawable} (PDB_DRAWABLE)--Chrome Mask
@item @emph{value} (PDB_STRING)--Chrome Saturation
@item @emph{value} (PDB_STRING)--Chrome Lightness
@item @emph{value} (PDB_STRING)--Chrome Factor
@item @emph{value} (PDB_STRING)--Environment Map
@item @emph{color} (PDB_COLOR)--Highlight Balance
@item @emph{color} (PDB_COLOR)--Chrome Balance
@item @emph{toggle} (PDB_INT32)--Chrome White Areas
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-sota-chrome-logo run_mode, value, value, value, value, value, value, value, color, color
State of the art chromed logos.--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Chrome Saturation
@item @emph{value} (PDB_STRING)--Chrome Lightness
@item @emph{value} (PDB_STRING)--Chrome Factor
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{value} (PDB_STRING)--Environment Map
@item @emph{color} (PDB_COLOR)--Highlight Balance
@item @emph{color} (PDB_COLOR)--Chrome Balance
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-sphere run_mode, value, value, value, color, color
Simple spheres with drop shadows--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Radius (in pixels)
@item @emph{value} (PDB_STRING)--Lighting (degrees)
@item @emph{value} (PDB_STRING)--Shadow?
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{color} (PDB_COLOR)--Sphere Color
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-starburst-logo run_mode, value, value, value, color, color
Starburst as inspired by GIMP News--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Burst Color
@item @emph{color} (PDB_COLOR)--BG Color
@end itemize
@end defun
@emph{Spencer Kimball & Xach Beane}

@defun script-fu-starscape-logo run_mode, value, value, value, color
Starscape using the Nova plug-in--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Glow Color
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-swirl-tile run_mode, value, value, value, value, value, value, value, value, color
Create an interesting swirled tile--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Depth
@item @emph{value} (PDB_STRING)--Azimuth
@item @emph{value} (PDB_STRING)--Elevation
@item @emph{value} (PDB_STRING)--Blur Radius
@item @emph{value} (PDB_STRING)--Height
@item @emph{value} (PDB_STRING)--Width
@item @emph{value} (PDB_STRING)--Whirl Amount
@item @emph{value} (PDB_STRING)--Roughness
@item @emph{color} (PDB_COLOR)--Backgound Color
@end itemize
@end defun
@emph{Adrian Likins <aklikins@@eos.ncsu.edu>}

@defun script-fu-swirly-pattern run_mode, value, value, value
Create a swirly pattern--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Quarter size
@item @emph{value} (PDB_STRING)--Whirl angle
@item @emph{value} (PDB_STRING)--Number of times to whirl
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun script-fu-t-o-p-logo run_mode, value, value, value, value, value, value, color, color
Trace of Particles Effect--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{value} (PDB_STRING)--Hit Rate [0.0,1.0]
@item @emph{value} (PDB_STRING)--Edge Width
@item @emph{value} (PDB_STRING)--Edge Only [0/1]
@item @emph{color} (PDB_COLOR)--Base Color
@item @emph{color} (PDB_COLOR)--Background Color
@end itemize
@end defun
@emph{Shuji Narazaki (narazaki@@InetQ.or.jp)}

@defun script-fu-textured-logo run_mode, value, value, value, value, value, color, color, color
Creates textured logos with blended backgrounds, highlights, and shadows--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text Pattern
@item @emph{value} (PDB_STRING)--Mosaic Tile Type
@item @emph{value} (PDB_STRING)--Text String
@item @emph{value} (PDB_STRING)--Font Size (in pixels)
@item @emph{value} (PDB_STRING)--Font
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{color} (PDB_COLOR)--Starting Blend
@item @emph{color} (PDB_COLOR)--Ending Blend
@end itemize
@end defun
@emph{Spencer Kimball}

@defun script-fu-title-header run_mode, value, value, value, value, value, value, value, value
Web title header--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text
@item @emph{value} (PDB_STRING)--Text size
@item @emph{value} (PDB_STRING)--Foundry
@item @emph{value} (PDB_STRING)--Family
@item @emph{value} (PDB_STRING)--Weight
@item @emph{value} (PDB_STRING)--Slant
@item @emph{value} (PDB_STRING)--Set width
@item @emph{value} (PDB_STRING)--Spacing
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun script-fu-trochoid run_mode, value, value, value, value, value
Draw Trochoid Curve--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Base radius (pixel)
@item @emph{value} (PDB_STRING)--Wheel Radius (hypo < 0 < epi)
@item @emph{value} (PDB_STRING)--Pen rad./wheel rad. [0.0:1.0]
@item @emph{value} (PDB_STRING)--Hue rate 
@item @emph{value} (PDB_STRING)--Erase before draw? [0/1]
@end itemize
@end defun
@emph{Shuji Narazaki <narazaki@@InetQ.or.jp>}

@defun script-fu-truchet run_mode, value, value, color, color, value, value
Create a Truchet pattern--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Block Size
@item @emph{value} (PDB_STRING)--Thickness
@item @emph{color} (PDB_COLOR)--Background Color
@item @emph{color} (PDB_COLOR)--Foreground Color
@item @emph{value} (PDB_STRING)--Number of Xtiles
@item @emph{value} (PDB_STRING)--Number of Ytiles
@end itemize
@end defun
@emph{Adrian Likins <aklikins@@eos.ncsu.edu>}

@defun script-fu-tube-button-label-gimp-org run_mode, value, toggle, toggle
Tube Button Label Header for gimp.org--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{toggle} (PDB_INT32)--Remove Background
@item @emph{toggle} (PDB_INT32)--Index Image
@end itemize
@end defun
@emph{Adrian Likins & Jens Lautenbacher}

@defun script-fu-tube-subbutton-label-gimp-org run_mode, value, toggle, toggle
Tube Button Label Header for gimp.org--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{toggle} (PDB_INT32)--Remove Background
@item @emph{toggle} (PDB_INT32)--Index Image
@end itemize
@end defun
@emph{Adrian Likins & Jens Lautenbacher}

@defun script-fu-tube-subsubbutton-label-gimp-org run_mode, value, toggle, toggle
Tube Button Label Header for gimp.org--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{value} (PDB_STRING)--Text String
@item @emph{toggle} (PDB_INT32)--Remove Background
@item @emph{toggle} (PDB_INT32)--Index Image
@end itemize
@end defun
@emph{Adrian Likins & Jens Lautenbacher}

@defun script-fu-waves-anim run_mode, image, drawable, value, value, value, toggle
Animate an image like a stone's been thrown into it--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Amplitude
@item @emph{value} (PDB_STRING)--Wavelength
@item @emph{value} (PDB_STRING)--Number of Frames
@item @emph{toggle} (PDB_INT32)--Invert direction
@end itemize
@end defun
@emph{Sven Neumann (neumanns@@uni-duesseldorf.de)}

@defun script-fu-weave run_mode, image, drawable, value, value, value, value, value, value, value
Weave effect a la Alien Skin--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image to weave
@item @emph{drawable} (PDB_DRAWABLE)--Drawable to weave
@item @emph{value} (PDB_STRING)--Ribbon width
@item @emph{value} (PDB_STRING)--Ribbon spacing
@item @emph{value} (PDB_STRING)--Shadow darkness
@item @emph{value} (PDB_STRING)--Shadow depth
@item @emph{value} (PDB_STRING)--Thread length
@item @emph{value} (PDB_STRING)--Thread density
@item @emph{value} (PDB_STRING)--Thread intensity
@end itemize
@end defun
@emph{Federico Mena Quintero}

@defun script-fu-xach-effect run_mode, image, drawable, value, value, color, color, color, value, value, value, value, toggle
Add a subtle translucent 3-d effect to the current selection or alpha channel--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--Interactive, non-interactive
@item @emph{image} (PDB_IMAGE)--Image
@item @emph{drawable} (PDB_DRAWABLE)--Drawable
@item @emph{value} (PDB_STRING)--Highlight X offset
@item @emph{value} (PDB_STRING)--Highlight Y offset
@item @emph{color} (PDB_COLOR)--Highlight Color
@item @emph{color} (PDB_COLOR)--Opacity
@item @emph{color} (PDB_COLOR)--Drop Shadow Color
@item @emph{value} (PDB_STRING)--Drop shadow Opacity
@item @emph{value} (PDB_STRING)--Drop shadow Blur Radius
@item @emph{value} (PDB_STRING)--Drop shadow X offset
@item @emph{value} (PDB_STRING)--Drop shadow Y offset
@item @emph{toggle} (PDB_INT32)--Keep Selection?
@end itemize
@end defun
@emph{Adrian Likins <adrian@@gimp.org>}

@defun script_fu_refresh run_mode
Re-read all available scripts--@strong{Temporary Procedure}

@strong{Inputs}
@itemize @bullet
@item @emph{run_mode} (PDB_INT32)--[Interactive], non-interactive
@end itemize
@end defun
@emph{Spencer Kimball & Peter Mattis}

@bye
