# GIMP - The GNU Image Manipulation Program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

sub item_is_valid {
    $blurb = 'Returns TRUE if the item is valid.';

    $help = <<'HELP';
This procedure checks if the given item ID is valid and refers to an
existing item.
HELP

    &neo_pdb_misc('2007', '2.8');

    @inargs = (
	{ name => 'item', type => 'item', no_validate => 1,
	  desc => 'The item to check' }
    );

    @outargs = (
	{ name => 'valid', type => 'boolean',
	  desc => 'Whether the item ID is valid' }
    );

    %invoke = (
	code => <<'CODE'
{
  valid = (GIMP_IS_ITEM (item) &&
           ! gimp_item_is_removed (GIMP_ITEM (item)));
}
CODE
    );
}

sub item_get_image {
    $blurb = "Returns the item's image.";

    $help = "This procedure returns the item's image.";

    &std_pdb_misc;
    $since = '2.8';

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'image', type => 'image',
	  desc => "The item's image" }
    );

    %invoke = (
	code => <<'CODE'
{
  image = gimp_item_get_image (GIMP_ITEM (item));
}
CODE
    );
}

sub item_delete {
    $blurb = 'Delete a item.';

    $help = <<'HELP';
This procedure deletes the specified item. This must not be done if the
image containing this item was already deleted or if the item was
already removed from the image. The only case in which this procedure is
useful is if you want to get rid of a item which has not yet been
added to an image.
HELP

    &std_pdb_misc;
    $since = '2.8';

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item to delete' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (g_object_is_floating (item))
    {
      g_object_ref_sink (item);
      g_object_unref (item);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub item_is_drawable {
    $blurb = 'Returns whether the item is a drawable.';

    $help = <<HELP;
This procedure returns TRUE if the specified item is a drawable.
HELP

    &std_pdb_misc;
    $since = '2.8';

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'drawable', type => 'boolean',
	  desc => 'TRUE if the item is a drawable, FALSE otherwise' }
    );

    %invoke = (
	code => <<'CODE'
{
  drawable = GIMP_IS_DRAWABLE (item);
}
CODE
    );
}

sub item_is_layer {
    $blurb = 'Returns whether the item is a layer.';

    $help = <<HELP;
This procedure returns TRUE if the specified item is a layer.
HELP

    &std_pdb_misc;
    $since = '2.8';

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'layer', type => 'boolean',
	  desc => 'TRUE if the item is a layer, FALSE otherwise' }
    );

    %invoke = (
	code => <<'CODE'
{
  layer = GIMP_IS_LAYER (item);
}
CODE
    );
}

sub item_is_text_layer {
    $blurb = 'Returns whether the item is a text layer.';

    $help = <<'HELP';
This procedure returns TRUE if the specified item is a text layer.
HELP

    &mitch_pdb_misc('2010', '2.8');

    @inargs = (
        { name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
        { name => 'text_layer', type => 'boolean',
	  desc => 'TRUE if the item is a text layer, FALSE otherwise.' }
    );

    %invoke = (
        code => <<'CODE'
{
  text_layer = gimp_item_is_text_layer (item);
}
CODE
    );
}

sub item_is_channel {
    $blurb = 'Returns whether the item is a channel.';

    $help = <<HELP;
This procedure returns TRUE if the specified item is a channel.
HELP

    &std_pdb_misc;
    $since = '2.8';

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'channel', type => 'boolean',
	  desc => 'TRUE if the item is a channel, FALSE otherwise' }
    );

    %invoke = (
	code => <<'CODE'
{
  channel = GIMP_IS_CHANNEL (item);
}
CODE
    );
}

sub item_is_layer_mask {
    $blurb = 'Returns whether the item is a layer mask.';

    $help = <<HELP;
This procedure returns TRUE if the specified item is a layer mask.
HELP

    &std_pdb_misc;
    $since = '2.8';

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'layer_mask', type => 'boolean',
	  desc => 'TRUE if the item is a layer mask, FALSE otherwise' }
    );

    %invoke = (
	code => <<'CODE'
{
  layer_mask = GIMP_IS_LAYER_MASK (item);
}
CODE
    );
}

sub item_is_selection {
    $blurb = 'Returns whether the item is a selection.';

    $help = <<HELP;
This procedure returns TRUE if the specified item is a selection.
HELP

    &std_pdb_misc;
    $since = '2.8';

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'selection', type => 'boolean',
	  desc => 'TRUE if the item is a selection, FALSE otherwise' }
    );

    %invoke = (
	code => <<'CODE'
{
  selection = GIMP_IS_SELECTION (item);
}
CODE
    );
}

sub item_is_vectors {
    $blurb = 'Returns whether the item is a vectors.';

    $help = <<HELP;
This procedure returns TRUE if the specified item is a vectors.
HELP

    &std_pdb_misc;
    $since = '2.8';

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'vectors', type => 'boolean',
	  desc => 'TRUE if the item is a vectors, FALSE otherwise' }
    );

    %invoke = (
	code => <<'CODE'
{
  vectors = GIMP_IS_VECTORS (item);
}
CODE
    );
}

sub item_is_group {
    $blurb = 'Returns whether the item is a group item.';

    $help = <<HELP;
This procedure returns TRUE if the specified item is a group item which
can have children.
HELP

    &mitch_pdb_misc('2010', '2.8');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'group', type => 'boolean',
	  desc => 'TRUE if the item is a group, FALSE otherwise' }
    );

    %invoke = (
	code => <<'CODE'
{
  group = (gimp_viewable_get_children (GIMP_VIEWABLE (item)) != NULL);
}
CODE
    );
}

sub item_get_parent {
    $blurb = "Returns the item's parent item.";

    $help = <<HELP;
This procedure returns the item's parent item, if any.
HELP

    &mitch_pdb_misc('2010', '2.8');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'parent', type => 'item',
	  desc => "The item's parent item" }
    );

    %invoke = (
	code => <<'CODE'
{
  parent = gimp_item_get_parent (item);
}
CODE
    );
}

sub item_get_children {
    $blurb = "Returns the item's list of children.";

    $help = <<HELP;
This procedure returns the list of items which are children of the specified
item. The order is topmost to bottommost.
HELP

    &mitch_pdb_misc('2010', '2.8');
    $lib_private = 1;

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'child_ids', type => 'int32array',
	  desc => "The item's list of children",
	  array => { name => 'num_children',
		     desc => "The item's number of children" } }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpContainer *children = gimp_viewable_get_children (GIMP_VIEWABLE (item));

  if (children)
    {
      num_children = gimp_container_get_n_children (children);

      if (num_children)
        {
          GList *list;
          gint   i;

          child_ids = g_new (gint32, num_children);

          for (list = GIMP_LIST (children)->queue->head, i = 0;
               list;
               list = g_list_next (list), i++)
            {
              child_ids[i] = gimp_item_get_ID (GIMP_ITEM (list->data));
            }
        }
    }
  else
    success = FALSE;

}
CODE
    );
}

sub item_get_expanded {
    $blurb = 'Returns whether the item is expanded.';

    $help = <<HELP;
This procedure returns TRUE if the specified item is expanded.
HELP

    &ell_pdb_misc('2017', '2.10');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'expanded', type => 'boolean',
	  desc => 'TRUE if the item is expanded, FALSE otherwise' }
    );

    %invoke = (
	code => <<'CODE'
{
  expanded = gimp_viewable_get_expanded (GIMP_VIEWABLE (item));
}
CODE
    );
}

sub item_set_expanded {
    $blurb = 'Sets the expanded state of the item.';

    $help = <<HELP;
This procedure expands or collapses the item.
HELP

    &ell_pdb_misc('2017', '2.10');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' },
    { name => 'expanded', type => 'boolean',
	  desc => 'TRUE to expand the item, FALSE to collapse the item' }
    );

    %invoke = (
	code => <<'CODE'
{
  gimp_viewable_set_expanded (GIMP_VIEWABLE (item), expanded);
}
CODE
    );
}

sub item_get_name {
    $blurb = "Get the name of the specified item.";

    $help = "This procedure returns the specified item's name.";

    &std_pdb_misc;
    $since = '2.8';

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'name', type => 'string',
	  desc => "The item name" }
    );

    %invoke = (
	code => <<'CODE'
{
  name = g_strdup (gimp_object_get_name (item));
}
CODE
    );
}

sub item_set_name {
    $blurb = "Set the name of the specified item.";

    $help = "This procedure sets the specified item's name.";

    &std_pdb_misc;
    $since = '2.8';

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' },
	{ name => 'name', type => 'string',
	  desc => "The new item name" }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gimp_item_rename (GIMP_ITEM (item), name, error);
}
CODE
    );
}

sub item_get_visible {
    $blurb = "Get the visibility of the specified item.";

    $help = "This procedure returns the specified item's visibility.";

    &std_pdb_misc;
    $since = '2.8';

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'visible', type => 'boolean',
	  desc => "The item visibility" }
    );

    %invoke = (
	code => <<'CODE'
{
  visible = gimp_item_get_visible (GIMP_ITEM (item));
}
CODE
    );
}

sub item_set_visible {
    $blurb = "Set the visibility of the specified item.";

    $help = "This procedure sets the specified item's visibility.";

    &std_pdb_misc;
    $since = '2.8';

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' },
	{ name => 'visible', type => 'boolean',
	  desc => "The new item visibility" }
    );

    %invoke = (
	code => <<'CODE'
{
  gimp_item_set_visible (GIMP_ITEM (item), visible, TRUE);
}
CODE
    );
}

sub item_get_linked {
    $blurb = "Get the linked state of the specified item.";

    $help = "This procedure returns the specified item's linked state.";

    &wolfgang_pdb_misc('1998', '2.8');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'linked', type => 'boolean',
	  desc => "The item linked state (for moves)" }
    );

    %invoke = (
	code => <<'CODE'
{
  linked = gimp_item_get_linked (GIMP_ITEM (item));
}
CODE
    );
}

sub item_set_linked {
    $blurb = "Set the linked state of the specified item.";

    $help = "This procedure sets the specified item's linked state.";

    &wolfgang_pdb_misc('1998', '2.8');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' },
	{ name => 'linked', type => 'boolean',
	  desc => "The new item linked state" }
    );

    %invoke = (
	code => <<'CODE'
{
  gimp_item_set_linked (GIMP_ITEM (item), linked, TRUE);
}
CODE
    );
}

sub item_get_lock_content {
    $blurb = "Get the 'lock content' state of the specified item.";

    $help = "This procedure returns the specified item's lock content state.";

    &mitch_pdb_misc('2009', '2.8');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'lock_content', type => 'boolean',
	  desc => "Whether the item's contents are locked" }
    );

    %invoke = (
	code => <<'CODE'
{
  lock_content = gimp_item_get_lock_content (GIMP_ITEM (item));
}
CODE
    );
}

sub item_set_lock_content {
    $blurb = "Set the 'lock content' state of the specified item.";

    $help = "This procedure sets the specified item's lock content state.";

    &mitch_pdb_misc('2009', '2.8');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' },
	{ name => 'lock_content', type => 'boolean',
	  desc => "The new item 'lock content' state" }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_item_can_lock_content (GIMP_ITEM (item)))
    gimp_item_set_lock_content (GIMP_ITEM (item), lock_content, TRUE);
  else
    success = FALSE;
}
CODE
    );
}

sub item_get_lock_position {
    $blurb = "Get the 'lock position' state of the specified item.";

    $help = "This procedure returns the specified item's lock position state.";

    &mitch_pdb_misc('2012', '2.10');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'lock_position', type => 'boolean',
	  desc => "Whether the item's position is locked" }
    );

    %invoke = (
	code => <<'CODE'
{
  lock_position = gimp_item_get_lock_position (GIMP_ITEM (item));
}
CODE
    );
}

sub item_set_lock_position {
    $blurb = "Set the 'lock position' state of the specified item.";

    $help = "This procedure sets the specified item's lock position state.";

    &mitch_pdb_misc('2009', '2.10');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' },
	{ name => 'lock_position', type => 'boolean',
	  desc => "The new item 'lock position' state" }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_item_can_lock_position (GIMP_ITEM (item)))
    gimp_item_set_lock_position (GIMP_ITEM (item), lock_position, TRUE);
  else
    success = FALSE;
}
CODE
    );
}

sub item_get_color_tag {
    $blurb = "Get the color tag of the specified item.";

    $help = "This procedure returns the specified item's color tag.";

    &mitch_pdb_misc('2016', '2.10');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'color_tag', type => 'enum GimpColorTag',
	  desc => "The item's color tag" }
    );

    %invoke = (
	code => <<'CODE'
{
  color_tag = gimp_item_get_color_tag (GIMP_ITEM (item));
}
CODE
    );
}

sub item_set_color_tag {
    $blurb = "Set the color tag of the specified item.";

    $help = "This procedure sets the specified item's color tag.";

    &mitch_pdb_misc('2016', '2.10');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' },
	{ name => 'color_tag', type => 'enum GimpColorTag',
	  desc => "The new item color tag" }
    );

    %invoke = (
	code => <<'CODE'
{
  gimp_item_set_color_tag (GIMP_ITEM (item), color_tag, TRUE);
}
CODE
    );
}

sub item_get_tattoo {
    $blurb = "Get the tattoo of the specified item.";

    $help = <<'HELP';
This procedure returns the specified item's tattoo. A tattoo is a
unique and permanent identifier attached to a item that can be
used to uniquely identify a item within an image even between
sessions.
HELP

    &jay_pdb_misc('1998', '2.8');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'tattoo', type => 'tattoo',
	  desc => "The item tattoo" }
    );

    %invoke = (
	code => <<'CODE'
{
  tattoo = gimp_item_get_tattoo (GIMP_ITEM (item));
}
CODE
    );
}

sub item_set_tattoo {
    $blurb = "Set the tattoo of the specified item.";

    $help = <<'HELP';
This procedure sets the specified item's tattoo. A tattoo is a
unique and permanent identifier attached to a item that can be
used to uniquely identify a item within an image even between
sessions.
HELP

    &jay_pdb_misc('1998', '2.8');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' },
	{ name => 'tattoo', type => 'tattoo',
	  desc => "The new item tattoo" }
    );

    %invoke = (
	code => <<'CODE'
{
  gimp_item_set_tattoo (GIMP_ITEM (item), tattoo);
}
CODE
    );
}

sub item_attach_parasite {
    $blurb = 'Add a parasite to an item.';

    $help = <<'HELP';
This procedure attaches a parasite to an item. It has no return values.
HELP

    &jay_pdb_misc('1998', '2.8');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' },
	{ name => 'parasite', type => 'parasite',
	  desc => 'The parasite to attach to the item' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_item_parasite_validate (item, parasite, error))
    gimp_item_parasite_attach (item, parasite, TRUE);
  else
    success = FALSE;
}
CODE
    );
}

sub item_detach_parasite {
    $blurb = 'Removes a parasite from an item.';

    $help = <<'HELP';
This procedure detaches a parasite from an item. It has no return values.
HELP

    &jay_pdb_misc('1998', '2.8');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' },
	{ name => 'name', type => 'string',
	  desc => 'The name of the parasite to detach from the item.' }
    );

    %invoke = (
	code => <<'CODE'
{
  gimp_item_parasite_detach (item, name, TRUE);
}
CODE
    );
}

sub item_get_parasite {
    $blurb = 'Look up a parasite in an item';

    $help = <<'HELP';
Finds and returns the parasite that is attached to an item.
HELP

    &jay_pdb_misc('1998', '2.8');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' },
	{ name => 'name', type => 'string',
	  desc => 'The name of the parasite to find' }
    );

    @outargs = (
	{ name => 'parasite', type => 'parasite',
	  desc => 'The found parasite' }
    );

    %invoke = (
	code => <<'CODE'
{
  parasite = gimp_parasite_copy (gimp_item_parasite_find (item, name));

  if (! parasite)
    success = FALSE;
}
CODE
    );
}

sub item_get_parasite_list {
    $blurb = 'List all parasites.';
    $help  = 'Returns a list of all parasites currently attached the an item.';

    &marc_pdb_misc('1999', '2.8');

    @inargs = (
	{ name => 'item', type => 'item',
	  desc => 'The item' }
    );

    @outargs = (
	{ name => 'parasites', type => 'stringarray',
	  desc => 'The names of currently attached parasites',
	  array => { desc => 'The number of attached parasites' } }
    );

    %invoke = (
	code => <<'CODE'
{
  parasites = gimp_item_parasite_list (item, &num_parasites);
}
CODE
    );
}

@headers = qw("core/gimplayermask.h"
              "core/gimplist.h"
              "core/gimpselection.h"
              "text/gimptextlayer.h"
	      "vectors/gimpvectors.h"
              "gimppdb-utils.h"
              "gimppdbcontext.h"
              "gimp-intl.h");

@procs = qw(item_is_valid
            item_get_image
            item_delete
            item_is_drawable
            item_is_layer
            item_is_text_layer
	    item_is_channel
	    item_is_layer_mask
	    item_is_selection
	    item_is_vectors
	    item_is_group
            item_get_parent
	    item_get_children
            item_get_expanded item_set_expanded
            item_get_name item_set_name
            item_get_visible item_set_visible
            item_get_linked item_set_linked
            item_get_lock_content item_set_lock_content
            item_get_lock_position item_set_lock_position
            item_get_color_tag item_set_color_tag
            item_get_tattoo item_set_tattoo
	    item_attach_parasite item_detach_parasite
	    item_get_parasite
	    item_get_parasite_list);

%exports = (app => [@procs], lib => [@procs]);

$desc = 'Item procedures';
$doc_title = 'gimpitem';
$doc_short_desc = 'Functions to manipulate items.';
$doc_long_desc = 'Functions to manipulate items.';

1;
