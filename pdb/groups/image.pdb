# GIMP - The GNU Image Manipulation Program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

sub image_id_is_valid {
    $blurb = 'Returns TRUE if the image ID is valid.';

    $help = <<'HELP';
This procedure checks if the given image ID is valid and refers to an
existing image.
HELP

    &neo_pdb_misc('2007', '3.0');

    @inargs = (
        { name => 'image_id', type => 'int32',
          desc => 'The image ID to check' }
    );

    @outargs = (
        { name => 'valid', type => 'boolean',
          desc => 'Whether the image ID is valid' }
    );

    %invoke = (
        code => <<'CODE'
{
  valid = (gimp_image_get_by_id (gimp, image_id) != NULL);
}
CODE
    );
}

sub get_images {
    $blurb = 'Returns the list of images currently open.';

    $help = <<'HELP';
This procedure returns the list of images currently open in GIMP.
HELP

    &std_pdb_misc;

    @outargs = (
        { name => 'images', type => 'imagearray',
          desc => 'The list of images currently open.' }
    );

    %invoke = (
        code => <<CODE
{
  GList *list = gimp_get_image_iter (gimp);
  gsize  num_images;
  gint   i;

  num_images = g_list_length (list);
  images     = g_new0 (GimpImage *, num_images + 1);

  for (i = 0; i < num_images; i++, list = g_list_next (list))
    images[i] = list->data;
}
CODE
    );
}

sub image_new {
    $blurb = 'Creates a new image with the specified width, height, and type.';

    $help = <<'HELP';
Creates a new image, undisplayed, with the specified extents and
type. A layer should be created and added before this image is
displayed, or subsequent calls to [ctor@Gimp.Display.new] with this
image as an argument will fail. Layers can be created using the
[ctor@Gimp.Layer.new] command. They can be added to an image using the
[method@Gimp.Image.insert_layer] command.


If your image's type is INDEXED, a palette must also be set with
[method@Gimp.Image.set_palette]. An indexed image without a palette will
output unexpected colors.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'width', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
          desc => 'The width of the image' },
        { name => 'height', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
          desc => 'The height of the image' },
        { name => 'type', type => 'enum GimpImageBaseType',
          desc => 'The type of image' }
    );

    @outargs = (
        { name => 'image', type => 'image',
          desc => 'The newly created image' }
    );

    %invoke = (
        code => <<'CODE'
{
  image = gimp_create_image (gimp, width, height, type,
                             GIMP_PRECISION_U8_NON_LINEAR, FALSE);

  if (! image)
    success = FALSE;
}
CODE
    );
}

sub image_new_with_precision {
    $blurb = 'Creates a new image with the specified width, height, type and precision.';

    $help = <<'HELP';
Creates a new image, undisplayed with the specified extents, type and
precision. Indexed images can only be created at
[enum@Gimp.Precision.U8_NON_LINEAR] precision. See [ctor@Gimp.Image.new] for
further details.
HELP

    &mitch_pdb_misc('2012', '2.10');

    @inargs = (
        { name => 'width', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
          desc => 'The width of the image' },
        { name => 'height', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
          desc => 'The height of the image' },
        { name => 'type', type => 'enum GimpImageBaseType',
          desc => 'The type of image' },
        { name => 'precision', type => 'enum GimpPrecision',
          desc => 'The precision' }
    );

    @outargs = (
        { name => 'image', type => 'image',
          desc => 'The newly created image' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_babl_is_valid (type, precision))
    {
      image = gimp_create_image (gimp, width, height, type,
                                 precision, FALSE);
      if (! image)
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub image_duplicate {
    $blurb = 'Duplicate the specified image';

    $help = <<'HELP';
This procedure duplicates the specified image, copying all layers, channels,
and image information.
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'new_image', type => 'image',
          desc => 'The new, duplicated image' }
    );

    %invoke = (
        headers => [ qw("core/gimpimage-duplicate.h") ],
        code => <<'CODE'
{
  new_image = gimp_image_duplicate (image);

  if (! new_image)
    success = FALSE;
}
CODE
    );
}

sub image_delete {
    $blurb = 'Delete the specified image.';

    $help = <<'HELP';
If there are no displays associated with this image it will be deleted.
This means that you can not delete an image through the PDB that was
created by the user. If the associated display was however created
through the PDB and you know the display ID, you may delete the display.
Removal of the last associated display will then delete the image.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_image_get_display_count (image) == 0)
    g_object_unref (image);
  else
    success = FALSE;
}
CODE
    );
}

sub image_get_layers {
    $blurb = 'Returns the list of root layers contained in the specified image.';

    $help = <<HELP;
This procedure returns the list of root layers contained in the specified image.
The order of layers is from topmost to bottommost.

Note that this is not the full list of layers, but only the root layers,
i.e. layers with no parents themselves. If you need all layers, it is up
to you to verify that any of these layers is a group layer with
gimp_item_is_group() and to obtain its children with
gimp_item_get_children() (possibly recursively checking if these have
children too).
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'layers', type => 'layerarray',
          desc => 'The list of layers contained in the image.' }
    );

    %invoke = (
        code => <<'CODE'
{
  GList *list = gimp_image_get_layer_iter (image);
  gsize  num_layers;
  gint   i;

  num_layers = g_list_length (list);

  layers = g_new0 (GimpLayer *, num_layers + 1);

  for (i = 0; i < num_layers; i++, list = g_list_next (list))
    layers[i] = list->data;
}
CODE
    );
}

sub image_get_channels {
    $blurb = 'Returns the list of channels contained in the specified image.';

    $help = <<HELP;
This procedure returns the list of channels contained in the specified image.
This does not include the selection mask, or layer masks. The order is from
topmost to bottommost. Note that "channels" are custom channels and do not
include the image's color components.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'channels', type => 'channelarray',
          desc => 'The list of channels contained in the image.' }
    );

    %invoke = (
        code => <<'CODE'
{
  GList *list = gimp_image_get_channel_iter (image);
  gsize  num_channels;
  gint   i;

  num_channels = g_list_length (list);
  channels = g_new0 (GimpChannel *, num_channels + 1);

  for (i = 0; i < num_channels; i++, list = g_list_next (list))
    channels[i] = list->data;
}
CODE
    );
}

sub image_get_paths {
    $blurb = 'Returns the list of paths contained in the specified image.';

    $help = <<HELP;
This procedure returns the list of paths contained in the specified image.
HELP

    &simon_pdb_misc('2005', '2.4');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'paths', type => 'patharray',
          desc => 'The list of paths contained in the image.' }
    );

    %invoke = (
        code => <<'CODE'
{
  GList *list = gimp_image_get_path_iter (image);
  gsize  num_paths;
  gint   i;

  num_paths = g_list_length (list);
  paths     = g_new0 (GimpPath *, num_paths + 1);

  for (i = 0; i < num_paths; i++, list = g_list_next (list))
    paths[i] = g_object_ref (list->data);
}
CODE
    );
}

sub image_unset_active_channel {
    $blurb = 'Unsets the active channel in the specified image.';

    $help = <<'HELP';
If an active channel exists, it is unset. There then exists no active
channel, and if desired, one can be set through a call to 'Set Active
Channel'. No error is returned in the case of no existing active
channel.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    %invoke = (
        code => <<'CODE'
{
  gimp_image_unset_selected_channels (image);
}
CODE
    );
}

sub image_pick_color {
    $blurb = <<'BLURB';
Determine the color at the given coordinates
BLURB

    $help = <<'HELP';
This tool determines the color at the specified coordinates. The
returned color is an RGB triplet even for grayscale and indexed
drawables. If the coordinates lie outside of the extents of the
specified drawables, then an error is returned. All drawables must
belong to the image and be of the same type.

If only one drawable is given and it has an alpha channel, the algorithm
examines the alpha value of the drawable at the coordinates. If the
alpha value is completely transparent (0), then an error is returned.
With several drawables specified, the composite image with only these
drawables is used.

If the sample_merged parameter is TRUE, the data of the composite image
will be used instead of that for the specified drawables. This is
equivalent to sampling for colors after merging all visible layers. In
the case of a merged sampling, the supplied drawables are ignored.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'drawables', type => 'drawablearray',
          desc => 'The drawables to pick from' },
        { name => 'x', type => 'double',
          desc => 'x coordinate of upper-left corner of rectangle' },
        { name => 'y', type => 'double',
          desc => 'y coordinate of upper-left corner of rectangle' },
        { name => 'sample_merged', type => 'boolean',
          desc => 'Use the composite image, not the drawables' },
        { name => 'sample_average', type => 'boolean',
          desc => 'Average the color of all the pixels in a specified
                   radius' },
        { name => 'average_radius', type => '0 < double', no_validate => 1,
          desc => 'The radius of pixels to average' }
    );

    @outargs = (
        { name => 'color', type => 'geglcolor', has_alpha => 1, void_ret => 1,
          desc => 'The return color' }
    );

    %invoke = (
        headers => [ qw("core/gimpimage-pick-color.h" "core/gimppickable.h") ],
        code => <<'CODE'
{
  gint i;

  if (! sample_merged)
    {
      if (drawables == NULL || drawables[0] == NULL)
        {
          success = FALSE;
        }
      else
        {
          for (i = 0; drawables[i] != NULL; i++)
            if (gimp_item_get_image (GIMP_ITEM (drawables[i])) != image)
              {
                success = FALSE;
                break;
              }
        }
    }

  if (success && sample_average)
    {
      if (average_radius <= 0.0)
        success = FALSE;
    }

  if (success)
    {
      GList *drawable_list = NULL;

      for (i = 0; drawables[i] != NULL; i++)
        {
          GimpPickable *pickable = (GimpPickable *) drawables[i];

          drawable_list = g_list_prepend (drawable_list, pickable);
          if (! sample_merged)
            gimp_pickable_flush (pickable);
        }

      if (sample_merged)
        gimp_pickable_flush (GIMP_PICKABLE (image));

      color   = gegl_color_new ("black");
      success = gimp_image_pick_color (image,
                                       drawable_list,
                                       (gint) x, (gint) y,
                                       FALSE,
                                       sample_merged,
                                       sample_average,
                                       average_radius,
                                       NULL,
                                       NULL,
                                       &color);

      g_list_free (drawable_list);
    }
}
CODE
    );
}

sub image_pick_correlate_layer {
    $blurb = 'Find the layer visible at the specified coordinates.';

    $help = <<'HELP';
This procedure finds the layer which is visible at the specified
coordinates.  Layers which do not qualify are those whose extents do
not pass within the specified coordinates, or which are transparent at
the specified coordinates.  This procedure will return -1 if no layer
is found.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'x', type => 'int32',
          desc => 'The x coordinate for the pick' },
        { name => 'y', type => 'int32',
          desc => 'The y coordinate for the pick' }
    );

    @outargs = (
        { name => 'layer', type => 'layer',
          desc => 'The layer found at the specified coordinates' }
    );

    %invoke = (
        headers => [ qw("core/gimpimage-pick-item.h") ],
        code => <<'CODE'
{
  layer = gimp_image_pick_layer (image, x, y, NULL);
}
CODE
    );
}

sub image_get_item_position {
    $blurb = 'Returns the position of the item in its level of its item tree.';

    $help = <<'HELP';
This procedure determines the position of the specified item in its
level in its item tree in the image. If the item doesn't exist in the
image, or the item is not part of an item tree, an error is returned.
HELP

    &mitch_pdb_misc('2010', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'item', type => 'item',
          desc => 'The item' }
    );

    @outargs = (
        { name => 'position', type => 'int32',
          desc => "The position of the item in its level in the item tree" }
    );


    %invoke = (
        code => <<'CODE'
{
  if (gimp_pdb_item_is_in_tree (item, image, 0, error))
    position = gimp_item_get_index (item);
  else
    success = FALSE;
}
CODE
    );
}

sub image_raise_item {
    $blurb = "Raise the specified item in its level in its item tree";

    $help = <<'HELP';
This procedure raises the specified item one step in the item tree.
The procedure call will fail if there is no item above it.
HELP

    &mitch_pdb_misc('2010', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'item', type => 'item',
          desc => 'The item to raise' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_pdb_item_is_in_tree (item, image, 0, error))
    success = gimp_image_raise_item (image, item, error);
  else
    success = FALSE;
}
CODE
    );
}

sub image_lower_item {
    $blurb = "Lower the specified item in its level in its item tree";

    $help = <<'HELP';
This procedure lowers the specified item one step in the item tree.
The procedure call will fail if there is no item below it.
HELP

    &mitch_pdb_misc('2010', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'item', type => 'item',
          desc => 'The item to lower' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_pdb_item_is_in_tree (item, image, 0, error))
    success = gimp_image_lower_item (image, item, error);
  else
    success = FALSE;
}
CODE
    );
}

sub image_raise_item_to_top {
    $blurb = <<'BLURB';
Raise the specified item to the top of its level in its item tree
BLURB

    $help = <<'HELP';
This procedure raises the specified item to top of its level in the
item tree. It will not move the item if there is no item above it.
HELP

    &mitch_pdb_misc('2010', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'item', type => 'item',
          desc => 'The item to raise to top' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_pdb_item_is_in_tree (item, image, 0, error))
    success = gimp_image_raise_item_to_top (image, item);
  else
    success = FALSE;
}
CODE
    );
}

sub image_lower_item_to_bottom {
    $blurb = <<'BLURB';
Lower the specified item to the bottom of its level in its item tree
BLURB

    $help = <<'HELP';
This procedure lowers the specified item to bottom of its level in the
item tree. It will not move the layer if there is no layer below it.
HELP

    &mitch_pdb_misc('2010', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'item', type => 'item',
          desc => 'The item to lower to bottom' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_pdb_item_is_in_tree (item, image, 0, error))
    success = gimp_image_lower_item_to_bottom (image, item);
  else
    success = FALSE;
}
CODE
    );
}

sub image_reorder_item {
    $blurb = "Reorder the specified item within its item tree";

    $help = <<'HELP';
Reorders or moves item within an item tree.
Requires parent is %NULL or a GroupLayer, else returns error.
When parent is not %NULL and item is in parent,
reorders item within parent group.
When parent is not %NULL and item is not in parent,
moves item into parent group.
When parent is %NULL, moves item from current parent to top level.


Requires item is in same tree as not %NULL parent, else returns error.
Layers, Channels, and Paths are in separate trees.


Requires item is not ancestor of parent, else returns error, to preclude cycles.
HELP

    &mitch_pdb_misc('2010', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'item', type => 'item',
          desc => 'The item to reorder' },
        { name => 'parent', type => 'item', none_ok => 1,
          desc => 'The new parent item' },
        { name => 'position', type => 'int32',
          desc => 'The new position of the item' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_pdb_item_is_in_tree (item, image, 0, error) &&
      (parent == NULL ||
       (gimp_pdb_item_is_in_same_tree (item, parent, image, error) &&
        gimp_pdb_item_is_group (parent, error) &&
        gimp_pdb_item_is_not_ancestor (item, parent, error))))
    {
      success = gimp_image_reorder_item (image, item, parent, position,
                                         TRUE, NULL);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub image_merge_visible_layers {
    $blurb = 'Merge the visible image layers into one.';

    $help = <<'HELP';
This procedure combines the visible layers into a single layer using
the specified merge type. A merge type of [enum@Gimp.MergeType.EXPAND_AS_NECESSARY]
expands the final layer to encompass the areas of the visible layers. A merge
type of [enum@Gimp.MergeType.CLIP_TO_IMAGE] clips the final layer to the
extents of the image. A merge type of [enum@Gimp.MergeType.CLIP_TO_BOTTOM_LAYER]
clips the final layer to the size of the bottommost layer.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'merge_type',
          type => 'enum GimpMergeType (no GIMP_FLATTEN_IMAGE)',
          desc => 'The type of merge' }
    );

    @outargs = (
        { name => 'layer', type => 'layer',
          desc => 'The resulting layer' }
    );

    %invoke = (
        headers => [ qw("core/gimpimage-merge.h") ],
        code => <<'CODE'
{
  GList *layers;

  layers = gimp_image_merge_visible_layers (image, context, merge_type,
                                            FALSE, FALSE, progress);

  if (layers)
    /* With merge_selected_groups set to FALSE, we always get only a
     * single selected layer.
     */
    layer = layers->data;

  if (! layer)
    success = FALSE;
}
CODE
    );
}

sub image_merge_down {
    $blurb = 'Merge the layer passed and the first visible layer below.';

    $help = <<'HELP';
This procedure combines the passed layer and the first visible layer
below it using the specified merge type. A merge type of
[enum@Gimp.MergeType.EXPAND_AS_NECESSARY] expands the final layer to encompass
the areas of the visible layers. A merge type of
[enum@Gimp.MergeType.CLIP_TO_IMAGE] clips the final layer to the extents of
the image. A merge type of [enum@Gimp.MergeType.CLIP_TO_BOTTOM_LAYER] clips
the final layer to the size of the bottommost layer.
HELP

    &larry_pdb_misc('1998');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'merge_layer', type => 'layer',
          desc => 'The layer to merge down from' },
        { name => 'merge_type',
          type => 'enum GimpMergeType (no GIMP_FLATTEN_IMAGE)',
          desc => 'The type of merge' }
    );

    @outargs = (
        { name => 'layer', type => 'layer',
          desc => 'The resulting layer' }
    );

    %invoke = (
        headers => [ qw("core/gimpimage-merge.h") ],
        code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (merge_layer), image, 0, error))
    {
      GList *merge_layers = g_list_prepend (NULL, merge_layer);
      GList *layers;

      layers = gimp_image_merge_down (image, merge_layers, context,
                                      merge_type, progress, NULL, error);
      g_list_free (merge_layers);

      if (! layers)
        success = FALSE;
      else
        layer = layers->data;

      g_list_free (layers);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub image_flatten {
    $blurb = <<'BLURB';
Flatten all visible layers into a single layer. Discard all invisible layers.
BLURB

    $help = <<'HELP';
This procedure combines the visible layers in a manner analogous to merging
with the [enum@Gimp.MergeType.CLIP_TO_IMAGE] merge type. Non-visible layers
are discarded, and the resulting image is stripped of its alpha channel.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
   );

    @outargs = (
        { name => 'layer', type => 'layer',
          desc => 'The resulting layer' }
    );

    %invoke = (
        headers => [ qw("core/gimpimage-merge.h") ],
        code => <<'CODE'
{
  layer = gimp_image_flatten (image, context,
                              progress, error);

  if (! layer)
    success = FALSE;
}
CODE
    );
}

sub image_insert_layer {
    $blurb = 'Add the specified layer to the image.';

    $help = <<'HELP';
This procedure adds the specified layer to the image at the given
position. If the specified parent is a valid layer group (See
[method@Gimp.Item.is_group] and [ctor@Gimp.GroupLayer.new]) then the layer is
added inside the group. If the parent is 0, the layer is added inside
the main stack, outside of any group. The position argument specifies
the location of the layer inside the stack (or the group, if a valid
parent was supplied), starting from the top (0) and increasing.  If
the position is specified as -1 and the parent is specified as 0, then
the layer is inserted above the active layer, or inside the group if
the active layer is a layer group. The layer type must be compatible
with the image base type.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'layer', type => 'layer',
          desc => 'The layer' },
        { name => 'parent', type => 'layer', none_ok => 1,
          desc => 'The parent layer' },
        { name => 'position', type => 'int32',
          desc => 'The layer position' }
    );

    $invoke{code} = <<'CODE';
{
  if (gimp_pdb_item_is_floating (GIMP_ITEM (layer), image, error) &&
      gimp_pdb_image_is_base_type (image,
                                   gimp_drawable_get_base_type (GIMP_DRAWABLE (layer)),
                                   error) &&
      (parent == NULL ||
       (gimp_pdb_item_is_in_tree (GIMP_ITEM (parent), image, 0, error) &&
        gimp_pdb_item_is_group (GIMP_ITEM (parent), error))))
    {
      if (position == -1 && parent == NULL)
        parent = GIMP_IMAGE_ACTIVE_PARENT;

      /* see layer-new */
      if (gimp_drawable_is_gray (GIMP_DRAWABLE (layer)))
        gimp_layer_fix_format_space (layer, TRUE, FALSE);

      success = gimp_image_add_layer (image, layer,
                                      parent, MAX (position, -1), TRUE);
    }
  else
    {
      success = FALSE;
    }
}
CODE
}

sub image_remove_layer {
    $blurb = 'Remove the specified layer from the image.';

    $help = <<'HELP';
This procedure removes the specified layer from the image. If the
layer doesn't exist, an error is returned. If there are no layers left
in the image, this call will fail. If this layer is the last layer
remaining, the image will become empty and have no active layer.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'layer', type => 'layer',
          desc => 'The layer' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (layer), image, 0, error))
    gimp_image_remove_layer (image, layer, TRUE, NULL);
  else
    success = FALSE;
}
CODE
    );
}

sub image_freeze_layers {
    $blurb = "Freeze the image's layer list.";

    $help = <<'HELP';
This procedure freezes the layer list of the image, suppressing any
updates to the Layers dialog in response to changes to the image's
layers.  This can significantly improve performance while applying
changes affecting the layer list.


Each call to gimp_image_freeze_layers() should be matched by a
corresponding call to [method@Gimp.Image.thaw_layers], undoing its
effects.
HELP

    &ell_pdb_misc('2018', '2.10.2');

    @inargs = (
    { name => 'image', type => 'image',
      desc => 'The image' }
    );

    %invoke = (
    code => <<'CODE'
{
  GimpPlugIn    *plug_in   = gimp->plug_in_manager->current_plug_in;
  GimpContainer *container = gimp_image_get_layers (image);

  if (plug_in)
    success = gimp_plug_in_cleanup_layers_freeze (plug_in, image);

  if (success)
    gimp_container_freeze (container);
}
CODE
    );
}

sub image_thaw_layers {
    $blurb = "Thaw the image's layer list.";

    $help = <<'HELP';
This procedure thaws the layer list of the image, re-enabling
updates to the Layers dialog.


This procedure should match a corresponding call to
[method@Gimp.Image.freeze_layers].
HELP

    &ell_pdb_misc('2018', '2.10.2');

    @inargs = (
    { name => 'image', type => 'image',
      desc => 'The image' }
    );

    %invoke = (
    code => <<'CODE'
{
  GimpPlugIn    *plug_in   = gimp->plug_in_manager->current_plug_in;
  GimpContainer *container = gimp_image_get_layers (image);

  if (plug_in)
    success = gimp_plug_in_cleanup_layers_thaw (plug_in, image);

  if (success)
    success = gimp_container_frozen (container);

  if (success)
    gimp_container_thaw (container);
}
CODE
    );
}

sub image_insert_channel {
    $blurb = 'Add the specified channel to the image.';

    $help = <<'HELP';
This procedure adds the specified channel to the image at the given
position. Since channel groups are not currently supported, the parent
argument must always be 0. The position argument specifies the
location of the channel inside the stack, starting from the top (0) and
increasing. If the position is specified as -1, then the channel is
inserted above the active channel.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'channel', type => 'channel',
          desc => 'The channel' },
        { name => 'parent', type => 'channel', none_ok => 1,
          desc => 'The parent channel' },
        { name => 'position', type => 'int32',
          desc => 'The channel position' }
    );

    $invoke{code} = <<'CODE';
{
  if (gimp_pdb_item_is_floating (GIMP_ITEM (channel), image, error) &&
      (parent == NULL ||
       (gimp_pdb_item_is_in_tree (GIMP_ITEM (parent), image, 0, error) &&
        gimp_pdb_item_is_group (GIMP_ITEM (parent), error))))
    {
      if (position == -1 && parent == NULL)
        parent = GIMP_IMAGE_ACTIVE_PARENT;

      success = gimp_image_add_channel (image, channel,
                                        parent, MAX (position, -1), TRUE);
    }
  else
    {
      success = FALSE;
    }
}
CODE
}

sub image_remove_channel {
    $blurb = 'Remove the specified channel from the image.';

    $help = <<'HELP';
This procedure removes the specified channel from the image. If the channel
doesn't exist, an error is returned.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'channel', type => 'channel',
          desc => 'The channel' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (channel), image, 0, error))
    gimp_image_remove_channel (image, channel, TRUE, NULL);
  else
    success = FALSE;
}
CODE
    );
}

sub image_freeze_channels {
    $blurb = "Freeze the image's channel list.";

    &ell_pdb_misc('2018', '2.10.2');

    $help = <<'HELP';
This procedure freezes the channel list of the image, suppressing any
updates to the Channels dialog in response to changes to the image's
channels.  This can significantly improve performance while applying
changes affecting the channel list.


Each call to gimp_image_freeze_channels() should be matched by a
corresponding call to [method@Gimp.Image.thaw_channels], undoing its
effects.
HELP

    @inargs = (
    { name => 'image', type => 'image',
      desc => 'The image' }
    );

    %invoke = (
    code => <<'CODE'
{
  GimpPlugIn    *plug_in   = gimp->plug_in_manager->current_plug_in;
  GimpContainer *container = gimp_image_get_channels (image);

  if (plug_in)
    success = gimp_plug_in_cleanup_channels_freeze (plug_in, image);

  if (success)
    gimp_container_freeze (container);
}
CODE
    );
}

sub image_thaw_channels {
    $blurb = "Thaw the image's channel list.";

    &ell_pdb_misc('2018', '2.10.2');

    $help = <<'HELP';
This procedure thaws the channel list of the image, re-enabling
updates to the Channels dialog.


This procedure should match a corresponding call to
[method@Gimp.Image.freeze_channels].
HELP

    @inargs = (
    { name => 'image', type => 'image',
      desc => 'The image' }
    );

    %invoke = (
    code => <<'CODE'
{
  GimpPlugIn    *plug_in   = gimp->plug_in_manager->current_plug_in;
  GimpContainer *container = gimp_image_get_channels (image);

  if (plug_in)
    success = gimp_plug_in_cleanup_channels_thaw (plug_in, image);

  if (success)
    success = gimp_container_frozen (container);

  if (success)
    gimp_container_thaw (container);
}
CODE
    );
}

sub image_insert_path {
    $blurb = 'Add the specified path to the image.';

    $help = <<'HELP';
This procedure adds the specified path to the image at the given
position. Since path groups are not currently supported, the parent
argument must always be 0. The position argument specifies the
location of the path inside the stack, starting from the top (0) and
increasing. If the position is specified as -1, then the path is
inserted above the active path.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'path', type => 'path',
          desc => 'The path' },
        { name => 'parent', type => 'path', none_ok => 1,
          desc => 'The parent path' },
        { name => 'position', type => 'int32',
          desc => 'The path position' }
    );

    $invoke{code} = <<'CODE';
{
  if (gimp_pdb_item_is_floating (GIMP_ITEM (path), image, error) &&
      (parent == NULL ||
       (gimp_pdb_item_is_in_tree (GIMP_ITEM (parent), image, 0, error) &&
        gimp_pdb_item_is_group (GIMP_ITEM (parent), error))))
    {
      if (position == -1 && parent == NULL)
        parent = GIMP_IMAGE_ACTIVE_PARENT;

      success = gimp_image_add_path (image, path,
                                     parent, MAX (position, -1), TRUE);
    }
  else
    {
      success = FALSE;
    }
}
CODE
}

sub image_remove_path {
    $blurb = 'Remove the specified path from the image.';

    $help = <<'HELP';
This procedure removes the specified path from the image. If the path
doesn't exist, an error is returned.
HELP

    &simon_pdb_misc('2005', '2.4');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'path', type => 'path',
          desc => 'The path object' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (path), image, 0, error))
    gimp_image_remove_path (image, path, TRUE, NULL);
  else
    success = FALSE;
}
CODE
    );
}

sub image_import_paths_from_file {
    $blurb = 'Import paths from an SVG file.';

    $help = <<'HELP';
This procedure imports paths from an SVG file. SVG elements other than
paths and basic shapes are ignored.
HELP

    &simon_pdb_misc('2006', '2.4');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'file', type => 'file',
          desc => 'The SVG file to import.' },
        { name => 'merge', type => 'boolean',
          desc => 'Merge paths into a single path object.' },
        { name => 'scale', type => 'boolean',
          desc => 'Scale the SVG to image dimensions.' }
    );

    @outargs = (
        { name => 'paths', type => 'patharray', void_ret => 1,
          desc => 'The list of newly created paths' }
    );

    %invoke = (
        headers => [ qw("path/gimppath-import.h") ],
        code    => <<'CODE'
{
  GList *path_list = NULL;

  /* FIXME tree */
  success = gimp_path_import_file (image, file,
                                   merge, scale, NULL, -1,
                                   &path_list, error);

  if (success)
    {
      gsize  num_paths = g_list_length (path_list);
      GList *list;
      gint   i;

      paths = g_new0 (GimpPath *, num_paths + 1);

      for (i = 0, list = path_list;
           i < num_paths;
           i++, list = g_list_next (list))
        {
          paths[i] = list->data;
        }

      g_list_free (path_list);
    }
}
CODE
    );
}

sub image_import_paths_from_string {
    $blurb = 'Import paths from an SVG string.';

    $help = <<'HELP';
This procedure works like [method@Gimp.Image.import_paths_from_file] but takes a string
rather than reading the SVG from a file. This allows you to write scripts that
generate SVG and feed it to GIMP.
HELP

    &simon_pdb_misc('2006', '2.4');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'string', type => 'string', allow_non_utf8 => 1,
          desc => 'A string that must be a complete and valid SVG document.' },
        { name => 'length', type => 'int32',
          desc => 'Number of bytes in string or -1 if the string is NULL
                   terminated.' },
        { name => 'merge', type => 'boolean',
          desc => 'Merge paths into a single path object.' },
        { name => 'scale', type => 'boolean',
          desc => 'Scale the SVG to image dimensions.' }
    );

    @outargs = (
        { name => 'paths', type => 'patharray', void_ret => 1,
          desc => 'The list of newly created paths' }
    );

    %invoke = (
        headers => [ qw("path/gimppath-import.h") ],
        code    => <<'CODE'
{
  GList *path_list = NULL;

  /* FIXME tree */
  success = gimp_path_import_buffer (image, string, length,
                                     merge, scale, NULL, -1,
                                     &path_list, error);

  if (success)
    {
      GList *list;
      gsize  num_paths = g_list_length (path_list);
      gint   i;

      paths = g_new0 (GimpPath *, num_paths + 1);

      for (i = 0, list = path_list;
           i < num_paths;
           i++, list = g_list_next (list))
        {
          paths[i] = list->data;
        }

      g_list_free (path_list);
    }
}
CODE
    );
}

sub image_export_path_to_file {
    $blurb = 'save a path as an SVG file.';

    $help = <<'HELP';
This procedure creates an SVG file to save a Path object, that is,
a path.  The resulting file can be edited using a vector graphics
application, or later reloaded into GIMP.  Pass %NULL as the 'path'
argument to export all paths in the image.
HELP

    &bill_pdb_misc('2007', '2.6');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'file', type => 'file',
          desc => 'The SVG file to create.' },
        { name => 'path', type => 'path',
          no_validate => 1, none_ok => 1,
          desc => 'The path object to export, or %NULL for all in the image' }
    );

    %invoke = (
        headers => [ qw("path/gimppath-export.h") ],
        code    => <<'CODE'
{
  GList *path_list = NULL;

  if (path != NULL)
    path_list = g_list_prepend (path_list, path);

  success = gimp_path_export_file (image, path_list, file, error);

  g_list_free (path_list);
}
CODE
    );
}

sub image_export_path_to_string {
    $blurb = 'Save a path as an SVG string.';

    $help = <<'HELP';
This procedure works like [method@Gimp.Image.export_path_to_file] but creates a string
rather than a file. The string is NULL-terminated and holds a
complete XML document.  Pass %NULL as the 'path' argument to export
all paths in the image.
HELP

    &bill_pdb_misc('2007', '2.6');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'path', type => 'path',
          no_validate => 1, none_ok => 1,
          desc => 'The path object to export, or %NULL for all in the image' }
    );

    @outargs = (
        { name => 'string', type => 'string',
          desc => 'A string whose contents are a complete SVG document.' }
    );

    %invoke = (
        headers => [ qw("path/gimppath-export.h") ],
        code    => <<'CODE'
{
  GList *path_list = NULL;

  if (path != NULL)
    path_list = g_list_prepend (path_list, path);

  string = gimp_path_export_string (image, path_list);
  g_list_free (path_list);

  success = (string != NULL);
}
CODE
    );
}

sub image_freeze_paths {
    $blurb = "Freeze the image's path list.";

    &ell_pdb_misc('2018', '2.10.2');

    $help = <<'HELP';
This procedure freezes the path list of the image, suppressing any
updates to the Paths dialog in response to changes to the image's
path.  This can significantly improve performance while applying
changes affecting the path list.


Each call to gimp_image_freeze_paths() should be matched by a
corresponding call to [method@Gimp.Image.thaw_paths], undoing its
effects.
HELP

    @inargs = (
    { name => 'image', type => 'image',
      desc => 'The image' }
    );

    %invoke = (
    code => <<'CODE'
{
  GimpPlugIn    *plug_in   = gimp->plug_in_manager->current_plug_in;
  GimpContainer *container = gimp_image_get_paths (image);

  if (plug_in)
    success = gimp_plug_in_cleanup_paths_freeze (plug_in, image);

  if (success)
    gimp_container_freeze (container);
}
CODE
    );
}

sub image_thaw_paths {
    $blurb = "Thaw the image's path list.";

    &ell_pdb_misc('2018', '2.10.2');

    $help = <<'HELP';
This procedure thaws the path list of the image, re-enabling
updates to the Paths dialog.


This procedure should match a corresponding call to
[method@Gimp.Image.freeze_paths].
HELP

    @inargs = (
    { name => 'image', type => 'image',
      desc => 'The image' }
    );

    %invoke = (
    code => <<'CODE'
{
  GimpPlugIn    *plug_in   = gimp->plug_in_manager->current_plug_in;
  GimpContainer *container = gimp_image_get_paths (image);

  if (plug_in)
    success = gimp_plug_in_cleanup_paths_thaw (plug_in, image);

  if (success)
    success = gimp_container_frozen (container);

  if (success)
    gimp_container_thaw (container);
}
CODE
    );
}

sub image_get_base_type {
    $blurb = 'Get the base type of the image.';

    $help = <<'HELP';
This procedure returns the image's base type. Layers in the image must be of
this subtype, but can have an optional alpha channel.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'base_type', type => 'enum GimpImageBaseType',
          desc => "The image's base type" }
    );

    %invoke = (
        code => <<'CODE'
{
  base_type = gimp_image_get_base_type (image);
}
CODE
    );
}

sub image_get_precision {
    $blurb = 'Get the precision of the image.';

    $help = <<'HELP';
This procedure returns the image's precision.
HELP

    &mitch_pdb_misc('2012', '2.10');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'precision', type => 'enum GimpPrecision',
          desc => "The image's precision" }
    );

    %invoke = (
        code => <<'CODE'
{
  precision = gimp_image_get_precision (image);
}
CODE
    );
}

sub image_get_default_new_layer_mode {
    $blurb = 'Get the default mode for newly created layers of this image.';
    $help  = 'Returns the default mode for newly created layers of this image.';

    &mitch_pdb_misc('2017', '2.10');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
	{ name => 'mode', type => 'enum GimpLayerMode',
          default => 'GIMP_LAYER_MODE_NORMAL',
	  desc => 'The layer mode' }
    );

    %invoke = (
	code => <<'CODE'
{
  mode = gimp_image_get_default_new_layer_mode (image);
}
CODE
    );
}

sub image_get_palette {
    $blurb = "Returns the image's colormap";

    $help = <<'HELP';
This procedure returns the image's colormap as a [class@Gimp.Palette].
If the image is not in Indexed color mode, %NULL is returned.
HELP

    &jehan_pdb_misc('2023', '3.0');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'palette', type => 'palette',
          desc => "The image's colormap palette." }
    );

    %invoke = (
        headers => [ qw("core/gimpimage-colormap.h") ],
        code => <<'CODE'
{
  palette = gimp_image_get_colormap_palette (image);
}
CODE
    );
}

sub image_set_palette {
    $blurb = 'Set the image\'s colormap to a copy of @palette';

    $help = <<'HELP';
This procedure changes the image's colormap to an exact copy of @palette
and returns the palette of @image.

If the image is not in Indexed color mode, nothing happens and %NULL is
returned.
HELP

    &jehan_pdb_misc('2024', '3.0');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'new_palette', type => 'palette',
          desc => "The palette to copy from." }
    );

    @outargs = (
        { name => 'palette', type => 'palette',
          desc => "The image's colormap palette." }
    );

    %invoke = (
        headers => [ qw("core/gimpimage-colormap.h") ],
        code => <<'CODE'
{
  palette = gimp_image_get_colormap_palette (image);

  if (palette == NULL || new_palette == NULL)
    success = FALSE;
  else if (new_palette != palette)
    gimp_image_set_colormap_palette (image, new_palette, TRUE);
}
CODE
    );
}

sub image_get_metadata {
    $blurb = "Returns the image's metadata.";
    $help  = 'Returns exif/iptc/xmp metadata from the image.';

    &std_pdb_misc('2013', '2.10');

    $lib_private = 1;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
	{ name => 'metadata_string', type => 'string',
	  desc => 'The exif/ptc/xmp metadata as a string'}
    );

    %invoke = (
	code => <<'CODE'
{
  GimpMetadata *metadata = gimp_image_get_metadata (image);

  if (metadata)
    metadata_string = gimp_metadata_serialize (metadata);
}
CODE
    );
}

sub image_set_metadata {
    $blurb = "Set the image's metadata.";
    $help  = 'Sets exif/iptc/xmp metadata on the image.';

    &std_pdb_misc('2013', '2.10');

    $lib_private = 1;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
	{ name => 'metadata_string', type => 'string',
	  desc => 'The exif/ptc/xmp metadata as a string' }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpMetadata *metadata = gimp_metadata_deserialize (metadata_string);

  gimp_image_set_metadata (image, metadata, TRUE);

  if (metadata)
    g_object_unref (metadata);
}
CODE
    );
}

sub image_clean_all {
    $blurb = 'Set the image dirty count to 0.';

    $help = <<'HELP';
This procedure sets the specified image's dirty count to 0, allowing
operations to occur without having a 'dirtied' image. This is
especially useful for creating and loading images which should not
initially be considered dirty, even though layers must be created,
filled, and installed in the image. Note that save plug-ins must NOT
call this function themselves after saving the image.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    %invoke = (
        code => <<'CODE'
{
  gimp_image_clean_all (image);
}
CODE
    );
}

sub image_is_dirty {
    $blurb = 'Checks if the image has unsaved changes.';

    $help = <<'HELP';
This procedure checks the specified image's dirty count to see if it
needs to be saved. Note that saving the image does not automatically
set the dirty count to 0, you need to call [method@Gimp.Image.clean_all] after
calling a save procedure to make the image clean.


When loading an image using e.g. [func@Gimp.file_load], or when created
by a [class@Gimp.LoadProcedure], the image will be marked as clean.
In other cases, it may sometimes be useful to clean programmatically
created image yourself.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'dirty', type => 'boolean',
          desc => 'TRUE if the image has unsaved changes.' }
    );

    %invoke = (
        code => <<'CODE'
{
  dirty = gimp_image_is_dirty (image);
}
CODE
    );
}

sub image_get_floating_sel {
    $blurb = 'Return the floating selection of the image.';

    $help = <<'HELP';
This procedure returns the image's floating selection, if it exists.
If it doesn't exist, -1 is returned as the layer ID.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'floating_sel', type => 'layer',
          desc => "The image's floating selection" }
    );

    %invoke = (
        code => <<'CODE'
{
  floating_sel = gimp_image_get_floating_selection (image);
}
CODE
    );
}

sub image_floating_sel_attached_to {
    $blurb = 'Return the drawable the floating selection is attached to.';

    $help = <<'HELP';
This procedure returns the drawable the image's floating selection is attached
to, if it exists. If it doesn't exist, -1 is returned as the drawable ID.
HELP

    &wolfgang_pdb_misc('1998');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'drawable', type => 'drawable',
          desc => 'The drawable the floating selection is attached to' }
    );

    %invoke = (
        code => <<'CODE'
{
  GimpLayer *floating_sel = gimp_image_get_floating_selection (image);

  if (floating_sel)
    drawable = gimp_layer_get_floating_sel_drawable (floating_sel);
  else
    drawable = NULL;
}
CODE
    );
}

sub image_get_width {
    $blurb = 'Return the width of the image';

    $help = <<'HELP';
This procedure returns the image's width. This value is independent of any of
the layers in this image. This is the "canvas" width.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'width', type => 'int32',
          desc => "The image's width" }
    );

    %invoke = (
        code => <<'CODE'
{
  width = gimp_image_get_width (image);
}
CODE
    );
}

sub image_get_height {
    $blurb = 'Return the height of the image';

    $help = <<'HELP';
This procedure returns the image's height. This value is independent of any of
the layers in this image. This is the "canvas" height.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'height', type => 'int32',
          desc => "The image's height" }
    );

    %invoke = (
        code => <<'CODE'
{
  height = gimp_image_get_height (image);
}
CODE
    );
}

sub image_get_selected_layers {
    $blurb = "Returns the specified image's selected layers.";

    $help = <<'HELP';
This procedure returns the list of selected layers in the specified image.
HELP

    &jehan_pdb_misc('2020', '3.0.0');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'layers', type => 'layerarray',
          desc => 'The list of selected layers in the image.' }
    );

    %invoke = (
        code => <<'CODE'
{
  GList *list = gimp_image_get_selected_layers (image);
  gsize  num_layers;
  gint   i;

  num_layers = g_list_length (list);
  layers = g_new0 (GimpLayer *, num_layers + 1);

  for (i = 0; i < num_layers; i++, list = g_list_next (list))
    layers[i] = list->data;
}
CODE
    );
}

sub image_set_selected_layers {
    $blurb = "Sets the specified image's selected layers.";

    $help = <<'HELP';
The layers are set as the selected layers in the image. Any previous
selected layers or channels are unselected. An exception is a previously
existing floating selection, in which case this procedure will return an
execution error.
HELP

    &jehan_pdb_misc('2021', '3.0.0');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'layers', type => 'layerarray',
          desc => 'The list of layers to select' }
    );

    %invoke = (
        code => <<'CODE'
{
  GList *selected_layers = NULL;
  gint   i;

  if (layers)
    for (i = 0; layers[i] != NULL; i++)
      selected_layers = g_list_prepend (selected_layers, (gpointer) layers[i]);

  gimp_image_set_selected_layers (image, selected_layers);
  g_list_free (selected_layers);
}
CODE
    );
}

sub image_get_selected_channels {
    $blurb = "Returns the specified image's selected channels.";

    $help = <<'HELP';
This procedure returns the list of selected channels in the specified image.
HELP

    &jehan_pdb_misc('2022', '3.0.0');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'channels', type => 'channelarray',
          desc => 'The list of selected channels in the image.' }
    );

    %invoke = (
        code => <<'CODE'
{
  GList *list = gimp_image_get_selected_channels (image);
  gsize  num_channels;
  gint   i;

  num_channels = g_list_length (list);
  channels = g_new0 (GimpChannel *, num_channels + 1);

  for (i = 0; i < num_channels; i++, list = g_list_next (list))
    channels[i] = list->data;
}
CODE
    );
}

sub image_set_selected_channels {
    $blurb = "Sets the specified image's selected channels.";

    $help = <<'HELP';
The channels are set as the selected channels in the image. Any previous
selected layers or channels are unselected. An exception is a previously
existing floating selection, in which case this procedure will return an
execution error.
HELP

    &jehan_pdb_misc('2022', '3.0.0');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'channels', type => 'channelarray',
          desc => 'The list of channels to select' }
    );

    %invoke = (
        code => <<'CODE'
{
  GList *selected_channels = NULL;
  gint   i;

  if (channels)
    for (i = 0; channels[i] != NULL; i++)
      selected_channels = g_list_prepend (selected_channels, (gpointer) channels[i]);

  gimp_image_set_selected_channels (image, selected_channels);
  g_list_free (selected_channels);
}
CODE
    );
}

sub image_get_selected_paths {
    $blurb = "Returns the specified image's selected paths.";

    $help = <<'HELP';
This procedure returns the list of selected paths in the specified image.
HELP

    &jehan_pdb_misc('2022', '3.0.0');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'paths', type => 'patharray',
          desc => 'The list of selected paths in the image.' }
    );

    %invoke = (
        code => <<'CODE'
{
  GList *list = gimp_image_get_selected_paths (image);
  gsize  num_paths;
  gint   i;

  num_paths = g_list_length (list);
  paths     = g_new0 (GimpPath *, num_paths + 1);

  for (i = 0; i < num_paths; i++, list = g_list_next (list))
    paths[i] = g_object_ref (list->data);
}
CODE
    );
}

sub image_set_selected_paths {
    $blurb = "Sets the specified image's selected paths.";

    $help = <<'HELP';
The paths are set as the selected paths in the image.
HELP

    &jehan_pdb_misc('2022', '3.0.0');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'paths', type => 'patharray',
          desc => 'The list of paths to select' }
    );

    %invoke = (
        code => <<'CODE'
{
  GList *selected_paths = NULL;
  gint   i;

  for (i = 0; paths[i] != NULL; i++)
    selected_paths = g_list_prepend (selected_paths, (gpointer) paths[i]);

  gimp_image_set_selected_paths (image, selected_paths);
  g_list_free (selected_paths);
}
CODE
    );
}

sub image_get_selected_drawables {
    $blurb = "Get the image's selected drawables";

    $help = <<'HELP';
This procedure returns the list of selected drawable in the specified image.
This can be either layers, channels, or a layer mask.

The active drawables are the active image channels. If there are none,
these are the active image layers. If the active image layer has a layer
mask and the layer mask is in edit mode, then the layer mask is the
active drawable.
HELP

    &jehan_pdb_misc('2022', '3.0.0');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'drawables', type => 'drawablearray',
          desc => 'The list of selected drawables in the image.' }
    );

    %invoke = (
        code => <<'CODE'
{
  GList *list = gimp_image_get_selected_drawables (image);
  gsize  num_drawables;
  gint   i;

  num_drawables = g_list_length (list);
  drawables     = g_new0 (GimpDrawable *, num_drawables + 1);

  for (i = 0; i < num_drawables; i++, list = g_list_next (list))
    drawables[i] = list->data;
}
CODE
    );
}

sub image_get_selection {
    $blurb = "Returns the specified image's selection.";

    $help = <<'HELP';
This will always return a valid ID for a selection -- which is represented as a
channel internally.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'selection', type => 'selection',
          desc => 'The selection channel' }
    );

    %invoke = (
        code => <<'CODE'
{
  selection = GIMP_SELECTION (gimp_image_get_mask (image));

  if (! selection)
    success = FALSE;
}
CODE
    );
}

sub image_get_component_active {
    $blurb = "Returns if the specified image's image component is active.";

    $help = <<'HELP';
This procedure returns if the specified image's image component
(i.e. Red, Green, Blue intensity channels in an RGB image) is active
or inactive -- whether or not it can be modified. If the specified
component is not valid for the image type, an error is returned.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'component', type => 'enum GimpChannelType',
          desc => 'The image component' }
    );

    @outargs = (
        { name => 'active', type => 'boolean',
          desc => 'Component is active' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (component == GIMP_CHANNEL_GRAY)
    success = gimp_pdb_image_is_base_type (image, GIMP_GRAY, error);
  else if (component == GIMP_CHANNEL_INDEXED)
    success = gimp_pdb_image_is_base_type (image, GIMP_INDEXED, error);
  else
    success = gimp_pdb_image_is_base_type (image, GIMP_RGB, error);

  if (success)
    active = gimp_image_get_component_active (image, component);
}
CODE
    );
}

sub image_set_component_active {
    $blurb = "Sets if the specified image's image component is active.";

    $help = <<'HELP';
This procedure sets if the specified image's image component
(i.e. Red, Green, Blue intensity channels in an RGB image) is active
or inactive -- whether or not it can be modified. If the specified
component is not valid for the image type, an error is returned.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'component', type => 'enum GimpChannelType',
          desc => 'The image component' },
        { name => 'active', type => 'boolean',
          desc => 'Component is active' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (component == GIMP_CHANNEL_GRAY)
    success = gimp_pdb_image_is_base_type (image, GIMP_GRAY, error);
  else if (component == GIMP_CHANNEL_INDEXED)
    success = gimp_pdb_image_is_base_type (image, GIMP_INDEXED, error);
  else
    success = gimp_pdb_image_is_base_type (image, GIMP_RGB, error);

  if (success)
    gimp_image_set_component_active (image, component, active);
}
CODE
    );
}

sub image_get_component_visible {
    $blurb = "Returns if the specified image's image component is visible.";

    $help = <<'HELP';
This procedure returns if the specified image's image component
(i.e. Red, Green, Blue intensity channels in an RGB image) is visible
or invisible -- whether or not it can be seen. If the specified
component is not valid for the image type, an error is returned.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'component', type => 'enum GimpChannelType',
          desc => 'The image component' }
    );

    @outargs = (
        { name => 'visible', type => 'boolean',
          desc => 'Component is visible' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (component == GIMP_CHANNEL_GRAY)
    success = gimp_pdb_image_is_base_type (image, GIMP_GRAY, error);
  else if (component == GIMP_CHANNEL_INDEXED)
    success = gimp_pdb_image_is_base_type (image, GIMP_INDEXED, error);
  else
    success = gimp_pdb_image_is_base_type (image, GIMP_RGB, error);

  if (success)
    visible = gimp_image_get_component_visible (image, component);
}
CODE
    );
}

sub image_set_component_visible {
    $blurb = "Sets if the specified image's image component is visible.";

    $help = <<'HELP';
This procedure sets if the specified image's image component
(i.e. Red, Green, Blue intensity channels in an RGB image) is visible
or invisible -- whether or not it can be seen. If the specified
component is not valid for the image type, an error is returned.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'component', type => 'enum GimpChannelType',
          desc => 'The image component' },
        { name => 'visible', type => 'boolean',
          desc => 'Component is visible' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (component == GIMP_CHANNEL_GRAY)
    success = gimp_pdb_image_is_base_type (image, GIMP_GRAY, error);
  else if (component == GIMP_CHANNEL_INDEXED)
    success = gimp_pdb_image_is_base_type (image, GIMP_INDEXED, error);
  else
    success = gimp_pdb_image_is_base_type (image, GIMP_RGB, error);

  if (success)
    gimp_image_set_component_visible (image, component, visible);
}
CODE
    );
}

sub image_get_file {
    $blurb = "Returns the file for the specified image.";

    $help = <<'HELP';
This procedure returns the file associated with the specified image.
The image has a file only if it was loaded or imported from a file or
has since been saved or exported. Otherwise, this function returns
%NULL.  See also gimp-image-get-imported-file to get the
current file if it was imported from a non-GIMP file format and not
yet saved, or gimp-image-get-exported-file if the image has been
exported to a non-GIMP file format.
HELP

    &neo_pdb_misc('2009', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'file', type => 'file',
          desc => 'The file.' }
    );

    %invoke = (
        code => <<'CODE'
{
  file = gimp_image_get_any_file (image);
  if (file)
    g_object_ref (file);
}
CODE
    );
}

sub image_set_file {
    $blurb = "Sets the specified XCF image's file.";

    $help = <<'HELP';
This procedure sets the specified image's file.

This is to set the XCF file associated with your image. In particular, do not
use this function to set the imported file in file import plug-ins. This is done
by the core process.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'file', type => 'file',
          desc => 'The new image file' }
    );

    %invoke = (
        code => <<'CODE'
{
  gchar *uri;
  gchar *folded_uri;

  uri        = g_file_get_uri (file);
  folded_uri = g_utf8_casefold (uri, -1);

  if (! g_regex_match_simple ("\\.xcf(\\.?(gz|bz2|xz))?$", uri, G_REGEX_CASELESS, 0))
    {
      gchar *dot = g_strrstr (uri, ".");

      if (dot != NULL && strstr (dot + 1, G_DIR_SEPARATOR_S) == NULL)
        g_printerr ("%s: failure to set file '%s' with extension '%s'. "
                    "The extension must be '.xcf' (or a compressed variant).\n",
                    "gimp_image_set_file", uri, dot + 1);
      else
        g_printerr ("%s: failure to set file '%s' without extension. "
                    "The extension must be '.xcf' (or a compressed variant).\n",
                    "gimp_image_set_file", uri);

      success = FALSE;
    }
  if (success)
    gimp_image_set_file (image, file);

  g_free (uri);
  g_free (folded_uri);
}
CODE
    );
}

sub image_get_xcf_file {
    $blurb = "Returns the XCF file for the specified image.";

    $help = <<'HELP';
This procedure returns the XCF file associated with the image. If
there is no such file, this procedure returns %NULL.
HELP

    $author = 'Eric Grivel <gimp@lumenssolutions.com>';
    $copyright = 'Eric Grivel';
    $date = '2011';
    $since = '2.8';

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'file', type => 'file',
          desc => 'The imported XCF file.' }
    );

    %invoke = (
        code => <<'CODE'
{
  file = gimp_image_get_file (image);
  if (file)
    g_object_ref (file);
}
CODE
    );
}

sub image_get_imported_file {
    $blurb = "Returns the imported file for the specified image.";

    $help = <<'HELP';
This procedure returns the file associated with the specified image
if the image was imported from a non-native Gimp format. If the
image was not imported, or has since been saved in the native Gimp
format, this procedure returns %NULL.
HELP

    $author = 'Eric Grivel <gimp@lumenssolutions.com>';
    $copyright = 'Eric Grivel';
    $date = '2011';
    $since = '2.8';

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'file', type => 'file',
          desc => 'The imported file.' }
    );

    %invoke = (
        code => <<'CODE'
{
  file = gimp_image_get_imported_file (image);
  if (file)
    g_object_ref (file);
}
CODE
    );
}

sub image_get_exported_file {
    $blurb = "Returns the exported file for the specified image.";

    $help = <<'HELP';
This procedure returns the file associated with the specified image
if the image was exported a non-native GIMP format. If the
image was not exported, this procedure returns %NULL.
HELP

    $author = 'Eric Grivel <gimp@lumenssolutions.com>';
    $copyright = 'Eric Grivel';
    $date = '2011';
    $since = '2.8';

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'file', type => 'file',
          desc => 'The exported file.' }
    );

    %invoke = (
        code => <<'CODE'
{
  file = gimp_image_get_exported_file (image);
  if (file)
    g_object_ref (file);
}
CODE
    );
}

sub image_get_name {
    $blurb = "Returns the specified image's name.";
    $help  =  <<'HELP';
This procedure returns the image's name. If the image has a filename
or an URI, then the returned name contains the filename's or URI's
base name (the last component of the path). Otherwise it is the
translated string "Untitled". The returned name is formatted like the
image name in the image window title, it may contain '[]',
'(imported)' etc. and should only be used to label user interface
elements. Never use it to construct filenames.
HELP

    &std_pdb_misc;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'name', type => 'string',
          desc => 'The name.' }
    );

    %invoke = (
        code => <<'CODE'
{
  name = g_strdup (gimp_image_get_display_name (image));
}
CODE
    );
}

sub image_get_resolution {
    $blurb = "Returns the specified image's resolution.";

    $help = <<'HELP';
This procedure returns the specified image's resolution in dots per inch.
This value is independent of any of the layers in this image.
HELP

    &austin_pdb_misc('1998');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'xresolution', type => 'double', void_ret => 1,
          desc => 'The resolution in the x-axis, in dots per inch' },
        { name => 'yresolution', type => 'double',
          desc => 'The resolution in the y-axis, in dots per inch' }
    );

    %invoke = (
        code => <<'CODE'
{
  gimp_image_get_resolution (image, &xresolution, &yresolution);
}
CODE
    );
}

sub image_set_resolution {
    $blurb = "Sets the specified image's resolution.";

    $help = <<'HELP';
This procedure sets the specified image's resolution in dots per inch.
This value is independent of any of the layers in this image.
No scaling or resizing is performed.
HELP

    &austin_pdb_misc('1998');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'xresolution', type => 'double',
          desc => 'The new image resolution in the x-axis, in dots per inch' },
        { name => 'yresolution', type => 'double',
          desc => 'The new image resolution in the y-axis, in dots per inch' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (! isfinite (xresolution) ||
      xresolution < GIMP_MIN_RESOLUTION || xresolution > GIMP_MAX_RESOLUTION ||
      ! isfinite (yresolution) ||
      yresolution < GIMP_MIN_RESOLUTION || yresolution > GIMP_MAX_RESOLUTION)
    {
      g_set_error_literal (error, GIMP_PDB_ERROR,
                           GIMP_PDB_ERROR_INVALID_ARGUMENT,
                           _("Image resolution is out of bounds, "
                             "using the default resolution instead."));
      success = FALSE;
    }
  else
    {
      gimp_image_set_resolution (image, xresolution, yresolution);
    }
}
CODE
    );
}

sub image_get_unit {
    $blurb = "Returns the specified image's unit.";

    $help = <<'HELP';
This procedure returns the specified image's unit. This value is
independent of any of the layers in this image. See the gimp_unit_*()
procedure definitions for the valid range of unit IDs and a
description of the unit system.
HELP

    &mitch_pdb_misc('1998');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'unit', type => 'unit',
          desc => 'The unit' }
    );

    %invoke = (
        code => <<'CODE'
{
  unit = gimp_image_get_unit (image);
}
CODE
    );
}

sub image_set_unit {
    $blurb = "Sets the specified image's unit.";

    $help = <<'HELP';
This procedure sets the specified image's unit. No scaling or resizing
is performed. This value is independent of any of the layers in this
image. See the gimp_unit_*() procedure definitions for the valid range
of unit IDs and a description of the unit system.
HELP

    &mitch_pdb_misc('1998');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'unit', type => 'unit',
          desc => 'The new image unit' }
    );

    %invoke = (
        code => <<'CODE'
{
  gimp_image_set_unit (image, unit);
}
CODE
    );
}

sub image_get_tattoo_state {
    $blurb = 'Returns the tattoo state associated with the image.';

    $help = <<'HELP';
This procedure returns the tattoo state of the image. Use only by
save/load plug-ins that wish to preserve an images tattoo state. Using this
function at other times will produce unexpected results.
HELP

    &andy_pdb_misc('2000');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'tattoo_state', type => 'tattoo',
          desc => 'The tattoo state' }
    );

    %invoke = (
        code => <<'CODE'
{
  tattoo_state = gimp_image_get_tattoo_state (image);
}
CODE
    );
}

sub image_set_tattoo_state {
    $blurb = 'Set the tattoo state associated with the image.';

    $help = <<'HELP';
This procedure sets the tattoo state of the image. Use only by
save/load plug-ins that wish to preserve an images tattoo state. Using
this function at other times will produce unexpected results. A full
check of uniqueness of states in layers, channels and paths will be
performed by this procedure and a execution failure will be returned
if this fails. A failure will also be returned if the new tattoo state
value is less than the maximum tattoo value from all of the tattoos
from the paths, layers and channels. After the image data has been
loaded and all the tattoos have been set then this is the last
procedure that should be called. If effectively does a status check on
the tattoo values that have been set to make sure that all is OK.
HELP

    &andy_pdb_misc('2000');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'tattoo_state', type => 'tattoo',
          desc => 'The new image tattoo state' }
    );

    %invoke = (
        code => <<'CODE'
{
  gimp_image_set_tattoo_state (image, tattoo_state);
}
CODE
    );
}

sub image_get_layer_by_tattoo {
    $blurb = 'Find a layer with a given tattoo in an image.';

    $help = <<'HELP';
This procedure returns the layer with the given tattoo in the specified image.
HELP

    &jay_pdb_misc('1998');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'tattoo', type => 'tattoo',
          desc => 'The tattoo of the layer to find' }
    );

    @outargs = (
        { name => 'layer', type => 'layer',
          desc => 'The layer with the specified tattoo' }
    );

    %invoke = (
        code => <<'CODE'
{
  layer = gimp_image_get_layer_by_tattoo (image, tattoo);
}
CODE
    );
}

sub image_get_channel_by_tattoo {
    $blurb = 'Find a channel with a given tattoo in an image.';

    $help = <<'HELP';
This procedure returns the channel with the given tattoo in the specified image.
HELP

    &jay_pdb_misc('1998');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'tattoo', type => 'tattoo',
          desc => 'The tattoo of the channel to find' }
    );

    @outargs = (
        { name => 'channel', type => 'channel',
          desc => 'The channel with the specified tattoo' }
    );

    %invoke = (
        code => <<'CODE'
{
  channel = gimp_image_get_channel_by_tattoo (image, tattoo);
}
CODE
    );
}

sub image_get_path_by_tattoo {
    $blurb = 'Find a path with a given tattoo in an image.';

    $help = <<'HELP';
This procedure returns the path with the given tattoo in the
specified image.
HELP

    &simon_pdb_misc('2005', '2.6');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'tattoo', type => 'tattoo',
          desc => 'The tattoo of the path to find' }
    );

    @outargs = (
        { name => 'path', type => 'path',
          desc => 'The path with the specified tattoo' }
    );

    %invoke = (
        code => <<'CODE'
{
  path = gimp_image_get_path_by_tattoo (image, tattoo);
}
CODE
    );
}

sub image_get_layer_by_name {
    $blurb = 'Find a layer with a given name in an image.';

    $help = <<'HELP';
This procedure returns the layer with the given name in the specified image.
HELP

    &mitch_pdb_misc('2011', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'name', type => 'string', non_empty => 1,
          desc => 'The name of the layer to find' }
    );

    @outargs = (
        { name => 'layer', type => 'layer',
          desc => 'The layer with the specified name' }
    );

    %invoke = (
        code => <<'CODE'
{
  layer = gimp_image_get_layer_by_name (image, name);
}
CODE
    );
}

sub image_get_channel_by_name {
    $blurb = 'Find a channel with a given name in an image.';

    $help = <<'HELP';
This procedure returns the channel with the given name in the specified image.
HELP

    &mitch_pdb_misc('2011', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'name', type => 'string', non_empty => 1,
          desc => 'The name of the channel to find' }
    );

    @outargs = (
        { name => 'channel', type => 'channel',
          desc => 'The channel with the specified name' }
    );

    %invoke = (
        code => <<'CODE'
{
  channel = gimp_image_get_channel_by_name (image, name);
}
CODE
    );
}

sub image_get_path_by_name {
    $blurb = 'Find a path with a given name in an image.';

    $help = <<'HELP';
This procedure returns the path with the given name in the
specified image.
HELP

    &mitch_pdb_misc('2011', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'name', type => 'string', non_empty => 1,
          desc => 'The name of the path to find' }
    );

    @outargs = (
        { name => 'path', type => 'path',
          desc => 'The path with the specified name' }
    );

    %invoke = (
        code => <<'CODE'
{
  path = gimp_image_get_path_by_name (image, name);
}
CODE
    );
}

sub image_attach_parasite {
    $blurb = 'Add a parasite to an image.';

    $help = <<'HELP';
This procedure attaches a parasite to an image. It has no return values.
HELP

    &jay_pdb_misc('1998', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'parasite', type => 'parasite',
          desc => 'The parasite to attach to an image' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_image_parasite_validate (image, parasite, error))
    gimp_image_parasite_attach (image, parasite, TRUE);
  else
    success = FALSE;
}
CODE
    );
}

sub image_detach_parasite {
    $blurb = 'Removes a parasite from an image.';

    $help = <<'HELP';
This procedure detaches a parasite from an image.


It will return %FALSE if @name is invalid (%NULL or empty string) and
%TRUE otherwise (even if there was no parasite removed, because no
parasite was named like this).
HELP

    &jay_pdb_misc('1998', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'name', type => 'string',
          desc => 'The name of the parasite to detach from an image.' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (name && strlen (name) > 0)
    gimp_image_parasite_detach (image, name, TRUE);
  else
    success = FALSE;
}
CODE
    );
}

sub image_get_parasite {
    $blurb = 'Look up a parasite in an image';

    $help = <<'HELP';
Finds and returns the parasite that was previously attached to an image.
HELP

    &jay_pdb_misc('1998', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'name', type => 'string',
          desc => 'The name of the parasite to find' }
    );

    @outargs = (
        { name => 'parasite', type => 'parasite',
          desc => 'The found parasite' }
    );

    %invoke = (
        code => <<'CODE'
{
  parasite = gimp_parasite_copy (gimp_image_parasite_find (image, name));

  if (! parasite)
    success = FALSE;
}
CODE
    );
}

sub image_get_parasite_list {
    $blurb = 'List all parasites.';
    $help = <<'HELP';
Returns a list of the names of all currently attached parasites.
These names can later be used to get the actual #GimpParasite with
gimp_image_get_parasite() when needed.
HELP

    &marc_pdb_misc('1999', '2.8');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' }
    );

    @outargs = (
        { name => 'parasites', type => 'strv',
          desc => 'The names of currently attached parasites' }
    );

    %invoke = (
        code => <<'CODE'
{
  parasites = gimp_image_parasite_list (image);
}
CODE
    );
}

sub image_thumbnail {
    $blurb = 'Get a thumbnail of an image.';

    $help = <<'HELP';
This function gets data from which a thumbnail of an image preview can
be created. Maximum x or y dimension is 1024 pixels. The pixels are
returned in RGB[A] or GRAY[A] format. The bpp return value gives the
number of bits per pixel in the image.
HELP

    &andy_pdb_misc('1999');

    $lib_private = 1;

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'width', type => '1 <= int32 <= 1024',
          desc => 'The requested thumbnail width' },
        { name => 'height', type => '1 <= int32 <= 1024',
          desc => 'The requested thumbnail height' }
    );

    @outargs = (
        { name => 'actual_width', type => 'int32', void_ret => 1,
          desc => 'The previews width' },
        { name => 'actual_height', type => 'int32',
          desc => 'The previews height' },
        { name => 'bpp', type => 'int32',
          desc => 'The previews bpp' },
        { name => 'thumbnail_data', type => 'bytes',
          desc => 'The thumbnail data' }
    );

    %invoke = (
        code => <<'CODE'
{
  GimpTempBuf *buf;
  gint         dwidth, dheight;

  gimp_assert (GIMP_VIEWABLE_MAX_PREVIEW_SIZE >= 1024);

  /* Adjust the width/height ratio */
  dwidth  = gimp_image_get_width  (image);
  dheight = gimp_image_get_height (image);

  if (dwidth > dheight)
    height = MAX (1, (width * dheight) / dwidth);
  else
    width  = MAX (1, (height * dwidth) / dheight);

  gimp_pickable_flush (GIMP_PICKABLE (image));

  buf = gimp_viewable_get_new_preview (GIMP_VIEWABLE (image), context,
                                       width, height, NULL);

  if (buf)
    {
      actual_width         = gimp_temp_buf_get_width  (buf);
      actual_height        = gimp_temp_buf_get_height (buf);
      bpp                  = babl_format_get_bytes_per_pixel (gimp_temp_buf_get_format (buf));
      thumbnail_data       = g_bytes_new (gimp_temp_buf_get_data (buf),
                                          gimp_temp_buf_get_data_size (buf));

      gimp_temp_buf_unref (buf);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub image_policy_rotate {
    $blurb = 'Execute the "Orientation" metadata policy.';
    $help = <<'HELP';
Process the image according to the rotation policy as set in Preferences.
If GIMP is running as a GUI and interactive is TRUE, a dialog may be
presented to the user depending on the set policy. Otherwise, if the
policy does not mandate the action to perform, the image will be rotated
following the Orientation metadata.

If you wish absolutely to rotate a loaded image following the
Orientation metadata, do not use this function and process the metadata
yourself. Indeed even with `interactive` to FALSE, user settings may
leave the image unrotated.

Finally it is unnecessary to call this function in a format load
procedure because this is called automatically by the core code when
loading any image. You should only call this function explicitly when
loading an image through a PDB call.
HELP

    &jehan_pdb_misc('2020', '3.0');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'interactive', type => 'boolean',
          desc => 'Querying the user through a dialog is a possibility' }
    );

    %invoke = (
        code => <<'CODE'
{
  gimp_image_import_rotation_metadata (image, context, progress, interactive);
}
CODE
    );
}

sub image_policy_color_profile {
    $blurb = 'Execute the color profile conversion policy.';
    $help = <<'HELP';
Process the image according to the color profile policy as set in
Preferences.

If GIMP is running as a GUI and interactive is TRUE, a dialog may be
presented to the user depending on the policy. Otherwise, if the policy
does not mandate the conversion to perform, the conversion to the
preferred RGB or grayscale profile will happen, defaulting to built-in
profiles if no preferred profiles were set in `Preferences`.

This function should be used only if you want to follow user settings.
If you intend to convert to a specific profile, call preferably
gimp_image_convert_color_profile(). And if you wish to leave whatever
profile an image has, do not call any of these functions.

Finally it is unnecessary to call this function in a format load
procedure because this is called automatically by the core code when
loading any image. You should only call this function explicitly when
loading an image through a PDB call.
HELP

    &jehan_pdb_misc('2020', '3.0');

    @inargs = (
        { name => 'image', type => 'image',
          desc => 'The image' },
        { name => 'interactive', type => 'boolean',
          desc => 'Querying the user through a dialog is a possibility' }
    );

    %invoke = (
        code => <<'CODE'
{
  gimp_image_import_color_profile (image, context, progress, interactive);
}
CODE
    );
}

@headers = qw("libgimpmath/gimpmath.h"
              "libgimpbase/gimpbase.h"
              "gegl/gimp-babl.h"
              "core/gimp.h"
              "core/gimpcontainer.h"
              "core/gimpimage-color-profile.h"
              "core/gimpimage-metadata.h"
              "core/gimpimage-rotate.h"
              "core/gimpprogress.h"
              "core/gimptempbuf.h"
              "file/file-utils.h"
              "plug-in/gimpplugin.h"
              "plug-in/gimpplugin-cleanup.h"
              "plug-in/gimppluginmanager.h"
              "gimppdbcontext.h"
              "gimppdberror.h"
              "gimppdb-utils.h"
              "gimp-intl.h");

@procs = qw(image_id_is_valid
            get_images
            image_new image_new_with_precision
            image_duplicate image_delete
            image_get_base_type
            image_get_precision
            image_get_default_new_layer_mode
            image_get_width image_get_height
            image_get_layers
            image_get_channels
            image_get_paths
            image_unset_active_channel
            image_get_floating_sel
            image_floating_sel_attached_to
            image_pick_color
            image_pick_correlate_layer
            image_insert_layer image_remove_layer
            image_freeze_layers image_thaw_layers
            image_insert_channel image_remove_channel
            image_freeze_channels image_thaw_channels
            image_insert_path image_remove_path
            image_import_paths_from_file
            image_import_paths_from_string
            image_export_path_to_file
            image_export_path_to_string
            image_freeze_paths image_thaw_paths
            image_get_item_position
            image_raise_item image_lower_item
            image_raise_item_to_top image_lower_item_to_bottom
            image_reorder_item
            image_flatten image_merge_visible_layers image_merge_down
            image_get_palette image_set_palette
            image_get_metadata image_set_metadata
            image_clean_all image_is_dirty
            image_thumbnail
            image_get_selected_layers image_set_selected_layers
            image_get_selected_channels image_set_selected_channels
            image_get_selected_paths image_set_selected_paths
            image_get_selected_drawables
            image_get_selection
            image_get_component_active image_set_component_active
            image_get_component_visible image_set_component_visible
            image_get_file
            image_set_file
            image_get_xcf_file
            image_get_imported_file
            image_get_exported_file
            image_get_name
            image_get_resolution image_set_resolution
            image_get_unit image_set_unit
            image_get_tattoo_state image_set_tattoo_state
            image_get_layer_by_tattoo
            image_get_channel_by_tattoo
            image_get_path_by_tattoo
            image_get_layer_by_name
            image_get_channel_by_name
            image_get_path_by_name
            image_attach_parasite image_detach_parasite
            image_get_parasite
            image_get_parasite_list
            image_policy_rotate
            image_policy_color_profile);

%exports = (app => [@procs], lib => [@procs]);

$desc = 'Image';
$doc_title = 'gimpimage';
$doc_short_desc = 'Operations on complete images.';
$doc_long_desc = 'Operations on complete images: creation, resizing/rescaling, and operations involving multiple layers.';

1;
