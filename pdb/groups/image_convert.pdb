# LIGMA - The GNU Image Manipulation Program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# "Perlized" from C source by Manish Singh <yosh@ligma.org>

sub image_convert_rgb {
    $blurb = 'Convert specified image to RGB color';

    $help = <<'HELP';
This procedure converts the specified image to RGB color. This process
requires an image in Grayscale or Indexed color mode. No image content is
lost in this process aside from the colormap for an indexed image.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (ligma_pdb_image_is_not_base_type (image, LIGMA_RGB, error) &&
      ligma_babl_is_valid (LIGMA_RGB, ligma_image_get_precision (image)))
    {
      success = ligma_image_convert_type (image, LIGMA_RGB, NULL, NULL, error);
    }
  else
    {
      success = FALSE;
    }
}
CODE
    );
}

sub image_convert_grayscale {
    $blurb = 'Convert specified image to grayscale';

    $help = <<'HELP';
This procedure converts the specified image to grayscale. This process
requires an image in RGB or Indexed color mode.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (ligma_pdb_image_is_not_base_type (image, LIGMA_GRAY, error) &&
      ligma_babl_is_valid (LIGMA_GRAY, ligma_image_get_precision (image)))
    {
      success = ligma_image_convert_type (image, LIGMA_GRAY, NULL, NULL, error);
    }
  else
    {
      success = FALSE;
    }
}
CODE
    );
}

sub image_convert_indexed {
    $blurb = 'Convert specified image to and Indexed image';

    $help = <<'HELP';
This procedure converts the specified image to 'indexed' color. This
process requires an image in RGB or Grayscale mode. The 'palette_type'
specifies what kind of palette to use, A type of '0' means to use an
optimal palette of 'num_cols' generated from the colors in the
image. A type of '1' means to re-use the previous palette (not
currently implemented). A type of '2' means to use the so-called
WWW-optimized palette. Type '3' means to use only black and white
colors. A type of '4' means to use a palette from the ligma palettes
directories.  The 'dither type' specifies what kind of dithering to
use.  '0' means no dithering, '1' means standard Floyd-Steinberg error
diffusion, '2' means Floyd-Steinberg error diffusion with reduced
bleeding, '3' means dithering based on pixel location ('Fixed'
dithering).
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'dither_type', type => 'enum LigmaConvertDitherType',
	  desc => 'The dither type to use' },
	{ name => 'palette_type', type => 'enum LigmaConvertPaletteType',
	  desc => 'The type of palette to use' },
	{ name => 'num_cols', type => 'int32',
	  desc => 'The number of colors to quantize to, ignored unless
		   (palette_type == LIGMA_CONVERT_PALETTE_GENERATE)' },
	{ name => 'alpha_dither', type => 'boolean',
	  desc => 'Dither transparency to fake partial opacity' },
	{ name => 'remove_unused', type => 'boolean',
	  desc => 'Remove unused or duplicate color entries from final
		   palette, ignored if (palette_type ==
		   LIGMA_CONVERT_PALETTE_GENERATE)' },
	{ name => 'palette', type => 'string',
	  desc => 'The name of the custom palette to use, ignored unless
		   (palette_type == LIGMA_CONVERT_PALETTE_CUSTOM)' }
    );

    %invoke = (
	code => <<'CODE'
{
  LigmaPalette *pal = NULL;

  if (ligma_pdb_image_is_not_base_type (image, LIGMA_INDEXED, error)             &&
      ligma_pdb_image_is_precision (image, LIGMA_PRECISION_U8_NON_LINEAR, error) &&
      ligma_babl_is_valid (LIGMA_INDEXED, ligma_image_get_precision (image))      &&
      ligma_item_stack_is_flat (LIGMA_ITEM_STACK (ligma_image_get_layers (image))))
    {
      switch (palette_type)
	{
	case LIGMA_CONVERT_PALETTE_GENERATE:
	  if (num_cols < 1 || num_cols > MAXNUMCOLORS)
	    success = FALSE;
	  break;

	case LIGMA_CONVERT_PALETTE_CUSTOM:
          pal = ligma_pdb_get_palette (ligma, palette, FALSE, error);
	  if (! pal)
            {
              success = FALSE;
            }
          else if (pal->n_colors > MAXNUMCOLORS)
            {
              g_set_error_literal (error,
	                           LIGMA_PDB_ERROR,
                                   LIGMA_PDB_ERROR_INVALID_ARGUMENT,
                                   _("Cannot convert to a palette "
                                     "with more than 256 colors."));
              success = FALSE;
            }
          break;

	default:
          break;
	}
    }
  else
    {
      success = FALSE;
    }

  if (success)
    success = ligma_image_convert_indexed (image,
                                          palette_type, num_cols, remove_unused,
                                          dither_type, alpha_dither, FALSE,
                                          pal,
                                          NULL, error);
}
CODE
    );
}

sub image_convert_set_dither_matrix {
    $blurb = 'Set dither matrix for conversion to indexed';

    $help = <<'HELP';
This procedure sets the dither matrix used when converting images to INDEXED mode with 
positional dithering. 
HELP

    &david_pdb_misc('2006', '2.4');

    @inargs = (
	{ name => 'width', type => 'int32',
	  desc => 'Width of the matrix (0 to reset to default matrix)' },
	{ name => 'height', type => 'int32',
	  desc => 'Height of the matrix (0 to reset to default matrix)' },
	{ name => 'matrix', type => 'int8array',
	  desc => 'The matrix -- all values must be >= 1',
	  array => { name => 'matrix_length', type => '1 <= int32 <= 1024',
                     desc => "The length of 'matrix'" }
	  },
    );

    %invoke = (
	code => <<'CODE'
{
  if (width == 0 || height == 0 || matrix_length == width * height)
    {
      ligma_image_convert_indexed_set_dither_matrix (matrix, width, height);
    }
  else
    {
      g_set_error_literal (error, LIGMA_PDB_ERROR,
                           LIGMA_PDB_ERROR_INVALID_ARGUMENT,
                           "Dither matrix length must be width * height");
      success = FALSE;
    }
}
CODE
    );
}

sub image_convert_precision {
    $blurb = 'Convert the image to the specified precision';

    $help = <<'HELP';
This procedure converts the image to the specified precision. Note
that indexed images cannot be converted and are always in
LIGMA_PRECISION_U8.
HELP

    &mitch_pdb_misc('2012', '2.10');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'precision', type => 'enum LigmaPrecision',
	  desc => 'The new precision' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (ligma_pdb_image_is_not_base_type (image, LIGMA_INDEXED, error) &&
      ligma_pdb_image_is_not_precision (image, precision, error)    &&
      ligma_babl_is_valid (ligma_image_get_base_type (image), precision))
    {
      ligma_image_convert_precision (image, precision,
                                    GEGL_DITHER_NONE,
                                    GEGL_DITHER_NONE,
                                    GEGL_DITHER_NONE,
                                    progress);
    }
  else
    {
      success = FALSE;
    }
}
CODE
    );
}

@headers = qw("gegl/ligma-babl.h"
              "core/ligma.h"
              "core/ligmaimage.h"
              "core/ligmaimage-convert-indexed.h"
              "core/ligmaimage-convert-precision.h"
              "core/ligmaimage-convert-type.h"
              "core/ligmaitemstack.h"
              "core/ligmapalette.h"
              "ligmapdberror.h"
              "ligmapdb-utils.h"
              "ligma-intl.h");

@procs = qw(image_convert_rgb
            image_convert_grayscale
            image_convert_indexed
            image_convert_set_dither_matrix
            image_convert_precision);

%exports = (app => [@procs], lib => [@procs]);

$desc = 'Image Convert';
$doc_title = 'ligmaimageconvert';
$doc_short_desc = 'Conversions between RGB, indexed, and grayscale modes.';
$doc_long_desc = 'Conversions between RGB, indexed, and grayscale modes.';

1;
