headers
#include <Python.h>

#define NO_IMPORT_PYGOBJECT
#include <pygobject.h>

#include <pycairo.h>
extern Pycairo_CAPI_t *Pycairo_CAPI;

#define GIMP_DISABLE_DEPRECATION_WARNINGS
#include <libgimp/gimp.h>
#undef GIMP_DISABLE_DEPRECATED
#include <libgimp/gimpui.h>
#define GIMP_DISABLE_DEPRECATED

#define NO_IMPORT_PYGIMP
#include "pygimp-api.h"

#define NO_IMPORT_PYGIMPCOLOR
#include "pygimpcolor-api.h"

typedef struct {
    PyObject *constraint;
    PyObject *user_data;
} PyGimpConstraintData;

typedef struct {
    PyObject *sensitivity_func;
    PyObject *user_data;
} PyGimpIntSensitivityData;

/* TODO: Add a header for these */
void gimpui_register_classes(PyObject *d);
void gimpui_add_constants(PyObject *module, const gchar *strip_prefix);

static void
pygimp_decref_callback(PyObject* obj) {
    Py_XDECREF (obj);
}

%%
modulename gimpui
%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gtk.Object as PyGtkObject_Type
import gtk.Widget as PyGtkWidget_Type
import gtk.Dialog as PyGtkDialog_Type
import gtk.Window as PyGtkWindow_Type
import gtk.Label as PyGtkLabel_Type
import gtk.Button as PyGtkButton_Type
import gtk.ToggleButton as PyGtkToggleButton_Type
import gtk.RadioButton as PyGtkRadioButton_Type
import gtk.SpinButton as PyGtkSpinButton_Type
import gtk.Entry as PyGtkEntry_Type
import gtk.DrawingArea as PyGtkDrawingArea_Type
import gtk.Grid as PyGtkGrid_Type
import gtk.Frame as PyGtkFrame_Type
import gtk.HBox as PyGtkHBox_Type
import gtk.VBox as PyGtkVBox_Type
import gtk.HPaned as PyGtkHPaned_Type
import gtk.VPaned as PyGtkVPaned_Type
import gtk.Scale as PyGtkScale_Type
import gtk.ProgressBar as PyGtkProgressBar_Type
import gtk.OptionMenu as PyGtkOptionMenu_Type
import gtk.ComboBox as PyGtkComboBox_Type
import gtk.ListStore as PyGtkListStore_Type
import gtk.TreeModel as PyGtkTreeModel_Type
import gtk.CellRenderer as PyGtkCellRenderer_Type
import gtk.CellRendererToggle as PyGtkCellRendererToggle_Type
import gimp.Parasite as PyGimpParasite_Type
%%
ignore
  gimp_dialog_add_buttons
  gimp_int_combo_box_connect
  gimp_color_profile_combo_box_new
  gimp_enum_store_new_with_values
  gimp_int_combo_box_new_array
%%
ignore-glob
  *_get_type
  *_valist
  gimp_resolution_*
%%
ignore-type
  GimpIntStoreColumns 
%%
override gimp_drawable_combo_box_new kwargs
static gboolean
pygimp_drawable_constraint_marshal(gint32 image_id, gint32 drawable_id,
                                   gpointer user_data)
{
    PyObject *img, *drw, *ret;
    gboolean res;
    PyGimpConstraintData *data = user_data;

    img = pygimp_image_new(image_id);
    if (!img) {
        PyErr_Print();
        return FALSE;
    }

    drw = pygimp_drawable_new(NULL, drawable_id);
    if (!drw) {
        PyErr_Print();
        Py_DECREF(img);
        return FALSE;
    }

    if (data->user_data && data->user_data != Py_None)
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, drw,
                                           data->user_data, NULL);
    else
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, drw, NULL);

    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }

    Py_DECREF(drw);
    Py_DECREF(img);

    return res;
}

static int
_wrap_gimp_drawable_combo_box_new(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    PyObject *constraint = NULL, *user_data = NULL;
    GimpDrawableConstraintFunc func = NULL;
    PyGimpConstraintData *data = NULL;

    static char *kwlist[] = { "constraint", "data", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:gimpui.DrawableComboBox.__init__",
                                     kwlist,
                                     &constraint, &user_data))
        return -1;

    if (constraint && constraint != Py_None) {
        if (!PyCallable_Check(constraint)) {
            PyErr_SetString(PyExc_TypeError, "first arg must be callable");
            return -1;
        }

        data = g_new(PyGimpConstraintData, 1);

        data->constraint = constraint;
        Py_XINCREF(constraint);

        data->user_data = user_data;
        Py_XINCREF(user_data);

        func = pygimp_drawable_constraint_marshal;
    }

    self->obj = (GObject *)gimp_drawable_combo_box_new(func, data);

    Py_XDECREF(constraint);
    Py_XDECREF(user_data);
    g_free(data);

    if (pyg_type_from_object((PyObject *)self) != GIMP_TYPE_DRAWABLE_COMBO_BOX) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing gimpui.DrawableComboBox");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
define GimpDrawableComboBox.set_active_drawable kwargs
static PyObject *
_wrap_gimp_drawable_combo_box_set_active_drawable(PyGObject *self, PyObject *args,
                                                  PyObject *kwargs)
{
    PyGimpDrawable *drw;

    static char *kwlist[] = { "drawable", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "O!:GimpDrawableComboBox.set_active_drawable",
                                     kwlist,
                                     PyGimpDrawable_Type, &drw))
        return NULL;

    if (!gimp_int_combo_box_set_active(GIMP_INT_COMBO_BOX(self->obj), drw->ID)) {
        PyErr_Format(pygimp_error,
                     "Drawable (ID %d) does not exist in GimpDrawableComboBox",
                     drw->ID);
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define GimpDrawableComboBox.get_active_drawable noargs
static PyObject *
_wrap_gimp_drawable_combo_box_get_active_drawable(PyGObject *self)
{
    int value;

    if (gimp_int_combo_box_get_active(GIMP_INT_COMBO_BOX(self->obj), &value))
        return pygimp_drawable_new(NULL, value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_channel_combo_box_new kwargs
static gboolean
pygimp_channel_constraint_marshal(gint32 image_id, gint32 channel_id,
                                  gpointer user_data)
{
    PyObject *img, *chn, *ret;
    gboolean res;
    PyGimpConstraintData *data = user_data;

    img = pygimp_image_new(image_id);
    if (!img) {
        PyErr_Print();
        return FALSE;
    }

    chn = pygimp_channel_new(channel_id);
    if (!chn) {
        PyErr_Print();
        Py_DECREF(img);
        return FALSE;
    }

    if (data->user_data && data->user_data != Py_None)
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, chn,
                                           data->user_data, NULL);
    else
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, chn, NULL);

    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }

    Py_DECREF(chn);
    Py_DECREF(img);

    return res;
}

static int
_wrap_gimp_channel_combo_box_new(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    PyObject *constraint = NULL, *user_data = NULL;
    GimpDrawableConstraintFunc func = NULL;
    PyGimpConstraintData *data = NULL;

    static char *kwlist[] = { "constraint", "data", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:gimpui.ChannelComboBox.__init__",
                                     kwlist,
                                     &constraint, &user_data))
        return -1;

    if (constraint && constraint != Py_None) {
        if (!PyCallable_Check(constraint)) {
            PyErr_SetString(PyExc_TypeError, "first arg must be callable");
            return -1;
        }

        data = g_new(PyGimpConstraintData, 1);

        data->constraint = constraint;
        Py_INCREF(constraint);

        data->user_data = user_data;
        Py_XINCREF(user_data);

        func = pygimp_channel_constraint_marshal;
    }

    self->obj = (GObject *)gimp_channel_combo_box_new(func, data);

    Py_XDECREF(constraint);
    Py_XDECREF(user_data);
    g_free(data);

    if (pyg_type_from_object((PyObject *)self) != GIMP_TYPE_CHANNEL_COMBO_BOX) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing gimpui.ChannelComboBox");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
define GimpChannelComboBox.set_active_channel kwargs
static PyObject *
_wrap_gimp_channel_combo_box_set_active_channel(PyGObject *self, PyObject *args,
                                                PyObject *kwargs)
{
    PyGimpChannel *chn;

    static char *kwlist[] = { "channel", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                    "O!:GimpChannelComboBox.set_active_channel",
                                    kwlist,
                                    PyGimpChannel_Type, &chn))
        return NULL;

    if (!gimp_int_combo_box_set_active(GIMP_INT_COMBO_BOX(self->obj), chn->ID)) {
        PyErr_Format(pygimp_error,
                     "Channel (ID %d) does not exist in GimpChannelComboBox",
                     chn->ID);
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define GimpChannelComboBox.get_active_channel noargs
static PyObject *
_wrap_gimp_channel_combo_box_get_active_channel(PyGObject *self)
{
    int value;

    if (gimp_int_combo_box_get_active(GIMP_INT_COMBO_BOX(self->obj), &value))
        return pygimp_channel_new(value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_layer_combo_box_new kwargs
static gboolean
pygimp_layer_constraint_marshal(gint32 image_id, gint32 layer_id,
                                gpointer user_data)
{
    PyObject *img, *lay, *ret;
    gboolean res;
    PyGimpConstraintData *data = user_data;

    img = pygimp_image_new(image_id);
    if (!img) {
        PyErr_Print();
        return FALSE;
    }

    lay = pygimp_layer_new(layer_id);
    if (!lay) {
        PyErr_Print();
        Py_DECREF(img);
        return FALSE;
    }

    if (data->user_data && data->user_data != Py_None)
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, lay,
                                           data->user_data, NULL);
    else
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, lay, NULL);

    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }

    Py_DECREF(lay);
    Py_DECREF(img);

    return res;
}

static int
_wrap_gimp_layer_combo_box_new(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    PyObject *constraint = NULL, *user_data = NULL;
    GimpDrawableConstraintFunc func = NULL;
    PyGimpConstraintData *data = NULL;

    static char *kwlist[] = { "constraint", "data", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:gimpui.LayerComboBox.__init__",
                                     kwlist,
                                     &constraint, &user_data))
        return -1;

    if (constraint && constraint != Py_None) {
        if (!PyCallable_Check(constraint)) {
            PyErr_SetString(PyExc_TypeError, "first arg must be callable");
            return -1;
        }

        data = g_new(PyGimpConstraintData, 1);

        data->constraint = constraint;
        Py_INCREF(constraint);

        data->user_data = user_data;
        Py_XINCREF(user_data);

        func = pygimp_layer_constraint_marshal;
    }

    self->obj = (GObject *)gimp_layer_combo_box_new(func, data);

    Py_XDECREF(constraint);
    Py_XDECREF(user_data);
    g_free(data);

    if (pyg_type_from_object((PyObject *)self) != GIMP_TYPE_LAYER_COMBO_BOX) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing gimpui.LayerComboBox");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
define GimpLayerComboBox.set_active_layer kwargs
static PyObject *
_wrap_gimp_layer_combo_box_set_active_layer(PyGObject *self, PyObject *args,
                                            PyObject *kwargs)
{
    PyGimpLayer *lay;

    static char *kwlist[] = { "layer", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "O!:GimpLayerComboBox.set_active_layer",
                                     kwlist,
                                     PyGimpLayer_Type, &lay))
        return NULL;

    if (!gimp_int_combo_box_set_active(GIMP_INT_COMBO_BOX(self->obj), lay->ID)) {
        PyErr_Format(pygimp_error,
                     "Layer (ID %d) does not exist in GimpLayerComboBox",
                     lay->ID);
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define GimpLayerComboBox.get_active_layer noargs
static PyObject *
_wrap_gimp_layer_combo_box_get_active_layer(PyGObject *self)
{
    int value;

    if (gimp_int_combo_box_get_active(GIMP_INT_COMBO_BOX(self->obj), &value))
        return pygimp_layer_new(value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_vectors_combo_box_new kwargs
static gboolean
pygimp_vectors_constraint_marshal(gint32 image_id, gint32 vectors_id,
                                  gpointer user_data)
{
    PyObject *img, *vect, *ret;
    gboolean res;
    PyGimpConstraintData *data = user_data;

    img = pygimp_image_new(image_id);
    if (!img) {
        PyErr_Print();
        return FALSE;
    }

    vect = pygimp_vectors_new(vectors_id);
    if (!vect) {
        PyErr_Print();
        Py_DECREF(img);
        return FALSE;
    }

    if (data->user_data && data->user_data != Py_None)
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, vect,
                                           data->user_data, NULL);
    else
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, vect, NULL);

    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }

    Py_DECREF(vect);
    Py_DECREF(img);

    return res;
}

static int
_wrap_gimp_vectors_combo_box_new(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    PyObject *constraint = NULL, *user_data = NULL;
    GimpVectorsConstraintFunc func = NULL;
    PyGimpConstraintData *data = NULL;

    static char *kwlist[] = { "constraint", "data", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:gimpui.VectorsComboBox.__init__",
                                     kwlist,
                                     &constraint, &user_data))
        return -1;

    if (constraint && constraint != Py_None) {
        if (!PyCallable_Check(constraint)) {
            PyErr_SetString(PyExc_TypeError, "first arg must be callable");
            return -1;
        }

        data = g_new(PyGimpConstraintData, 1);

        data->constraint = constraint;
        Py_INCREF(constraint);

        data->user_data = user_data;
        Py_XINCREF(user_data);

        func = pygimp_vectors_constraint_marshal;
    }

    self->obj = (GObject *)gimp_vectors_combo_box_new(func, data);

    Py_XDECREF(constraint);
    Py_XDECREF(user_data);
    g_free(data);

    if (pyg_type_from_object((PyObject *)self) != GIMP_TYPE_VECTORS_COMBO_BOX) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing gimpui.VectorsComboBox");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
define GimpVectorsComboBox.set_active_vectors kwargs
static PyObject *
_wrap_gimp_vectors_combo_box_set_active_vectors(PyGObject *self, PyObject *args,
                                                PyObject *kwargs)
{
    PyGimpVectors *vect;

    static char *kwlist[] = { "vectors", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                   "O!:GimpVectorsComboBox.set_active_vectors",
                                   kwlist,
                                   PyGimpVectors_Type, &vect))
        return NULL;

    if (!gimp_int_combo_box_set_active(GIMP_INT_COMBO_BOX(self->obj), vect->ID)) {
        PyErr_Format(pygimp_error,
                     "Vectors (ID %d) does not exist in GimpVectorsComboBox",
                     vect->ID);
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define GimpVectorsComboBox.get_active_vectors noargs
static PyObject *
_wrap_gimp_vectors_combo_box_get_active_vectors(PyGObject *self)
{
    int value;

    if (gimp_int_combo_box_get_active(GIMP_INT_COMBO_BOX(self->obj), &value))
        return pygimp_vectors_new(value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_image_combo_box_new kwargs
static gboolean
pygimp_image_constraint_marshal(gint32 image_id, gpointer user_data)
{
    PyObject *img, *ret;
    gboolean res;
    PyGimpConstraintData *data = user_data;

    img = pygimp_image_new(image_id);
    if (!img) {
        PyErr_Print();
        return FALSE;
    }

    if (data->user_data && data->user_data != Py_None)
        ret = PyObject_CallFunctionObjArgs(data->constraint, img,
                                           data->user_data, NULL);
    else
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, NULL);

    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }

    Py_DECREF(img);

    return res;
}

static int
_wrap_gimp_image_combo_box_new(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    PyObject *constraint = NULL, *user_data = NULL;
    GimpImageConstraintFunc func = NULL;
    PyGimpConstraintData *data = NULL;

    static char *kwlist[] = { "constraint", "data", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:gimpui.ImageComboBox.__init__",
                                     kwlist,
                                     &constraint, &user_data))
        return -1;

    if (constraint && constraint != Py_None) {
        if (!PyCallable_Check(constraint)) {
            PyErr_SetString(PyExc_TypeError, "first arg must be callable");
            return -1;
        }

        data = g_new(PyGimpConstraintData, 1);

        data->constraint = constraint;
        Py_INCREF(constraint);

        data->user_data = user_data;
        Py_XINCREF(user_data);

        func = pygimp_image_constraint_marshal;
    }

    self->obj = (GObject *)gimp_image_combo_box_new(func, data);

    Py_XDECREF(constraint);
    Py_XDECREF(user_data);
    g_free(data);

    if (pyg_type_from_object((PyObject *)self) != GIMP_TYPE_IMAGE_COMBO_BOX) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing gimpui.ImageComboBox");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
define GimpImageComboBox.set_active_image kwargs
static PyObject *
_wrap_gimp_image_combo_box_set_active_image(PyGObject *self, PyObject *args,
                                            PyObject *kwargs)
{
    PyGimpImage *img;

    static char *kwlist[] = { "image", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "O!:GimpImageComboBox.set_active_image",
                                     kwlist,
                                     PyGimpImage_Type, &img))
        return NULL;

    if (!gimp_int_combo_box_set_active(GIMP_INT_COMBO_BOX(self->obj), img->ID)) {
        PyErr_Format(pygimp_error,
                     "Image (ID %d) does not exist in GimpImageComboBox",
                     img->ID);
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define GimpImageComboBox.get_active_image noargs
static PyObject *
_wrap_gimp_image_combo_box_get_active_image(PyGObject *self)
{
    int value;

    if (gimp_int_combo_box_get_active(GIMP_INT_COMBO_BOX(self->obj), &value))
        return pygimp_image_new(value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_dialog_new kwargs
static void
pygimp_help_func_marshal(const gchar *help_id, gpointer help_data)
{
    GObject *dialog = help_data;
    PyObject *py_dialog, *help_func, *ret;

    py_dialog = g_object_get_data(dialog, "pygimp-dialog-pyobject");
    help_func = g_object_get_data(dialog, "pygimp-dialog-help_func");

    ret = PyObject_CallFunction(help_func, "sO", help_id, py_dialog);

    if (ret)
        Py_DECREF(ret);
    else
        PyErr_Print();
}

static void
pygimp_help_func_destroy(gpointer data)
{
    PyObject *help_func = data;

    Py_DECREF(help_func);
}

static void
pygimp_dialog_close(GtkWidget *widget)
{
    /* Synthesize delete_event to close dialog. */

    if (gtk_widget_get_window (widget)) {
        GdkEvent *event = gdk_event_new(GDK_DELETE);

        event->any.window     = g_object_ref (gtk_widget_get_window (widget));
        event->any.send_event = TRUE;

        gtk_main_do_event(event);
        gdk_event_free(event);
    }
}

static int
_wrap_gimp_dialog_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    gchar *title, *role;
    PyGObject *py_window = NULL;
    PyObject *py_flags = NULL, *py_buttons = Py_None;
    PyObject *help_func = NULL;
    gchar *help_id = NULL;
    GtkDialogFlags flags = 0;
    int len, i;
    GtkWidget *parent;
    GimpHelpFunc func;

    static char *kwlist[] = { "title", "role", "parent", "flags",
                              "help_func", "help_id", "buttons", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zz|OOOzO:gimpui.GimpDialog.__init__",
                                     kwlist,
                                     &title, &role, &py_window, &py_flags,
                                     &help_func, &help_id, &py_buttons))
        return -1;

    if (py_window == NULL || (PyObject*)py_window == Py_None)
        parent = NULL;
    else if (pygobject_check(py_window, &PyGtkWindow_Type))
        parent = GTK_WIDGET(py_window->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "parent must be a GtkWindow or None");
        return -1;
    }

    if (pyg_flags_get_value(GTK_TYPE_DIALOG_FLAGS, py_flags, (gint *)&flags))
        return -1;

    if (py_buttons == Py_None)
        len = 0;
    else if (PyTuple_Check(py_buttons))
        len = PyTuple_Size(py_buttons);
    else {
        PyErr_SetString(PyExc_TypeError, "buttons must be a tuple containing text/response pairs or None");
        return -1;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "buttons tuple must contain text/response id pairs");
        return -1;
    }

    if (help_func) {
        if (help_func != Py_None) {
            if (!PyCallable_Check(help_func)) {
                PyErr_SetString(PyExc_TypeError, "help_func must be callable");
                return -1;
            }

            func = pygimp_help_func_marshal;

       } else {
            func = gimp_standard_help_func;
        }
    } else {
        func = gimp_standard_help_func;
    }

    pygobject_construct(self,
                        "title",     title,
                        "role",      role,
                        "modal",     (flags & GTK_DIALOG_MODAL),
                        "help-func", func,
                        "help-id",   help_id,
                        NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GimpDialog object");
        return -1;
    }

   if (parent) {
        if (GTK_IS_WINDOW(parent))
            gtk_window_set_transient_for(GTK_WINDOW(self->obj),
                                         GTK_WINDOW(parent));
        else
            gtk_window_set_screen(GTK_WINDOW(self->obj),
                                  gtk_widget_get_screen(parent));

        if (flags & GTK_DIALOG_DESTROY_WITH_PARENT)
            g_signal_connect_object(parent, "destroy",
                                    G_CALLBACK(pygimp_dialog_close),
                                    self->obj, G_CONNECT_SWAPPED);
    }

    for (i = 0; i < len; i += 2) {
        PyObject *text = PyTuple_GetItem(py_buttons, i);
        PyObject *id = PyTuple_GetItem(py_buttons, i + 1);
        if (!PyString_Check(text) && !PyUnicode_Check(text)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each text/response id pair "
                            "must be a string");
            return -1;
        }
        if (!PyInt_Check(id)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each text/response id pair "
                            "must be a number");
            return -1;
        }

        gimp_dialog_add_button(GIMP_DIALOG(self->obj), PyString_AsString(text),
                               PyInt_AsLong(id));
    }

    if (help_func && help_func != Py_None) {
        g_object_set_data(self->obj, "pygimp-dialog-help-data", self);

        Py_INCREF(help_func);
        g_object_set_data_full(self->obj, "pygimp-dialog-help-func",
                               help_func, pygimp_help_func_destroy);
    }

    return 0;
}
%%
new-constructor GIMP_TYPE_DIALOG
%%
override gimp_color_button_get_color noargs
static PyObject *
_wrap_gimp_color_button_get_color(PyGObject *self)
{
    GimpRGB rgb;

    gimp_color_button_get_color(GIMP_COLOR_BUTTON(self->obj), &rgb);

    return pygimp_rgb_new(&rgb);
}
%%
override gimp_brush_select_button_get_brush noargs
static PyObject *
_wrap_gimp_brush_select_button_get_brush(PyGObject *self)
{
    const gchar *brush_name;
    gdouble opacity;
    gint spacing;
    GimpLayerMode paint_mode;

    brush_name =
        gimp_brush_select_button_get_brush(GIMP_BRUSH_SELECT_BUTTON(self->obj),
                                           &opacity, &spacing, &paint_mode);

    return Py_BuildValue("(sdiN)", brush_name, opacity, spacing,
                         pyg_enum_from_gtype(GIMP_TYPE_LAYER_MODE,
                                             paint_mode));
}
%%
override gimp_window_set_transient
static PyObject *
_wrap_gimp_window_set_transient(PyGObject *self)
{
    gimp_window_set_transient(GTK_WINDOW(self->obj));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_color_button_new kwargs
static int
_wrap_gimp_color_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    gchar *title = NULL;
    gint width = -1, height = -1;
    PyObject *py_color = NULL, *py_type = NULL;
    GimpRGB *color, default_color = { 0.0, 0.0, 0.0, 100.0 };
    GimpColorAreaType type;
    
    static char *kwlist[] = { "title", "width", "height", "color", "type",
                              NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|ziiOO:gimpui.ColorButton.__init__",
                                     kwlist,
                                     &title, &width, &height,
                                     &py_color, &py_type))
        return -1;

    if (py_color == NULL || (PyObject*)py_color == Py_None)
        color = &default_color;
    else if (pyg_boxed_check(py_color, GIMP_TYPE_RGB))
        color = pyg_boxed_get(py_color, GimpRGB);
    else {
        PyErr_SetString(PyExc_TypeError, "color should be a GimpRGB or None");
        return -1;
    }

    if (py_type == NULL || (PyObject*)py_type == Py_None)
       type = GIMP_COLOR_AREA_FLAT;
    else if (pyg_enum_get_value(GIMP_TYPE_COLOR_AREA_TYPE, py_type,
                                (gint*)&type))
       return -1;

    if (pygobject_construct(self,
                            "title",       title,
                            "type",        type,
                            "color",       color,
                            "area-width",  width,
			    "area-height", height,
                            NULL))
        return -1;

    return 0;
}
%%
new-constructor GIMP_TYPE_COLOR_BUTTON
%%
override gimp_color_scale_new kwargs
static int
_wrap_gimp_color_scale_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_orientation, *py_channel;
    GtkOrientation orientation;
    GimpColorSelectorChannel channel;

    static char *kwlist[] = { "orientation", "channel", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO:gimpui.ColorScale.__init__",
                                     kwlist,
                                     &py_orientation, &py_channel))
        return -1;

    if (pyg_enum_get_value(GTK_TYPE_ORIENTATION, py_orientation,
                           (gint*)&orientation))
        return -1;

    if (pyg_enum_get_value(GIMP_TYPE_COLOR_SELECTOR_CHANNEL, py_channel, 
                           (gint*)&channel))
        return -1;

    if (pygobject_construct(self,
                            "orientation", orientation,
                            "channel",     channel,
                            NULL))
        return -1;

    gtk_range_set_flippable (GTK_RANGE (self->obj),
                             orientation == GTK_ORIENTATION_HORIZONTAL);
    
    return 0;
}
%%
new-constructor GIMP_TYPE_COLOR_SCALE
%%
override gimp_enum_label_new kwargs
static int
_wrap_gimp_enum_label_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_enum_type = NULL;
    GType enum_type;
    gint value;

    static char *kwlist[] = { "enum_type", "value", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oi:gimpui.GimpEnumLabel.__init__",
                                     kwlist,
                                     &py_enum_type, &value))
        return -1;

    if ((enum_type = pyg_type_from_object(py_enum_type)) == 0)
        return -1;

    if (pygobject_construct(self,
                            "enum-type",  enum_type,
                            "enum-value", value,
                            NULL))
        return -1;

    return 0; 
}
%%
new-constructor GIMP_TYPE_ENUM_LABEL
%%
override gimp_int_combo_box_new kwargs
static int
_wrap_gimp_int_combo_box_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_items = NULL;
    int len, i;

    static char *kwlist[] = { "items", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|O:gimpui.IntComboBox.__init__",
                                     kwlist,
                                     &py_items))
        return -1; 

    if (py_items == NULL || py_items == Py_None)
        len = 0;
    else if (PyTuple_Check(py_items))
        len = PyTuple_Size(py_items);
    else {
        PyErr_SetString(PyExc_TypeError,
                        "items must be a tuple containing label/value pairs "
                        "or None");
        return -1;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "items tuple must contain label/value pairs");
        return -1;
    }

    if (pygobject_construct(self, NULL))
        return -1;

    for (i = 0; i < len; i += 2) {
        PyObject *label = PyTuple_GetItem(py_items, i);
        PyObject *value = PyTuple_GetItem(py_items, i + 1);

        if (!PyString_Check(label)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each label/value pair "
                            "must be a string");
            return -1;
        }

        if (!PyInt_Check(value)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each label/value pair "
                            "must be a number");
            return -1;
        }

        gimp_int_combo_box_append(GIMP_INT_COMBO_BOX(self->obj),
                                  GIMP_INT_STORE_LABEL,
                                  PyString_AsString(label),
                                  GIMP_INT_STORE_VALUE,
                                  PyInt_AsLong(value),
                                  -1);
    }

    return 0;
}
%%
new-constructor GIMP_TYPE_INT_COMBO_BOX
%%
override gimp_int_combo_box_set_sensitivity kwargs
static gboolean
pygimp_int_combo_box_sensitivity_marshal(gint value, gpointer user_data)
{
    PyObject *py_value;
    PyGimpIntSensitivityData *data;
    PyObject *ret;
    gboolean res;

    data = user_data;

    py_value = PyInt_FromLong(value);

    ret = PyObject_CallFunctionObjArgs(data->sensitivity_func, py_value,
                                       data->user_data, NULL);
    
    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }

    Py_DECREF(py_value);

    return res;
}

static void
pygimp_int_combo_box_sensitivity_data_destroy(gpointer user_data)
{
    PyGimpIntSensitivityData *data;
    data = user_data;

    Py_DECREF(data->sensitivity_func);
    Py_XDECREF(data->user_data);

    g_free(data);
}

static PyObject *
_wrap_gimp_int_combo_box_set_sensitivity(PyGObject *self, PyObject *args,
                                         PyObject *kwargs)
{
    PyObject *py_sensitivity_func;
    PyObject *py_user_data = NULL;
    PyGimpIntSensitivityData *data;

    static char *kwlist[] = { "sensitivity_func", "user_data", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "O|O:GimpIntComboBox.set_sensitivity",
                                     kwlist, &py_sensitivity_func,
                                     &py_user_data))
        return NULL;

    if (!PyCallable_Check(py_sensitivity_func)) {
        PyErr_SetString(PyExc_TypeError, "first argument must be callable.");
        return NULL;
    }

    data = g_new(PyGimpIntSensitivityData, 1);

    data->sensitivity_func = py_sensitivity_func;
    Py_INCREF(data->sensitivity_func);
    
   if (py_user_data == NULL || py_user_data == Py_None)
        data->user_data = NULL;
    else {
       data->user_data = py_user_data;
       Py_INCREF(data->user_data);
    }

    gimp_int_combo_box_set_sensitivity(GIMP_INT_COMBO_BOX(self->obj),
                                pygimp_int_combo_box_sensitivity_marshal,
                                data,
                                pygimp_int_combo_box_sensitivity_data_destroy);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_int_combo_box_get_active noargs
static PyObject *
_wrap_gimp_int_combo_box_get_active(PyGObject *self)
{
    int value;

    if (gimp_int_combo_box_get_active(GIMP_INT_COMBO_BOX(self->obj), &value))
        return PyLong_FromLong(value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_int_combo_box_set_active kwargs
static PyObject *
_wrap_gimp_int_combo_box_set_active(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    int value;

    static char *kwlist[] = { "value", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "i:GimpIntComboBox.set_active", kwlist,
                                     &value))
        return NULL;

    if (!gimp_int_combo_box_set_active(GIMP_INT_COMBO_BOX(self->obj), value)) {
        PyErr_Format(pygimp_error,
                     "Value %d does not exist in GimpIntComboBox",
                     value);
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_int_combo_box_append kwargs
static PyObject *
_wrap_gimp_int_combo_box_append(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    PyObject *py_items;
    int i, len;

    static char *kwlist[] = { "items", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:gimpui.IntComboBox.append",
                                     kwlist,
                                     &py_items))
        return NULL; 

    if (py_items == NULL || py_items == Py_None)
        len = 0;
    else if (PyTuple_Check(py_items))
        len = PyTuple_Size(py_items);
    else {
        PyErr_SetString(PyExc_TypeError,
                        "items must be a tuple containing label/value pairs "
                        "or None");
        return NULL;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "items tuple must contain label/value pairs");
        return NULL;
    }

    for (i = 0; i < len; i += 2) {
        PyObject *label = PyTuple_GetItem(py_items, i);
        PyObject *value = PyTuple_GetItem(py_items, i + 1);

        if (!PyString_Check(label)) {
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each label/value pair "
                            "must be a string");
            return NULL;
        }

        if (!PyInt_Check(value)) {
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each label/value pair "
                            "must be a number");
            return NULL;
        }

        gimp_int_combo_box_append(GIMP_INT_COMBO_BOX(self->obj),
                                  GIMP_INT_STORE_LABEL,
                                  PyString_AsString(label),
                                  GIMP_INT_STORE_VALUE,
                                  PyInt_AsLong(value),
                                  -1);
    }
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_int_combo_box_prepend kwargs
static PyObject *
_wrap_gimp_int_combo_box_prepend(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    PyObject *py_items;
    int i, len;

    static char *kwlist[] = { "items", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:gimpui.IntComboBox.prepend",
                                     kwlist,
                                     &py_items))
        return NULL; 

    if (py_items == NULL || py_items == Py_None)
        len = 0;
    else if (PyTuple_Check(py_items))
        len = PyTuple_Size(py_items);
    else {
        PyErr_SetString(PyExc_TypeError,
                        "items must be a tuple containing label/value pairs "
                        "or None");
        return NULL;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "items tuple must contain label/value pairs");
        return NULL;
    }

    for (i = 0; i < len; i += 2) {
        PyObject *label = PyTuple_GetItem(py_items, i);
        PyObject *value = PyTuple_GetItem(py_items, i + 1);

        if (!PyString_Check(label)) {
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each label/value pair "
                            "must be a string");
            return NULL;
        }

        if (!PyInt_Check(value)) {
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each label/value pair "
                            "must be a number");
            return NULL;
        }

        gimp_int_combo_box_prepend(GIMP_INT_COMBO_BOX(self->obj),
                                  GIMP_INT_STORE_LABEL,
                                  PyString_AsString(label),
                                  GIMP_INT_STORE_VALUE,
                                  PyInt_AsLong(value),
                                  -1);
    }
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_browser_add_search_types args
static PyObject *
_wrap_gimp_browser_add_search_types(PyGObject *self, PyObject *args)
{
    GimpBrowser *browser;
    int len, i;
    PyObject *element;
    gchar *label;
    gint id;

    browser = GIMP_BROWSER(self->obj);

    len = PyTuple_Size(args);

    for (i = 0; i < len; ++i) {
        element = PyTuple_GetItem(args, i);
        if (!PyTuple_Check(element)) {
            PyErr_SetString(PyExc_TypeError, "GimpBrowser.add_search_types: Arguments must be tuples");
            return NULL;
        }
        if (!PyArg_ParseTuple(element, "si",  &label, &id))
            return NULL;
        gimp_browser_add_search_types(browser, label, id, NULL);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_proc_browser_dialog_new kwargs
static int
_wrap_gimp_proc_browser_dialog_new(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    gchar *title, *role;
    PyObject *py_buttons = Py_None;
    PyObject *help_func = NULL;
    gchar *help_id = NULL;
    int len, i;
    GimpHelpFunc func;

    static char *kwlist[] = { "title", "role", "help_func", "help_id",
                              "buttons", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zz|OzO:gimpui.GimpProcBrowserDialog.__init__",
                                     kwlist,
                                     &title, &role, &help_func, &help_id,
                                     &py_buttons))
        return -1;

    if (py_buttons == Py_None)
        len = 0;
    else if (PyTuple_Check(py_buttons))
        len = PyTuple_Size(py_buttons);
    else {
        PyErr_SetString(PyExc_TypeError,
                        "buttons must be a tuple containing text/response "
                        "pairs or None");
        return -1;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "buttons tuple must contain text/response id pairs");
        return -1;
    }

    if (help_func) {
        if (help_func != Py_None) {
            if (!PyCallable_Check(help_func)) {
                PyErr_SetString(PyExc_TypeError, "help_func must be callable");
                return -1;
            }

            func = pygimp_help_func_marshal;

       } else {
            func = gimp_standard_help_func;
        }
    } else {
        func = gimp_standard_help_func;
    }

    pygobject_construct(self,
                        "title",     title,
                        "role",      role,
                        "help-func", func,
                        "help-id",   help_id,
                        NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GimpProcBrowserDialog object");
        return -1;
    }

    for (i = 0; i < len; i += 2) {
        PyObject *text = PyTuple_GetItem(py_buttons, i);
        PyObject *id = PyTuple_GetItem(py_buttons, i + 1);
        if (!PyString_Check(text) && !PyUnicode_Check(text)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each text/response id pair "
                            "must be a string");
            return -1;
        }
        if (!PyInt_Check(id)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each text/response id pair "
                            "must be a number");
            return -1;
        }

        gimp_dialog_add_button(GIMP_DIALOG(self->obj), PyString_AsString(text),
                               PyInt_AsLong(id));
    }

    if (help_func && help_func != Py_None) {
        g_object_set_data(self->obj, "pygimp-dialog-help-data", self);

        Py_INCREF(help_func);
        g_object_set_data_full(self->obj, "pygimp-dialog-help-func",
                               help_func, pygimp_help_func_destroy);
    }

    g_signal_emit_by_name(GIMP_PROC_BROWSER_DIALOG(self->obj)->browser,
                          "search", "", 0, self->obj);
    return 0;
}
%%
new-constructor GIMP_TYPE_PROC_BROWSER_DIALOG
%%
override gimp_number_pair_entry_get_values noargs
static PyObject *
_wrap_gimp_number_pair_entry_get_values(PyGObject *self)
{
    gdouble left, right;

    gimp_number_pair_entry_get_values(GIMP_NUMBER_PAIR_ENTRY(self->obj),
                                      &left, &right);

    return Py_BuildValue("(dd)", left, right);   
}
%%
override gimp_number_pair_entry_get_default_values noargs
static PyObject *
_wrap_gimp_number_pair_entry_get_default_values(PyGObject *self)
{
    gdouble left, right;

    gimp_number_pair_entry_get_default_values(
                                             GIMP_NUMBER_PAIR_ENTRY(self->obj),
                                             &left, &right);

    return Py_BuildValue("(dd)", left, right);
}
%%
override gimp_number_pair_entry_get_aspect noargs
static PyObject *
_wrap_gimp_number_pair_entry_get_aspect(PyGObject *self)
{
    GimpAspectType aspect;

    aspect =
          gimp_number_pair_entry_get_aspect(GIMP_NUMBER_PAIR_ENTRY(self->obj));

    return pyg_enum_from_gtype(GIMP_TYPE_ASPECT_TYPE, aspect);
}
%%
override gimp_number_pair_entry_set_aspect kwargs
static PyObject *
_wrap_gimp_number_pair_entry_set_aspect(PyGObject *self, PyObject *args,
                                        PyObject *kwargs)
{
    PyObject *py_aspect;
    GimpAspectType aspect;

    static char *kwlist[] = {"aspect", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "O:GimpNumberPairEntry.set_aspect",
                                    kwlist, &py_aspect))
        return NULL;

    if (pyg_enum_get_value(GIMP_TYPE_ASPECT_TYPE, py_aspect, (gint*)&aspect))
    {
        Py_XDECREF(py_aspect);
        return NULL;
    }

    gimp_number_pair_entry_set_aspect(GIMP_NUMBER_PAIR_ENTRY(self->obj),
                                      aspect);

    Py_DECREF(py_aspect);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_page_selector_get_selected_pages noargs
static PyObject *
_wrap_gimp_page_selector_get_selected_pages(PyGObject *self)
{
    gint *selected_pages;
    gint n_selected_pages;
    PyObject *py_selected_pages;
    int i;

    selected_pages = gimp_page_selector_get_selected_pages(
                                                GIMP_PAGE_SELECTOR (self->obj),
                                                &n_selected_pages);
    
    py_selected_pages = PyTuple_New(n_selected_pages);
    for (i = 0; i < n_selected_pages; ++i)
        PyTuple_SetItem(py_selected_pages, i,
                        PyInt_FromLong(selected_pages[i]));

    g_free(selected_pages);

    return py_selected_pages;
}
%%
override gimp_preview_get_position noargs
static PyObject *
_wrap_gimp_preview_get_position(PyGObject *self)
{
    gint x;
    gint y;
  
    gimp_preview_get_position(GIMP_PREVIEW(self->obj), &x, &y);

    return Py_BuildValue("(ii)", x, y);
}
%%
override gimp_preview_get_size noargs
static PyObject *
_wrap_gimp_preview_get_size(PyGObject *self)
{
    gint width;
    gint height;
  
    gimp_preview_get_size(GIMP_PREVIEW(self->obj), &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
%%
override gimp_preview_transform kwargs
static PyObject *
_wrap_gimp_preview_transform(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    gint src_x;
    gint src_y;
    gint dest_x;
    gint dest_y;

    static char *kwlist[] = {"x", "y", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GimpPreview.transform",
                                     kwlist, &src_x, &src_y))
        return NULL;

    gimp_preview_transform(GIMP_PREVIEW(self->obj), src_x, src_y, &dest_x,
                           &dest_y);

    return Py_BuildValue("(ii)", dest_x, dest_y);
}
%%
override gimp_preview_untransform kwargs
static PyObject *
_wrap_gimp_preview_untransform(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    gint src_x;
    gint src_y;
    gint dest_x;
    gint dest_y;

    static char *kwlist[] = {"x", "y", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "ii:GimpPreview.untransform",
                                     kwlist, &src_x, &src_y))
        return NULL;

    gimp_preview_untransform(GIMP_PREVIEW(self->obj), src_x, src_y, &dest_x,
                             &dest_y);

    return Py_BuildValue("(ii)", dest_x, dest_y);
}
%%
override gimp_zoom_model_get_fraction noargs
static PyObject *
_wrap_gimp_zoom_model_get_fraction(PyGObject *self)
{
    gint numerator;
    gint denominator;

    gimp_zoom_model_get_fraction(GIMP_ZOOM_MODEL(self->obj), &numerator,
                                 &denominator);

    return Py_BuildValue("(ii)", numerator, denominator);
}
%%
override gimp_drawable_preview_get_drawable noargs
static PyObject *
_wrap_gimp_drawable_preview_get_drawable(PyGObject *self)
{
    PyObject *drawable;
    
    drawable = g_object_get_data(self->obj, 
                                 "pygimp-drawable-preview-pydrawable");
    Py_INCREF(drawable);
    return drawable;
}
%%
override gimp_zoom_preview_get_drawable noargs
static PyObject *
_wrap_gimp_zoom_preview_get_drawable(PyGObject *self)
{
    PyObject *drawable;
    
    drawable = g_object_get_data(self->obj,
                                 "pygimp-zoom-preview-pydrawable");
    Py_INCREF(drawable);
    return drawable;
}
%%
override gimp_drawable_preview_draw_region kwargs
static PyObject *
_wrap_gimp_drawable_preview_draw_region(PyGObject *self, PyObject *args,
                                        PyObject *kwargs)
{
/*    PyGimpPixelRgn *pypixelrgn;

    static char *kwlist[] = {"drawable", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "O!:GimpDrawablePreview.draw_region",
                                    kwlist, PyGimpPixelRgn_Type, &pypixelrgn))
        return NULL;

    gimp_drawable_preview_draw_region(GIMP_DRAWABLE_PREVIEW(self->obj),
                                      &pypixelrgn->pr);
*/
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_int_store_lookup_by_value
static PyObject *
_wrap_gimp_int_store_lookup_by_value(PyGObject *self, PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "value", NULL };
    int value, ret;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                               "i:GimpIntStore.gimp_int_store_lookup_by_value",
                               kwlist, &value))
        return NULL;

    ret = gimp_int_store_lookup_by_value(GTK_TREE_MODEL(self->obj), value,
                                         &iter);
    if (ret)
        pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_memsize_entry_new
static int
_wrap_gimp_memsize_entry_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "value", "lower", "upper", NULL };
    guint64 value, lower, upper;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "LLL:GimpMemsizeEntry.__init__",
                                     kwlist, &value, &lower, &upper))
        return -1;
    
    self->obj = (GObject *)gimp_memsize_entry_new(value, lower, upper);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GimpMemsizeEntry object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gimp_memsize_entry_set_value
static PyObject *
_wrap_gimp_memsize_entry_set_value(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "value", NULL };
    guint64 value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "L:GimpMemsizeEntry.set_value",
                                     kwlist, &value))
        return NULL;

    gimp_memsize_entry_set_value(GIMP_MEMSIZE_ENTRY(self->obj), value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gimp_color_area_get_color noargs
static PyObject *
_wrap_gimp_color_area_get_color(PyGObject *self)
{
    GimpRGB rgb;

    gimp_color_area_get_color(GIMP_COLOR_AREA(self->obj), &rgb);

    return pygimp_rgb_new(&rgb);
}
%%
override gimp_color_hex_entry_get_color noargs
static PyObject *
_wrap_gimp_color_hex_entry_get_color(PyGObject *self)
{
    GimpRGB rgb;

    gimp_color_hex_entry_get_color(GIMP_COLOR_HEX_ENTRY(self->obj), &rgb);

    return pygimp_rgb_new(&rgb);
}
%%
override gimp_color_notebook_get_color noargs
static PyObject *
_wrap_gimp_color_notebook_get_color(PyGObject *self)
{
    GimpRGB rgb;

    gimp_color_notebook_get_color(GIMP_COLOR_NOTEBOOK(self->obj), &rgb);

    return pygimp_rgb_new(&rgb);
}
%%
override gimp_color_selection_get_color noargs
static PyObject *
_wrap_gimp_color_selection_get_color(PyGObject *self)
{
    GimpRGB rgb;

    gimp_color_selection_get_color(GIMP_COLOR_SELECTION(self->obj), &rgb);

    return pygimp_rgb_new(&rgb);
}
%%
override gimp_color_selection_get_old_color noargs
static PyObject *
_wrap_gimp_color_selection_get_old_color(PyGObject *self)
{
    GimpRGB rgb;

    gimp_color_selection_get_old_color(GIMP_COLOR_SELECTION(self->obj), &rgb);

    return pygimp_rgb_new(&rgb);
}
%%
override gimp_enum_store_new kwargs
static int
_wrap_gimp_enum_store_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "enum_type", "minimum", "maximum", NULL };
    PyObject *py_enum_type = NULL;
    PyObject *py_minimum = NULL;
    PyObject *py_maximum = NULL;
    GType enum_type;
    GEnumClass *enum_class;
    gint minimum, maximum;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O!O!:GimpEnumStore.__init__", kwlist,
                                      &py_enum_type, &PyInt_Type, &py_minimum,
                                      &PyInt_Type, &py_maximum))
        return -1;
    if ((enum_type = pyg_type_from_object(py_enum_type)) == 0)
        return -1;

    enum_class = g_type_class_ref(enum_type);

    if (py_minimum == NULL)
        minimum = enum_class->minimum;
    else
        minimum = PyInt_AsLong(py_minimum);
    
    if (py_maximum == NULL)
        maximum = enum_class->maximum;
    else
        maximum = PyInt_AsLong(py_maximum);
    
    g_type_class_unref(enum_class);

    self->obj = (GObject *)gimp_enum_store_new_with_range(enum_type, minimum, maximum);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GimpEnumStore object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gimp_zoom_preview_new_with_model kwargs
static int
_wrap_gimp_zoom_preview_new_with_model(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "drawable", "model", NULL };
    PyGimpDrawable *py_drawable;
    PyGObject *py_zoom_model = NULL;
    GimpZoomModel *zoom_model;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!|O!:GimpZoomPreview.__init__", kwlist,
                                     PyGimpDrawable_Type, &py_drawable,
                                     &PyGimpZoomModel_Type, &py_zoom_model))
        return -1;

    if (py_zoom_model)
        zoom_model = (GimpZoomModel*)py_zoom_model->obj;
    else
        zoom_model = NULL;

    if (!py_drawable->drawable)
        py_drawable->drawable = gimp_drawable_get(py_drawable->ID);

    if (pygobject_construct(self, "drawable", py_drawable->drawable, "model", zoom_model, NULL))
        return -1;

    g_object_set_data_full(self->obj, "pygimp-zoom-preview-pydrawable",
                           py_drawable,
                           (GDestroyNotify)pygimp_decref_callback);

    Py_INCREF(py_drawable);

    return 0;
}
%%
new-constructor GIMP_TYPE_ZOOM_PREVIEW
%%
override gimp_aspect_preview_new kwargs
static int
_wrap_gimp_aspect_preview_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "drawable", NULL };
    PyGimpDrawable *py_drawable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!|:GimpAspectPreview.__init__", kwlist,
                                     PyGimpDrawable_Type, &py_drawable))
        return -1;

    if (!py_drawable->drawable)
        py_drawable->drawable = gimp_drawable_get(py_drawable->ID);
    
    if (pygobject_construct(self, "drawable", py_drawable->drawable, NULL))
        return -1;
    
    g_signal_connect_swapped(self->obj, "destroy",
                             (GCallback)pygimp_decref_callback, py_drawable);
    Py_INCREF(py_drawable);

    return 0;
}
%%
new-constructor GIMP_TYPE_ASPECT_PREVIEW
%%
override gimp_drawable_preview_new kwargs
static int
_wrap_gimp_drawable_preview_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "drawable", NULL };
    PyGimpDrawable *py_drawable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!|:GimpDrawablePreview.__init__", kwlist,
                                     PyGimpDrawable_Type, &py_drawable))
        return -1;

    if (!py_drawable->drawable)
        py_drawable->drawable = gimp_drawable_get(py_drawable->ID);
  
    if (pygobject_construct(self, "drawable", py_drawable->drawable, NULL))
        return -1;

    g_object_set_data_full(self->obj, "pygimp-drawable-preview-pydrawable",
                           py_drawable, 
                           (GDestroyNotify)pygimp_decref_callback);

    Py_INCREF(py_drawable);

    return 0;
}

%%
new-constructor GIMP_TYPE_DRAWABLE_PREVIEW
%%
override gimp_ruler_get_range noargs
static PyObject *
_wrap_gimp_ruler_get_range(PyGObject *self)
{
    gdouble lower, upper, max_size;

    gimp_ruler_get_range(GIMP_RULER(self->obj), &lower, &upper, &max_size);

    return Py_BuildValue("(ddd)", lower, upper, max_size);
}
%%
override gimp_color_display_convert_surface kwargs
static PyObject *
_wrap_gimp_color_display_convert_surface(PyGObject *self, PyObject *args,
                                         PyObject *kwargs)
{
  PycairoSurface *pysurface;

  static char *kwlist[] = { "surface", NULL };

  if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                   "O!:GimpColorDisplay.convert_surface",
                                   kwlist,
                                   &PycairoSurface_Type, &pysurface))
    return NULL;

  gimp_color_display_convert_surface(GIMP_COLOR_DISPLAY(self->obj),
                                     pysurface->surface);

  Py_INCREF(Py_None);
  return Py_None;
}
%%
override gimp_color_display_stack_convert_surface kwargs
static PyObject *
_wrap_gimp_color_display_stack_convert_surface(PyGObject *self, PyObject *args,
                                               PyObject *kwargs)
{
  PycairoSurface *pysurface;

  static char *kwlist[] = { "surface", NULL };

  if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                   "O!:GimpColorDisplayStack.convert_surface",
                                   kwlist,
                                   &PycairoSurface_Type, &pysurface))
    return NULL;

  gimp_color_display_stack_convert_surface(GIMP_COLOR_DISPLAY_STACK(self->obj),
                                           pysurface->surface);

  Py_INCREF(Py_None);
  return Py_None;
}
%%
override gimp_zoom_preview_get_source noargs
static PyObject *
_wrap_gimp_zoom_preview_get_source(PyGObject *self)
{
  gint width, height, bpp;
  guchar *image;
  PyObject *pyimage;

  image = gimp_zoom_preview_get_source(GIMP_ZOOM_PREVIEW(self->obj),
                                       &width, &height, &bpp);

  if (image)
    {
      pyimage = PyByteArray_FromStringAndSize((const char *)image,
                                              width * height * bpp);
      g_free (image);
    }
  else
    {
      Py_INCREF(Py_None);
      pyimage = Py_None;
    }

  return Py_BuildValue("(Niii)", pyimage, width, height, bpp);
}
%%
override gimp_ui_init noargs
static PyObject *
_wrap_gimp_ui_init(PyObject *self)
{
  extern const char *prog_name;

  gimp_ui_init (prog_name, FALSE);

  Py_INCREF(Py_None);
  return Py_None;
}
