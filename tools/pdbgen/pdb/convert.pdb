# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

sub simple_inargs {
    @inargs = (
	&std_image_arg
    );
}

sub simple_invoke {
    my $type = shift;
    %invoke = (
	code => <<CODE
if ((success = (gimp_image_base_type (gimage) != $type)))
  gimp_image_convert ((void *) gimage, $type, 0, 0, 0, 1, 0, NULL);
CODE
    );
}

sub image_convert_rgb {
    $blurb = 'Convert specified image to RGB color';

    $help = <<'HELP';
This procedure converts the specified image to RGB color. This process requires
an image of type GIMP_GRAY or GIMP_INDEXED. No image content is lost in this 
process aside from the colormap for an indexed image.
HELP

    &std_pdb_misc;
    &simple_inargs;
    &simple_invoke('GIMP_RGB');
}

sub image_convert_grayscale {
    $blurb = 'Convert specified image to grayscale (256 intensity levels)';

    $help = <<'HELP';
This procedure converts the specified image to grayscale with 8 bits per pixel
(256 intensity levels). This process requires an image of type GIMP_RGB or 
GIMP_INDEXED.
HELP

    &std_pdb_misc;
    &simple_inargs;
    &simple_invoke('GIMP_GRAY');
}

sub image_convert_indexed {
    $blurb = 'Convert specified image to and Indexed image';

    $help = <<'HELP';
This procedure converts the specified image to 'indexed' color. This
process requires an image of type GIMP_GRAY or GIMP_RGB. The
'palette_type' specifies what kind of palette to use, A type of '0'
means to use an optimal palette of 'num_cols' generated from the
colors in the image. A type of '1' means to re-use the previous
palette (not currently implemented). A type of '2' means to use the
so-called WWW-optimized palette. Type '3' means to use only black and
white colors. A type of '4' means to use a palette from the gimp
palettes directories.  The 'dither type' specifies what kind of
dithering to use.  '0' means no dithering, '1' means standard
Floyd-Steinberg error diffusion, '2' means Floyd-Steinberg error
diffusion with reduced bleeding, '3' means dithering based on pixel
location ('Fixed' dithering).
HELP

    &std_pdb_misc;

    @inargs = (
	&std_image_arg,
	{ name => 'dither_type', type => 'enum GimpConvertDitherType',
	  desc => 'dither type (0=none, 1=fs, 2=fs/low-bleed 3=fixed)' },
	{ name => 'palette_type', type => 'enum GimpConvertPaletteType',
	  desc => 'The type of palette to use: { %%desc%% }', no_success => 1 },
	{ name => 'num_cols', type => 'int32',
	  desc => 'the number of colors to quantize to, ignored unless
		   (palette_type == GIMP_MAKE_PALETTE)' },
	{ name => 'alpha_dither', type => 'boolean',
	  desc => 'dither transparency to fake partial opacity' },
	{ name => 'remove_unused', type => 'boolean',
	  desc => 'remove unused or duplicate colour entries from final
		   palette, ignored if (palette_type == GIMP_MAKE_PALETTE)' },
	{ name => 'palette', type => 'string',
	  desc => 'The name of the custom palette to use, ignored unless
		   (palette_type == GIMP_CUSTOM_PALETTE)',
	  alias => 'palette_name' }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpPalette *palette = NULL;

  if ((success = (gimp_image_base_type (gimage) != GIMP_INDEXED)))
    {
      switch (dither_type)
        {
	case GIMP_NO_DITHER:
	case GIMP_FS_DITHER:
	case GIMP_FSLOWBLEED_DITHER:
	case GIMP_FIXED_DITHER:
	  break;
	default:
	  success = FALSE;
	  break;
        }
      
      switch (palette_type)
	{
	case GIMP_MAKE_PALETTE:
	  if (num_cols < 1 || num_cols > MAXNUMCOLORS)
	    success = FALSE;
	  break;

	case GIMP_REUSE_PALETTE:
	case GIMP_WEB_PALETTE:
	case GIMP_MONO_PALETTE:
	  break;

	case GIMP_CUSTOM_PALETTE:
	  if (! gimp->palette_factory->container->num_children)
	    gimp_data_factory_data_init (gimp->palette_factory, FALSE);

          palette = (GimpPalette *)
            gimp_container_get_child_by_name (gimp->palette_factory->container,
                                              palette_name);

	  if (palette == NULL)
	    success = FALSE;

	  break;

	default:
	  success = FALSE;
	}
    }

  if (success)
    gimp_image_convert (gimage, GIMP_INDEXED, num_cols, dither_type,
		        alpha_dither, remove_unused, palette_type, palette);
}
CODE
    );
}

@headers = qw("core/gimp.h" "core/gimpcontainer.h" "core/gimpimage.h"
	      "core/gimpimage-convert.h" "core/gimpdatafactory.h"
	      "core/gimppalette.h");

@procs = qw(image_convert_rgb image_convert_grayscale image_convert_indexed);
%exports = (app => [@procs], lib => [@procs]);

$desc = 'Convert';

1;
