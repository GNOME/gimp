# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

sub drawable_arg () {{
    name => 'drawable',
    type => 'drawable',
    desc => 'The drawable',
}}

sub drawable_coord_args () {
    @inargs = ( &drawable_arg );

    foreach (qw(x y)) {
	push @inargs, { name => "${_}_coord", type => '0 <= int32',
			desc => "The $_ coordinate", alias => $_ }
    }
}

sub pixel_arg () {{
    name => 'pixel',
    type => 'int8array',
    desc => 'The pixel value',
    array => { name => 'num_channels', type => 'int32',
	       desc => 'The number of channels for the pixel',
	       no_success => 1 }
}}

sub drawable_prop_proc {
    my ($return, $name, $type, $func, $desc, $core_type, $core_var) = @_;

    $core_type = 'drawable' unless $core_type;
    $core_var  = 'drawable' unless $core_var;

    $blurb = "Returns $return.";

    &std_pdb_misc;

    @inargs = ( &drawable_arg );

    @outargs = (
	{ name => $name, type => $type, desc => $desc,
	  alias => "gimp_${core_type}_$func (${core_var})", no_declare => 1 }
    );
}

sub drawable_type_proc {
    my ($desc, $type, $func) = @_;

    $help = <<HELP;
This procedure returns non-zero if the specified drawable is of type
{ $type }.
HELP

    &drawable_prop_proc("whether the drawable is $desc type", $func, 'boolean',
			$func, "non-zero if the drawable is $desc type");
}

sub drawable_is_proc {
    my ($desc, $check) = @_;

    my $type = $desc;
    $type =~ s/ /_/g;

    $help = <<HELP;
This procedure returns non-zero if the specified drawable is a $desc.
HELP

    &drawable_prop_proc("whether the drawable is a $desc",
			$type, 'boolean', $type,
			"Non-zero if the drawable is a $desc");

    $outargs[0]->{alias} = $check . ' (drawable) ? TRUE : FALSE';
}

sub drawable_get_prop_proc {
    my ($prop, $type, $desc, $undo, $core_type, $core_var) = @_;

    $core_type = 'drawable' unless $core_type;
    $core_var  = 'drawable' unless $core_var;

    $blurb = "Get the $desc of the specified drawable.";

    $help = "This procedure returns the specified drawable's $desc. ";

    &std_pdb_misc;

    @inargs = ( &drawable_arg );

    @outargs = (
	{ name => $prop, type => $type,
	  desc => "The drawable $desc", no_declare => 1 }
    );

    my $alias = "gimp_${core_type}_get_$prop ($core_var)";
    $alias = "g_strdup ($alias)" if $type eq 'string';
    $outargs[0]->{alias} .= "$alias";
}

sub drawable_set_prop_proc {
    my ($prop, $type, $desc, $undo, $core_type, $core_var) = @_;

    $core_type = 'drawable' unless $core_type;
    $core_var  = 'drawable' unless $core_var;

    $blurb = "Set the $desc of the specified drawable.";

    $help = "This procedure sets the specified drawable's $desc. ";

    &std_pdb_misc;

    @inargs = (
	&drawable_arg,
	{ name => $prop, type => $type,
	  desc => "The new drawable $desc" }
    );

    if ($type =~ /float/) {
	$inargs[1]->{desc} .= ' (%%desc%%)';
    }

    $invoke{code} = $undo ? "gimp_${core_type}_set_$prop ($core_var, $prop, TRUE);"
                          : "gimp_${core_type}_set_$prop ($core_var, $prop);";
}

sub drawable_accessors {
    my ($prop, $type, $desc, $undo, $extra, $core_type, $core_var) = @_;

    $core_type = 'drawable' unless $core_type;
    $core_var  = 'drawable' unless $core_var;

    my (@extra, %extra); my $once = 0;

    ref($extra) ? (@extra = @$extra) : (@extra = ($extra, $extra));
    %extra = map { $once++ ? 'set' : 'get', $_ ? $_ : "" } @extra;

    foreach (sort keys %extra) {
	my $proc = "drawable_${_}_$prop";

	eval <<SUB;
sub @{[ scalar caller ]}::$proc {
    \&drawable_${_}_prop_proc('$prop', '$type', '$desc', $undo,
                              '$core_type', '$core_var');
    $extra{$_}
}
SUB
    }
}

sub drawable_merge_shadow {
    $blurb = 'Merge the shadow buffer with the specified drawable.';

    $help = <<'HELP';
This procedure combines the contents of the image's shadow buffer (for
temporary processing) with the specified drawable. The "undo" parameter
specifies whether to add an undo step for the operation. Requesting no undo is
useful for such applications as 'auto-apply'.
HELP

    &std_pdb_misc;

    @inargs = (
	&drawable_arg,
        { name => 'undo', type => 'boolean',
	  desc => 'Push merge to undo stack?' }
    );

    %invoke = ( headers => [ qw("plug-in/plug-in.h") ],
                code => <<CODE
{
  success = gimp_item_is_attached (GIMP_ITEM (drawable));

  if (success)
    {
      gchar *undo_desc = NULL;

      if (gimp->current_plug_in)
        undo_desc = plug_in_get_undo_desc (gimp->current_plug_in);

      if (! undo_desc)
        undo_desc = g_strdup (_("Plug-In"));

      gimp_drawable_merge_shadow (drawable, undo, undo_desc);

      g_free (undo_desc);
    }
}
CODE
    );
}

sub drawable_fill {
    $blurb = 'Fill the drawable with the specified fill mode.';

    $help = <<'HELP';
This procedure fills the drawable with the fill mode. If the fill mode is
foreground the current foreground color is used. If the fill mode is
background, the current background color is used. If the fill type is white,
then white is used. Transparent fill only affects layers with an alpha channel,
in which case the alpha channel is set to transparent. If the drawable has no
alpha channel, it is filled to white. No fill leaves the drawable's contents
undefined. This procedure is unlike the bucket fill tool because it fills
regardless of a selection
HELP

    &std_pdb_misc;

    @inargs = (
	&drawable_arg,
	{ name => 'fill_type', type => 'enum GimpFillType',
	  desc => 'The type of fill: %%desc%%' }
    );

    %invoke = ( code => 'gimp_drawable_fill_by_type (drawable, context, (GimpFillType) fill_type);' );
}

sub drawable_update {
    $blurb = 'Update the specified region of the drawable.';

    $help = <<'HELP';
This procedure updates the specified region of the drawable. The (x, y)
coordinate pair is relative to the drawable's origin, not to the image origin.
Therefore, the entire drawable can be updated using (0, 0, width, height).
HELP

    &std_pdb_misc;

    @inargs = (
	&drawable_arg,
	{ name => 'x', type => 'int32',
	  desc => 'x coordinate of upper left corner of update region' },
	{ name => 'y', type => 'int32',
	  desc => 'y coordinate of upper left corner of update region' },
	{ name => 'width', type => 'int32',
	  desc => 'Width of update region' },
	{ name => 'height', type => 'int32',
	  desc => 'Height of update region' }
    );

    %invoke = ( code => 'gimp_drawable_update (drawable, x, y, width, height);' );
}

sub drawable_mask_bounds {
    $blurb = <<'BLURB';
Find the bounding box of the current selection in relation to the specified
drawable.
BLURB

    $help = <<'HELP';
This procedure returns whether there is a selection. If there is one, the
upper left and lower righthand corners of its bounding box are returned. These
coordinates are specified relative to the drawable's origin, and bounded by
the drawable's extents. Please note that the pixel specified by the lower
righthand coordinate of the bounding box is not part of the selection. The
selection ends at the upper left corner of this pixel. This means the width
of the selection can be calculated as (x2 - x1), its height as (y2 - y1).

Note that the returned boolean does NOT correspond with the returned
region being empty or not, it always returns whether the selection
is non_empty. See gimp_drawable_mask_intersect() for a boolean
return value which is more useful in most cases.
HELP

    &std_pdb_misc;

    @inargs = ( &drawable_arg );

    @outargs = (
	{ name => 'non_empty', type => 'boolean', init => 1,
	  desc => 'TRUE if there is a selection' },
    );

    my $pos = 1;
    foreach $where ('upper left', 'lower right') {
	foreach (qw(x y)) {
	    push @outargs, { name => "$_$pos", type => 'int32',
	    		     desc => "$_ coordinate of the $where corner of
			     	      selection bounds" }
	}
	$pos++;
    }

    %invoke = (
	code => <<'CODE'
non_empty = gimp_drawable_mask_bounds (drawable, &x1, &y1, &x2, &y2);
CODE
    );
}

sub drawable_mask_intersect {
    $blurb = <<'BLURB';
Find the bounding box of the current selection in relation to the specified
drawable.
BLURB

    $help = <<'HELP';
This procedure returns whether there is an intersection between the
drawable and the selection. Unlike gimp_drawable_mask_bounds(), the
intersection's bounds are returned as x, y, width, height.

If there is no selection this function returns TRUE and the returned
bounds are the extents of the whole drawable.
HELP

    $author    = 'Michael Natterer <mitch@gimp.org>';
    $copyright = 'Michael Natterer';
    $date      = '2004';
    $since     = '2.2';

    @inargs = ( &drawable_arg );

    @outargs = (
	{ name => 'non_empty', type => 'boolean', init => 1,
	  desc => 'TRUE if the returned area is not empty' },
	{ name => 'x', type => 'int32',
          desc => 'x coordinate of the upper left corner of the intersection' },
	{ name => 'y', type => 'int32',
          desc => 'y coordinate of the upper left corner of the intersection' },
	{ name => 'width', type => 'int32',
          desc => 'width of the intersection' },
	{ name => 'height', type => 'int32',
          desc => 'height of the intersection' }
    );

    %invoke = (
	code => <<'CODE'
non_empty = gimp_drawable_mask_intersect (drawable, &x, &y, &width, &height);
CODE
    );
}

sub drawable_get_image {
    $blurb = "Returns the drawable's image.";

    $help = "This procedure returns the drawable's image.";

    &std_pdb_misc;

    @inargs = ( &drawable_arg );

    @outargs = ( &std_image_arg );
    $outargs[0]->{desc} = "The drawable's image";
    $outargs[0]->{init} = 1;

    %invoke = (
	code => 'success = (gimage = gimp_item_get_image (GIMP_ITEM (drawable))) != NULL;'
    );
}

sub drawable_type {
    $help = "This procedure returns the drawable's type.";

    &drawable_prop_proc("the drawable's type", 'type', 'enum GimpImageType',
			'type', "The drawable's type: { %%desc%% }");
}

sub drawable_has_alpha {
    $help = <<'HELP';
This procedure returns whether the specified drawable has an alpha channel.
This can only be true for layers, and the associated type will be one of:
{ RGBA , GRAYA, INDEXEDA }.
HELP

    &drawable_prop_proc('non-zero if the drawable has an alpha channel',
			'has_alpha', 'boolean', 'has_alpha',
			'Does the drawable have an alpha channel?');
}

sub drawable_type_with_alpha {
    $help = <<'HELP';
This procedure returns the drawable's type as if had an alpha
channel. If the type is currently Gray, for instance, the returned
type would be GrayA. If the drawable already has an alpha channel, the
drawable's type is simply returned.
HELP

    &drawable_prop_proc("the drawable's type with alpha", 'type_with_alpha',
			'enum GimpImageType (no RGB_GIMAGE, GRAY_GIMAGE,
			 INDEXED_GIMAGE)', 'type_with_alpha',
			"The drawable's type with alpha: { %%desc%% }");
}

sub drawable_is_rgb {
    &drawable_type_proc('an RGB', 'RGB, RGBA', 'is_rgb');
}

sub drawable_is_gray {
    &drawable_type_proc('a grayscale', 'Gray, GrayA', 'is_gray');
}

sub drawable_is_indexed {
    &drawable_type_proc('an indexed', 'Indexed, IndexedA', 'is_indexed');
}

sub drawable_bpp {
    $help = <<'HELP';
This procedure returns the number of bytes per pixel (or the number of
channels) for the specified drawable.
HELP

    &drawable_prop_proc('the bytes per pixel', 'bpp', 'int32', 'bytes',
			'Bytes per pixel');
}

sub drawable_width {
    $help = "This procedure returns the specified drawable's width in pixels.";

    &drawable_prop_proc('the width of the drawable', 'width', 'int32',
			'width', 'Width of drawable',
                        'item', 'GIMP_ITEM (drawable)');
}

sub drawable_height {
    $help = "This procedure returns the specified drawable's height in pixels.";

    &drawable_prop_proc('the height of the drawable', 'height', 'int32',
			'height', 'Height of drawable',
                        'item', 'GIMP_ITEM (drawable)');
}

sub drawable_offsets {
    $blurb = 'Returns the offsets for the drawable.';

    $help = <<'HELP';
This procedure returns the specified drawable's offsets. This only makes sense
if the drawable is a layer since channels are anchored. The offsets of a
channel will be returned as 0.
HELP

    &std_pdb_misc;

    @inargs = ( &drawable_arg );

    foreach (qw(x y)) {
	push @outargs, { name => "offset_$_", type => 'int32',
			 desc => "$_ offset of drawable", void_ret => 1 }
    }

    %invoke = ( code => 'gimp_item_offsets (GIMP_ITEM (drawable), &offset_x, &offset_y);' );
}

sub drawable_is_layer {
    &drawable_is_proc('layer', 'GIMP_IS_LAYER');
}

sub drawable_is_layer_mask {
    &drawable_is_proc('layer mask', 'GIMP_IS_LAYER_MASK');
}

sub drawable_is_channel {
    &drawable_is_proc('channel', 'GIMP_IS_CHANNEL');
}

&drawable_accessors('name', 'string', 'name', 0, [ undef, <<'CODE' ],
$invoke{code} =~ s/gimp_object_set_name/success = gimp_item_rename/;
$invoke{code} =~ s/GIMP_OBJECT/GIMP_ITEM/;
CODE
                 'object', 'GIMP_OBJECT (drawable)');

&drawable_accessors('visible', 'boolean', 'visibility', 1, undef,
                    'item', 'GIMP_ITEM (drawable)');

&drawable_accessors('linked', 'boolean', 'linked state', 1,
                    <<'CODE', 'item', 'GIMP_ITEM (drawable)');
    $author = $copyright = 'Wolfgang Hofer';
    $date = '1998';

    if (scalar @outargs) {
        $outargs[0]->{desc} .= ' (for moves)'
    }
CODE

&drawable_accessors('tattoo', 'tattoo', 'tattoo', 0,
                    <<'CODE', 'item', 'GIMP_ITEM (drawable)');
    $help .= <<'HELP';
A tattoo is a unique and permanent identifier attached to a drawable that can be
used to uniquely identify a drawable within an image even between sessions
HELP

    $author = $copyright = 'Jay Cox';
    $date = '1998';
CODE

sub drawable_get_pixel {
    $blurb = 'Gets the value of the pixel at the specified coordinates.';

    $help = <<'HELP';
This procedure gets the pixel value at the specified coordinates. The
'num_channels' argument must always be equal to the bytes-per-pixel value for
the specified drawable.
HELP

    &std_pdb_misc;
    $date = '1997';

    &drawable_coord_args();

    @outargs = ( &pixel_arg );
    $outargs[0]->{init} = $outargs[0]->{array}->{init} = 1;

    %invoke = (
	vars => [ 'guint8 *p', 'gint b', 'Tile *tile' ],
	code => <<'CODE'
{
  if (x < gimp_item_width  (GIMP_ITEM (drawable)) &&
      y < gimp_item_height (GIMP_ITEM (drawable)))
    {
      num_channels = gimp_drawable_bytes (drawable);
      pixel = g_new (guint8, num_channels);

      tile = tile_manager_get_tile (gimp_drawable_data (drawable), x, y,
				    TRUE, TRUE);

      x %= TILE_WIDTH;
      y %= TILE_HEIGHT;

      p = tile_data_pointer (tile, x, y);
      for (b = 0; b < num_channels; b++)
	pixel[b] = p[b];

      tile_release (tile, FALSE);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub drawable_set_pixel {
    $blurb = 'Sets the value of the pixel at the specified coordinates.';

    $help = <<'HELP';
This procedure sets the pixel value at the specified coordinates. The
'num_channels' argument must always be equal to the bytes-per-pixel value for
the specified drawable. Note that this function is not undoable, you should
use it only on drawables you just created yourself.
HELP

    &std_pdb_misc;
    $date = '1997';

    &drawable_coord_args;
    push @inargs, &pixel_arg;

    %invoke = (
	vars => [ 'guint8 *p', 'gint b', 'Tile *tile' ],
	code => <<'CODE'
{
  if (x < gimp_item_width  (GIMP_ITEM (drawable)) &&
      y < gimp_item_height (GIMP_ITEM (drawable)) &&
      num_channels == gimp_drawable_bytes (drawable))
    {
      tile = tile_manager_get_tile (gimp_drawable_data (drawable), x, y,
				    TRUE, TRUE);

      x %= TILE_WIDTH;
      y %= TILE_HEIGHT;

      p = tile_data_pointer (tile, x, y);
      for (b = 0; b < num_channels; b++)
	*p++ = *pixel++;

      tile_release (tile, TRUE);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub drawable_set_image {
    &std_pdb_deprecated();

    @inargs = (
	&drawable_arg,
	&std_image_arg
    );

    %invoke = ( code =><<'CODE'
{
  success = (gimage == gimp_item_get_image (GIMP_ITEM (drawable)));
}
CODE
    );
}


sub dim_args () {
    my @args;
    foreach (qw(width height bpp)) {
	push @args, { name => $_, type => 'int32', desc => "The previews $_", init => 1 };
    }
    @args;
}

sub drawable_thumbnail {
    $blurb = 'Get a thumbnail of a drawable.';

    $help = <<'HELP';
This function gets data from which a thumbnail of a drawable preview
can be created. Maximum x or y dimension is 512 pixels. The pixels are
returned in RGB[A] or GRAY[A] format. The bpp return value gives the
number of bytes in the image.
HELP

    $author = $copyright = 'Andy Thomas';
    $date = '1999';

    @inargs = (
	&drawable_arg,
	{ name => 'width', type => '0 < int32 <= 512',
	  desc => 'The thumbnail width', alias => 'req_width' },
	{ name => 'height', type => '0 < int32 <= 512',
	  desc => 'The thumbnail height', alias => 'req_height' }
    );

    @outargs = (
	&dim_args,
        { name => 'thumbnail_data', type => 'int8array',
	  desc => 'The thumbnail data', init => 1, wrap => 1,
	  array => { name => 'thumbnail_data_count',
		     desc => 'The number of bytes in thumbnail data',
		     alias => 'num_bytes', init => 1 } }
    );
    $outargs[0]->{void_ret} = 1;

    %invoke = (
	code => <<'CODE'
{
  GimpImage *gimage = gimp_item_get_image (GIMP_ITEM (drawable));
  TempBuf   *buf;
  gint       dwidth, dheight;

  /* Adjust the width/height ratio */
  dwidth  = gimp_item_width  (GIMP_ITEM (drawable));
  dheight = gimp_item_height (GIMP_ITEM (drawable));

  if (dwidth > dheight)
    req_height = MAX (1, (req_width * dheight) / dwidth);
  else
    req_width  = MAX (1, (req_height * dwidth) / dheight);

  if (gimage->gimp->config->layer_previews)
    buf = gimp_viewable_get_new_preview (GIMP_VIEWABLE (drawable),
                                         req_width, req_height);
  else
    buf = gimp_viewable_get_dummy_preview (GIMP_VIEWABLE (drawable),
                                           req_width, req_height,
                                           gimp_drawable_has_alpha (drawable) ?
                                           4 : 3);

  if (buf)
    {
      num_bytes      = buf->height * buf->width * buf->bytes;
      thumbnail_data = g_memdup (temp_buf_data (buf), num_bytes);
      width          = buf->width;
      height         = buf->height;
      bpp            = buf->bytes;

      temp_buf_free (buf);
    }
  else
    {
      success = FALSE;
    }
}
CODE
    );
}

sub drawable_sub_thumbnail {
    $blurb = 'Get a thumbnail of a sub-area of a drawable drawable.';

    $help = <<'HELP';
This function gets data from which a thumbnail of a drawable preview
can be created. Maximum x or y dimension is 512 pixels. The pixels are
returned in RGB[A] or GRAY[A] format. The bpp return value gives the
number of bytes in the image.
HELP

    $author = $copyright = 'Michael Natterer <mitch@gimp.org>';
    $date   = '2004';
    $since  = '2.2';

    @inargs = (
	&drawable_arg,
        { name => 'src_x', type => '0 <= int32',
          desc => 'The x coordinate of the area' },
        { name => 'src_y', type => '0 <= int32',
          desc => 'The y coordinate of the area' },
        { name => 'src_width', type => '0 < int32',
          desc => 'The width of the area' },
        { name => 'src_height', type => '0 < int32',
          desc => 'The height of the area' },
	{ name => 'dest_width', type => '0 < int32 <= 512',
	  desc => 'The thumbnail width' },
	{ name => 'dest_height', type => '0 < int32 <= 512',
	  desc => 'The thumbnail height' }
    );

    @outargs = (
	&dim_args,
        { name => 'thumbnail_data', type => 'int8array',
	  desc => 'The thumbnail data', init => 1, wrap => 1,
	  array => { name => 'thumbnail_data_count',
		     desc => 'The number of bytes in thumbnail data',
		     alias => 'num_bytes', init => 1 } }
    );
    $outargs[0]->{void_ret} = 1;

    %invoke = (
	headers => [ qw("core/gimpdrawable-preview.h") ],
        code    => <<'CODE'
{
  success = ((src_x + src_width)  <= gimp_item_width  (GIMP_ITEM (drawable)) &&
             (src_y + src_height) <= gimp_item_height (GIMP_ITEM (drawable)));

  if (success)
    {
      GimpImage *gimage = gimp_item_get_image (GIMP_ITEM (drawable));
      TempBuf   *buf;

      if (gimage->gimp->config->layer_previews)
        buf = gimp_drawable_get_sub_preview (drawable,
                                             src_x, src_y,
                                             src_width, src_height,
                                             dest_width, dest_height);
      else
        buf = gimp_viewable_get_dummy_preview (GIMP_VIEWABLE (drawable),
                                               dest_width, dest_height,
                                               gimp_drawable_has_alpha (drawable) ?
                                               4 : 3);

      if (buf)
        {
          num_bytes      = buf->height * buf->width * buf->bytes;
          thumbnail_data = g_memdup (temp_buf_data (buf), num_bytes);
          width          = buf->width;
          height         = buf->height;
          bpp            = buf->bytes;

          temp_buf_free (buf);
        }
      else
        {
          success = FALSE;
        }
    }
}
CODE
    );
}

sub drawable_offset {
    $blurb = <<'BLURB';
Offset the drawable by the specified amounts in the X and Y directions
BLURB

    $help = <<'HELP';
This procedure offsets the specified drawable by the amounts specified by
'offset_x' and 'offset_y'. If 'wrap_around' is set to TRUE, then portions of
the drawable which are offset out of bounds are wrapped around. Alternatively,
the undefined regions of the drawable can be filled with transparency or the
background color, as specified by the 'fill_type' parameter.
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = (
	{ name => 'drawable', type => 'drawable',
	  desc => 'The drawable to offset' },
	{ name => 'wrap_around', type => 'boolean',
	  desc => 'wrap image around or fill vacated regions' },
	{ name => 'fill_type', type => 'enum GimpOffsetType',
	  desc => 'fill vacated regions of drawable with background or
		   transparent: %%desc%%' },
	{ name => 'offset_x', type => 'int32',
	  desc => 'offset by this amount in X direction' },
	{ name => 'offset_y', type => 'int32',
	  desc => 'offset by this amount in Y direction' }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gimp_item_is_attached (GIMP_ITEM (drawable));

  if (success)
    gimp_drawable_offset (drawable, context, wrap_around, fill_type,
                          offset_x, offset_y);
}
CODE
    );
}

sub drawable_delete {
    $blurb = 'Delete a drawable.';

    $help = <<'HELP';
This procedure deletes the specified drawable. This must not be done if the
gimage containing this drawable was already deleted or if the drawable was
already removed from the image. The only case in which this procedure is
useful is if you want to get rid of a drawable which has not yet been
added to an image.
HELP

    &std_pdb_misc;

    @inargs = ( &drawable_arg );
    $inargs[0]->{desc} .= ' to delete';

    %invoke = ( code => <<'CODE' );
{
  success = gimp_item_is_floating (GIMP_ITEM (drawable));

  if (success)
    gimp_item_sink (GIMP_ITEM (drawable));
}
CODE
}

sub drawable_foreground_extract {
    $blurb = 'Extract the foreground of a drawable using a given trimap.';

    $help = <<'HELP';
Image Segmentation by Uniform Color Clustering, see
http://www.inf.fu-berlin.de/inst/pubs/tr-b-05-07.pdf
HELP

    $author    = 'Gerald Friedland <fland@inf.fu-berlin.de>, Kristian Jantz <jantz@inf.fu-berlin.de>, Sven Neumann <sven@gimp.org>';
    $copyright = 'Gerald Friedland';
    $date      = '2005';
    $since     = '2.4';

    @inargs = (
	&drawable_arg,
        { name => 'mode', type => 'enum GimpForegroundExtractMode',
	  desc => 'The algorithm to use: %%desc%%' },
        { name => 'mask', type => 'drawable', desc => 'Tri-Map' }
    );

    %invoke = ( headers => [ qw("core/gimpdrawable-foreground-extract.h") ],
        code    => <<'CODE'
{
  success = gimp_item_is_attached (GIMP_ITEM (drawable));

  if (success)
    gimp_drawable_foreground_extract (drawable, mode, mask, progress);
}
CODE
    );
}


@headers = qw("base/tile.h" "base/tile-manager.h" "base/temp-buf.h"
              "config/gimpcoreconfig.h"
              "core/gimp.h" "core/gimplayer.h" "core/gimplayermask.h"
              "core/gimpdrawable-offset.h" "gimp-intl.h");

@procs = qw(drawable_delete
            drawable_is_layer drawable_is_layer_mask drawable_is_channel
	    drawable_type  drawable_type_with_alpha drawable_has_alpha
            drawable_is_rgb drawable_is_gray drawable_is_indexed
            drawable_bpp drawable_width drawable_height drawable_offsets
            drawable_get_image drawable_set_image
            drawable_get_name drawable_set_name
            drawable_get_visible drawable_set_visible
            drawable_get_linked drawable_set_linked
            drawable_get_tattoo drawable_set_tattoo
            drawable_mask_bounds drawable_mask_intersect
            drawable_merge_shadow drawable_update
            drawable_get_pixel drawable_set_pixel
	    drawable_fill drawable_offset
            drawable_thumbnail drawable_sub_thumbnail
            drawable_foreground_extract);
%exports = (app => [@procs], lib => [@procs]);

$desc = 'Drawable procedures';

1;
