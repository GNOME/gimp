# The GIMP -- an image manipulation program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

sub pdb_misc {
    $author = $copyright = 'Andy Thomas';
    $date = '1998';
}

sub sample_size_arg {{
    name => 'sample_size',
    type => '0 < int32 <= 10000',
    desc => 'Size of the sample to return when the gradient is changed
	    (%%desc%%)',
    on_fail => 'sample_size = GRADIENT_SAMPLE_SIZE;',
    no_success => 1
}}

sub gradients_popup {
    $blurb = 'Invokes the Gimp gradients selection.';

    $help = 'This procedure popups the gradients selection dialog.';

    &pdb_misc;

    @inargs = (
	{ name => 'gradients_callback', type => 'string', alias => 'name',
	  desc => 'The callback PDB proc to call when gradient selection is
		   made' },
	{ name => 'popup_title', type => 'string', alias => 'title',
	  desc => 'Title to give the gradient popup window' },
	{ name => 'initial_gradient', type => 'string',
	  desc => 'The name of the pattern to set as the first selected',
	  no_success => 1 },
	&sample_size_arg
    );

    %invoke = (
	vars => [ 'ProcRecord *prec', 'GradientSelect *newdialog' ],
	code => <<'CODE'
{
  if ((prec = procedural_db_lookup (name)))
    {
      if (initial_gradient && strlen (initial_gradient))
	newdialog = gradient_select_new (title, initial_gradient);
      else
	newdialog = gradient_select_new (title, NULL);

      newdialog->callback_name = g_strdup (name);
      newdialog->sample_size   = sample_size;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub gradients_close_popup {
    $blurb = 'Popdown the Gimp gradient selection.';

    $help = 'This procedure closes an opened gradient selection dialog.';

    &pdb_misc;

    @inargs = (
	{ name => 'gradients_callback', type => 'string', alias => 'name',
	  desc => 'The name of the callback registered for this popup' }
    );

    %invoke = (
	vars => [ 'ProcRecord *prec', 'GradientSelect *gsp' ],
	code => <<'CODE'
{
  if ((prec = procedural_db_lookup (name)) &&
      (gsp = gradients_get_gradientselect (name)))
    {
      if (GTK_WIDGET_VISIBLE (gsp->shell))
	gtk_widget_hide (gsp->shell);

      /* Free memory if poping down dialog which is not the main one */
      if (gsp != gradient_select_dialog)
	{
	  /* Send data back */
	  gtk_widget_destroy (gsp->shell);
	  gradient_select_free (gsp);
	}
    }
  else
    success = FALSE;
}
CODE
    );
}

sub gradients_set_popup {
    $blurb = 'Sets the current gradient selection in a popup.';

    $help = $blurb;

    &pdb_misc;

    @inargs = (
	{ name => 'gradients_callback', type => 'string', alias => 'pdbname',
	  desc => 'The name of the callback registered for this popup' },
	{ name => 'gradient_name', type => 'string',
	  desc => 'The name of the gradient to set as selected' }
    );

    %invoke = (
	vars => [ 'ProcRecord *prec', 'GradientSelect *gsp' ],
	code => <<'CODE'
{
  if ((prec = procedural_db_lookup (pdbname)) &&
      (gsp = gradients_get_gradientselect (pdbname)))
    {
      GSList *list;
      gradient_t *active = NULL;

      for (list = gradients_list; list; list = g_slist_next (list))
 	{
	  active = (gradient_t *) list->data;

	  if (!strcmp (gradient_name, active->name))
	    break; /* We found the one we want */
	}

      if (active)
        {
	  gimp_context_set_gradient (gsp->context, active);
	}
      else
	success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub gradients_get_gradient_data {
    $blurb = <<'BLURB';
Retrieve information about the specified gradient (including data).
BLURB

    $help = <<'HELP';
This procedure retrieves information about the gradient. This includes the
gradient name, and the sample data for the gradient.
HELP

    &pdb_misc;

    @inargs = (
	{ name => 'name', type => 'string',
	  desc => 'The gradient name ("" means current active gradient)' },
	&sample_size_arg
    );

    @outargs = (
	{ name => 'name', type => 'string',
	  desc => 'The gradient name',
	  alias => 'g_strdup (gradient->name)', no_declare => 1 },
	{ name => 'grad_data', type => 'floatarray', alias => 'values',
	  desc => 'The gradient sample data', init => 1,
	  array => { name => 'width',
		     desc => 'The gradient sample width (r,g,b,a)',
		     alias => 'sample_size * 4', no_declare => 1 } }
    );

    %invoke = (
	vars => [ 'gradient_t *gradient = NULL' ],
	code => <<'CODE'
{
  if (strlen (name))
    {
      GSList *list;

      success = FALSE;

      for (list = gradients_list; list; list = g_slist_next (list))
	{
	  gradient = (gradient_t *) list->data;

	  if (!strcmp (gradient->name, name))
	    {
	      success = TRUE;
	      break;      /* We found it! */
	    }
	}
    }
  else
    success = (gradient = gimp_context_get_gradient (NULL)) != NULL;

  if (success)
    {
      gdouble *pv;
      gdouble pos, delta;
      gdouble r, g, b, a;
      int i = sample_size;

      pos = 0.0;
      delta = 1.0 / (i - 1);

      pv = values = g_new (gdouble, i * 4);

      while (i--)
	{
	  gradient_get_color_at (gradient, pos, &r, &g, &b, &a);

	  *pv++ = r;
	  *pv++ = g;
	  *pv++ = b;
	  *pv++ = a;

	  pos += delta;
	}
    }
}
CODE
    );
}

@headers = qw(<string.h> "gimpcontext.h" "gradient_header.h" "gradient_select.h");

$extra{app}->{code} = <<'CODE';
static GradientSelect *
gradients_get_gradientselect (gchar *name)
{
  GSList *list;
  GradientSelect *gsp;

  for (list = gradient_active_dialogs; list; list = g_slist_next (list))
    {
      gsp = (GradientSelect *) list->data;
      
      if (gsp->callback_name && !strcmp (name, gsp->callback_name))
	return gsp;
    }

  return NULL;
}
CODE

@procs = qw(gradients_popup gradients_close_popup gradients_set_popup
	    gradients_get_gradient_data);
%exports = (app => [@procs], lib => [@procs]);

$desc = 'Gradient UI';

1;
