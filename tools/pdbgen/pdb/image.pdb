# GIMP - The GNU Image Manipulation Program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>

sub image_is_valid {
    $blurb = 'Returns TRUE if the image is valid.';

    $help = <<'HELP';
This procedure checks if the given image ID is valid and refers to an
existing image.
HELP

    &neo_pdb_misc('2007', '2.4');

    @inargs = (
	{ name => 'image', type => 'image', no_validate => 1,
	  desc => 'The image to check' }
    );

    @outargs = (
	{ name => 'valid', type => 'boolean',
	  desc => 'Whether the image ID is valid' }
    );

    %invoke = (
	code => <<'CODE'
{
  valid = GIMP_IS_IMAGE (image);
}
CODE
    );
}

sub image_list {
    $blurb = 'Returns the list of images currently open.';

    $help = <<'HELP';
This procedure returns the list of images currently open in GIMP.
HELP

    &std_pdb_misc;

    @outargs = (
	{ name => 'image_ids', type => 'int32array',
	  desc => 'The list of images currently open',
	  array => { name => 'num_images',
		     desc => 'The number of images currently open' } }
    );

    %invoke = (
	code => <<CODE
{
  GList *list = gimp_get_image_iter (gimp);

  num_images = g_list_length (list);

  if (num_images)
    {
      gint i;

      image_ids = g_new (gint32, num_images);

      for (i = 0; i < num_images; i++, list = g_list_next (list))
	image_ids[i] = gimp_image_get_ID (GIMP_IMAGE (list->data));
    }
}
CODE
    );
}

sub image_new {
    $blurb = 'Creates a new image with the specified width, height, and type.';

    $help = <<'HELP';
Creates a new image, undisplayed with the specified extents and
type. A layer should be created and added before this image is
displayed, or subsequent calls to gimp_display_new() with this image
as an argument will fail. Layers can be created using the
gimp_layer_new() commands. They can be added to an image using the
gimp_image_add_layer() command.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'width', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
	  desc => 'The width of the image' },
	{ name => 'height', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
	  desc => 'The height of the image' },
	{ name => 'type', type => 'enum GimpImageBaseType',
	  desc => 'The type of image' }
    );

    @outargs = (
	{ name => 'image', type => 'image',
	  desc => 'The ID of the newly created image' }
    );

    %invoke = (
	code => <<'CODE'
{
  image = gimp_create_image (gimp, width, height, type, FALSE);

  if (! image)
    success = FALSE;
}
CODE
    );
}

sub image_duplicate {
    $blurb = 'Duplicate the specified image';

    $help = <<'HELP';
This procedure duplicates the specified image, copying all layers, channels,
and image information.
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'new_image', type => 'image',
	  desc => 'The new, duplicated image' }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-duplicate.h") ],
        code => <<'CODE'
{
  new_image = gimp_image_duplicate (image);

  if (! new_image)
    success = FALSE;
}
CODE
    );
}

sub image_delete {
    $blurb = 'Delete the specified image.';

    $help = <<'HELP';
If there are no displays associated with this image it will be deleted.
This means that you can not delete an image through the PDB that was
created by the user. If the associated display was however created
through the PDB and you know the display ID, you may delete the display.
Removal of the last associated display will then delete the image.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_image_get_display_count (image) == 0)
    g_object_unref (image);
  else
    success = FALSE;
}
CODE
    );
}

sub image_resize {
    $blurb = 'Resize the image to the specified extents.';

    $help = <<'HELP';
This procedure resizes the image so that it's new width and height are
equal to the supplied parameters. Offsets are also provided which
describe the position of the previous image's content. All channels
within the image are resized according to the specified parameters;
this includes the image selection mask. All layers within the image
are repositioned according to the specified offsets.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'new_width', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
	  desc => 'New image width' },
	{ name => 'new_height', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
	  desc => 'New image height' },
	{ name => 'offx', type => 'int32',
	  desc => 'x offset between upper left corner of old and
		   new images: (new - old)' },
	{ name => 'offy', type => 'int32',
	  desc => 'y offset between upper left corner of old and
		   new images: (new - old)' }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-resize.h") ],
	code => <<'CODE'
{
  gimp_image_resize (image, context,
                     new_width, new_height, offx, offy, NULL);
}
CODE
    );
}

sub image_resize_to_layers {
    $blurb = 'Resize the image to fit all layers.';

    $help = <<'HELP';
This procedure resizes the image to the bounding box of all layers of
the image. All channels within the image are resized to the new size;
this includes the image selection mask. All layers within the image
are repositioned to the new image area.
HELP

    &simon_pdb_misc('2004', '2.2');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-resize.h") ],
	code => <<'CODE'
{
  gimp_image_resize_to_layers (image, context, NULL);
}
CODE
    );
}

sub image_scale {
    $blurb = 'Scale the image using the default interpolation method.';

    $help = <<'HELP';

This procedure scales the image so that its new width and height are
equal to the supplied parameters. All layers and channels within the
image are scaled according to the specified parameters; this includes
the image selection mask. The default interpolation method is used.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'new_width', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
	  desc => 'New image width' },
	{ name => 'new_height', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
	  desc => 'New image height' }
    );

    %invoke = (
	headers => [ qw("config/gimpcoreconfig.h" "core/gimpimage-scale.h") ],
	code => <<'CODE'
{
  if (progress)
    gimp_progress_start (progress, _("Scaling"), FALSE);

  gimp_image_scale (image, new_width, new_height,
                    gimp->config->interpolation_type,
                    progress);

  if (progress)
    gimp_progress_end (progress);
}
CODE
    );
}

sub image_scale_full {
    $blurb = 'Scale the image using a specific interpolation method.';

    $help = <<'HELP';
This procedure scales the image so that its new width and height are
equal to the supplied parameters. All layers and channels within the
image are scaled according to the specified parameters; this includes
the image selection mask. This procedure allows you to specify the
interpolation method explicitly.
HELP

    &neo_pdb_misc('2008', '2.6');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'new_width', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
	  desc => 'New image width' },
	{ name => 'new_height', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
	  desc => 'New image height' },
	{ name => 'interpolation', type => 'enum GimpInterpolationType',
	  desc => 'Type of interpolation' }
    );

    %invoke = (
	headers => [ qw("config/gimpcoreconfig.h" "core/gimpimage-scale.h") ],
	code => <<'CODE'
{
  if (progress)
    gimp_progress_start (progress, _("Scaling"), FALSE);

  gimp_image_scale (image, new_width, new_height, interpolation, progress);

  if (progress)
    gimp_progress_end (progress);
}
CODE
    );
}

sub image_crop {
    $blurb = 'Crop the image to the specified extents.';

    $help = <<'HELP';
This procedure crops the image so that it's new width and height are
equal to the supplied parameters. Offsets are also provided which
describe the position of the previous image's content. All channels
and layers within the image are cropped to the new image extents; this
includes the image selection mask. If any parameters are out of range,
an error is returned.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'new_width', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
	  desc => 'New image width: (0 < new_width <= width)' },
	{ name => 'new_height', type => '1 <= int32 <= GIMP_MAX_IMAGE_SIZE',
	  desc => 'New image height: (0 < new_height <= height)' },
	{ name => 'offx', type => '0 <= int32',
	  desc => 'X offset: (0 <= offx <= (width - new_width))' },
	{ name => 'offy', type => '0 <= int32',
	  desc => 'Y offset: (0 <= offy <= (height - new_height))' }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-crop.h") ],
	code => <<'CODE'
{
  if (new_width  >  gimp_image_get_width  (image)              ||
      new_height >  gimp_image_get_height (image)              ||
      offx       > (gimp_image_get_width  (image) - new_width) ||
      offy       > (gimp_image_get_height (image) - new_height))
    success = FALSE;
  else
    gimp_image_crop (image, context,
                     offx, offy, offx + new_width, offy + new_height,
		     FALSE, TRUE);
}
CODE
    );
}

sub image_flip {
    $blurb = 'Flips the image horizontally or vertically.';

    $help = <<'HELP';
This procedure flips (mirrors) the image.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'flip_type',
	  type => 'enum GimpOrientationType (no GIMP_ORIENTATION_UNKNOWN)',
	  desc => 'Type of flip' }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-flip.h") ],
	code => <<'CODE'
{
  gimp_image_flip (image, context, flip_type, NULL);
}
CODE
    );
}

sub image_rotate {
    $blurb = 'Rotates the image by the specified degrees.';
    $help = 'This procedure rotates the image.';

    &mitch_pdb_misc('2003');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'rotate_type', type => 'enum GimpRotationType',
	  desc => 'Angle of rotation' }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-rotate.h") ],
	code => <<'CODE'
{
  if (progress)
    gimp_progress_start (progress, _("Rotating"), FALSE);

  gimp_image_rotate (image, context, rotate_type, progress);

  if (progress)
    gimp_progress_end (progress);
}
CODE
    );
}

sub image_free_shadow {
    &std_pdb_deprecated ('gimp-drawable-free-shadow');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    %invoke = (
	code => <<'CODE'
{
}
CODE
    );
}

sub image_get_layers {
    $blurb = 'Returns the list of layers contained in the specified image.';

    $help = <<HELP;
This procedure returns the list of layers contained in the specified image.
The order of layers is from topmost to bottommost.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'layer_ids', type => 'int32array',
	  desc => 'The list of layers contained in the image',
	  array => { name => 'num_layers',
		     desc => 'The number of layers contained in the image' } }
    );

    %invoke = (
	code => <<'CODE'
{
  GList *list = gimp_image_get_layer_iter (image);

  num_layers = g_list_length (list);

  if (num_layers)
    {
      gint i;

      layer_ids = g_new (gint32, num_layers);

      for (i = 0; i < num_layers; i++, list = g_list_next (list))
	layer_ids[i] = gimp_item_get_ID (GIMP_ITEM (list->data));
    }
}
CODE
    );
}

sub image_get_channels {
    $blurb = 'Returns the list of channels contained in the specified image.';

    $help = <<HELP;
This procedure returns the list of channels contained in the specified image.
This does not include the selection mask, or layer masks. The order is from
topmost to bottommost.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'channel_ids', type => 'int32array',
	  desc => 'The list of channels contained in the image',
	  array => { name => 'num_channels',
		     desc => 'The number of channels contained in the image' } }
    );

    %invoke = (
	code => <<'CODE'
{
  GList *list = gimp_image_get_channel_iter (image);

  num_channels = g_list_length (list);

  if (num_channels)
    {
      gint i;

      channel_ids = g_new (gint32, num_channels);

      for (i = 0; i < num_channels; i++, list = g_list_next (list))
	channel_ids[i] = gimp_item_get_ID (GIMP_ITEM (list->data));
    }
}
CODE
    );
}

sub image_get_vectors {
    $blurb = 'Returns the list of vectors contained in the specified image.';

    $help = <<HELP;
This procedure returns the list of vectors contained in the specified image.
HELP

    &simon_pdb_misc('2005', '2.4');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'vector_ids', type => 'int32array',
	  desc => 'The list of vectors contained in the image',
	  array => { name => 'num_vectors',
		     desc => 'The number of vectors contained in the image' } }
    );

    %invoke = (
	code => <<'CODE'
{
  GList *list = gimp_image_get_vectors_iter (image);

  num_vectors = g_list_length (list);

  if (num_vectors)
    {
      gint i;

      vector_ids = g_new (gint32, num_vectors);

      for (i = 0; i < num_vectors; i++, list = g_list_next (list))
	vector_ids[i] = gimp_item_get_ID (GIMP_ITEM (list->data));
    }
}
CODE
    );
}

sub image_unset_active_channel {
    $blurb = 'Unsets the active channel in the specified image.';

    $help = <<'HELP';
If an active channel exists, it is unset. There then exists no active
channel, and if desired, one can be set through a call to 'Set Active
Channel'. No error is returned in the case of no existing active
channel.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    %invoke = (
	code => <<'CODE'
{
  gimp_image_unset_active_channel (image);
}
CODE
    );
}

sub image_pick_color {
    $blurb = <<'BLURB';
Determine the color at the given drawable coordinates
BLURB

    $help = <<'HELP';
This tool determines the color at the specified coordinates. The
returned color is an RGB triplet even for grayscale and indexed
drawables. If the coordinates lie outside of the extents of the
specified drawable, then an error is returned. If the drawable has an
alpha channel, the algorithm examines the alpha value of the drawable
at the coordinates. If the alpha value is completely transparent (0),
then an error is returned. If the sample_merged parameter is TRUE,
the data of the composite image will be used instead of that for the
specified drawable. This is equivalent to sampling for colors after
merging all visible layers. In the case of a merged sampling, the
supplied drawable is ignored.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'drawable', type => 'drawable', none_ok => 1,
          desc => 'The drawable to pick from' },
	{ name => 'x', type => 'float',
	  desc => 'x coordinate of upper-left corner of rectangle' },
	{ name => 'y', type => 'float',
	  desc => 'y coordinate of upper-left corner of rectangle' },
	{ name => 'sample_merged', type => 'boolean',
          desc => 'Use the composite image, not the drawable' },
	{ name => 'sample_average', type => 'boolean',
	  desc => 'Average the color of all the pixels in a specified
		   radius' },
	{ name => 'average_radius', type => '0 < float', no_validate => 1,
	  desc => 'The radius of pixels to average' }
    );

    @outargs = (
	{ name => 'color', type => 'color', has_alpha => 1, void_ret => 1,
	  desc => 'The return color' }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-pick-color.h" "core/gimppickable.h") ],
	code => <<'CODE'
{
  if (!sample_merged)
    if (!drawable || (gimp_item_get_image (GIMP_ITEM (drawable)) != image))
      success = FALSE;

  if (success && sample_average)
    {
      if (average_radius <= 0.0)
        success = FALSE;
    }

  if (success)
    {
      if (sample_merged)
        gimp_pickable_flush (GIMP_PICKABLE (gimp_image_get_projection (image)));
      else
        gimp_pickable_flush (GIMP_PICKABLE (drawable));

      success = gimp_image_pick_color (image,
                                       drawable,
                                       (gint) x, (gint) y,
                                       sample_merged,
                                       sample_average,
                                       average_radius,
                                       NULL,
                                       &color,
                                       NULL);
    }
}
CODE
    );
}

sub image_pick_correlate_layer {
    $blurb = 'Find the layer visible at the specified coordinates.';

    $help = <<'HELP';
This procedure finds the layer which is visible at the specified
coordinates.  Layers which do not qualify are those whose extents do
not pass within the specified coordinates, or which are transparent at
the specified coordinates.  This procedure will return -1 if no layer
is found.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'x', type => 'int32',
	  desc => 'The x coordinate for the pick' },
	{ name => 'y', type => 'int32',
	  desc => 'The y coordinate for the pick' }
    );

    @outargs = (
	{ name => 'layer', type => 'layer',
	  desc => 'The layer found at the specified coordinates' }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-pick-layer.h") ],
	code => <<'CODE'
{
  layer = gimp_image_pick_layer (image, x, y);
}
CODE
    );
}

sub image_get_layer_position {
    $blurb = 'Returns the position of the layer in the layer stack.';

    $help = <<'HELP';
This procedure determines the position of the specified layer in the
images layer stack. If the layer doesn't exist in the image, an error
is returned.
HELP

    &simon_pdb_misc('2006', '2.4');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'layer', type => 'layer',
	  desc => 'The layer' }
    );

    @outargs = (
	{ name => 'position', type => 'int32',
	  desc => "The position of the layer in the layer stack" }
    );


    %invoke = (
	code => <<'CODE'
{
  GimpContainer *container = gimp_image_get_layers (image);

  position = gimp_container_get_child_index (container,
                                             GIMP_OBJECT (layer));
  if (position < 0)
    success = FALSE;
}
CODE
    );
}

sub image_raise_layer {
    $blurb = "Raise the specified layer in the image's layer stack";

    $help = <<'HELP';
This procedure raises the specified layer one step in the existing layer stack.
The procecure call will fail if there is no layer above it.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'layer', type => 'layer',
	  desc => 'The layer to raise' }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gimp_image_raise_layer (image, layer, error);
}
CODE
    );
}

sub image_lower_layer {
    $blurb = "Lower the specified layer in the image's layer stack";

    $help = <<'HELP';
This procedure lowers the specified layer one step in the existing layer stack.
The procecure call will fail if there is no layer below it.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'layer', type => 'layer',
	  desc => 'The layer to lower' }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gimp_image_lower_layer (image, layer, error);
}
CODE
    );
}

sub image_raise_layer_to_top {
    $blurb = <<'BLURB';
Raise the specified layer in the image's layer stack to top of stack
BLURB

    $help = <<'HELP';
This procedure raises the specified layer to top of the existing layer stack.
It will not move the layer if there is no layer above it.
HELP

    &wolfgang_pdb_misc('1998');
    $author .= ", Sven Neumann";

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'layer', type => 'layer',
	  desc => 'The layer to raise to top' }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gimp_image_raise_layer_to_top (image, layer);
}
CODE
    );
}

sub image_lower_layer_to_bottom {
    $blurb = <<'BLURB';
Lower the specified layer in the image's layer stack to bottom of stack
BLURB

    $help = <<'HELP';
This procedure lowers the specified layer to bottom of the existing layer stack.
It will not move the layer if there is no layer below it.
HELP

    &wolfgang_pdb_misc('1998');
    $author .= ", Sven Neumann";

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'layer', type => 'layer',
	  desc => 'The layer to lower to bottom' }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gimp_image_lower_layer_to_bottom (image, layer);
}
CODE
    );
}

sub image_merge_visible_layers {
    $blurb = 'Merge the visible image layers into one.';

    $help = <<'HELP';
This procedure combines the visible layers into a single layer using
the specified merge type. A merge type of EXPAND_AS_NECESSARY expands
the final layer to encompass the areas of the visible layers. A merge
type of CLIP_TO_IMAGE clips the final layer to the extents of the
image. A merge type of CLIP_TO_BOTTOM_LAYER clips the final layer to
the size of the bottommost layer.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'merge_type',
	  type => 'enum GimpMergeType (no GIMP_FLATTEN_IMAGE)',
	  desc => 'The type of merge' }
    );

    @outargs = (
	{ name => 'layer', type => 'layer',
	  desc => 'The resulting layer' }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-merge.h") ],
	code => <<'CODE'
{
  layer = gimp_image_merge_visible_layers (image, context, merge_type, FALSE);

  if (! layer)
    success = FALSE;
}
CODE
    );
}

sub image_merge_down {
    $blurb = 'Merge the layer passed and the first visible layer below.';

    $help = <<'HELP';
This procedure combines the passed layer and the first visible layer
below it using the specified merge type. A merge type of
EXPAND_AS_NECESSARY expands the final layer to encompass the areas of
the visible layers. A merge type of CLIP_TO_IMAGE clips the final
layer to the extents of the image. A merge type of
CLIP_TO_BOTTOM_LAYER clips the final layer to the size of the
bottommost layer.
HELP

    &larry_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'merge_layer', type => 'layer',
	  desc => 'The layer to merge down from' },
	{ name => 'merge_type',
	  type => 'enum GimpMergeType (no GIMP_FLATTEN_IMAGE)',
	  desc => 'The type of merge' }
    );

    @outargs = (
	{ name => 'layer', type => 'layer',
	  desc => 'The resulting layer' }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-merge.h") ],
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (merge_layer), FALSE, error))
    {
      layer = gimp_image_merge_down (image, merge_layer, context, merge_type,
                                     error);

      if (! layer)
        success = FALSE;
    }
  else
    success = FALSE;
}
CODE
    );
}

sub image_flatten {
    $blurb = <<'BLURB';
Flatten all visible layers into a single layer. Discard all invisible layers.
BLURB

    $help = <<'HELP';
This procedure combines the visible layers in a manner analogous to merging
with the CLIP_TO_IMAGE merge type. Non-visible layers are discarded, and the
resulting image is stripped of its alpha channel.
HELP

    &std_pdb_misc;

    @inargs = (
 	{ name => 'image', type => 'image',
	  desc => 'The image' }
   );

    @outargs = (
	{ name => 'layer', type => 'layer',
	  desc => 'The resulting layer' }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-merge.h") ],
	code => <<'CODE'
{
  layer = gimp_image_flatten (image, context);

  if (! layer)
    success = FALSE;
}
CODE
    );
}

sub image_add_layer {
    $blurb = 'Add the specified layer to the image.';

    $help = <<'HELP';
This procedure adds the specified layer to the image at the given position.
If the position is specified as -1, then the layer is inserted above the
active layer. The layer type must be compatible with the image base type.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'layer', type => 'layer',
	  desc => 'The layer' },
	{ name => 'position', type => 'int32',
	  desc => 'The layer position' }
    );

    $invoke{code} = <<'CODE';
{
  if (gimp_pdb_item_is_floating (GIMP_ITEM (layer), image, error) &&
      gimp_pdb_image_is_base_type (image,
				   GIMP_IMAGE_TYPE_BASE_TYPE (gimp_drawable_type (GIMP_DRAWABLE (layer))),
				   error))
    {
      /* FIXME tree */
      success = gimp_image_add_layer (image, layer,
                                      NULL, MAX (position, -1), TRUE);
    }
  else
    {
      success = FALSE;
    }
}
CODE
}

sub image_remove_layer {
    $blurb = 'Remove the specified layer from the image.';

    $help = <<'HELP';
This procedure removes the specified layer from the image. If the
layer doesn't exist, an error is returned. If there are no layers left
in the image, this call will fail. If this layer is the last layer
remaining, the image will become empty and have no active layer.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'layer', type => 'layer',
	  desc => 'The layer' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (layer), FALSE, error))
    gimp_image_remove_layer (image, layer, TRUE, NULL);
  else
    success = FALSE;
}
CODE
    );
}

sub image_add_layer_mask {
    &std_pdb_deprecated ('gimp-layer-add-mask');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'layer', type => 'layer',
	  desc => 'The layer to receive the mask' },
	{ name => 'mask', type => 'layer_mask',
	  desc => 'The mask to add to the layer' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_floating (GIMP_ITEM (mask), image, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (layer), error))
    success = (gimp_layer_add_mask (layer, mask, TRUE, error) == mask);
  else
    success = FALSE;
}
CODE
    );
}

sub image_remove_layer_mask {
    &std_pdb_deprecated ('gimp-layer-remove-mask');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'layer', type => 'layer',
	  desc => 'The layer from which to remove mask' },
	{ name => 'mode', type => 'enum GimpMaskApplyMode',
	  desc => 'Removal mode' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (layer), mode == GIMP_MASK_APPLY, error) &&
      gimp_layer_get_mask (layer))
    gimp_layer_apply_mask (layer, mode, TRUE);
  else
    success = FALSE;
}
CODE
    );
}

sub image_get_channel_position {
    $blurb = 'Returns the position of the channel in the channel stack.';

    $help = <<'HELP';
This procedure determines the position of the specified channel in
the images channel stack. If the channel doesn't exist in the image,
an error is returned.
HELP

    &simon_pdb_misc('2006', '2.4');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'channel', type => 'channel',
	  desc => 'The channel' }
    );

    @outargs = (
	{ name => 'position', type => 'int32',
	  desc => "The position of the channel in the channel stack" }
    );


    %invoke = (
	code => <<'CODE'
{
  GimpContainer *container = gimp_image_get_channels (image);

  position = gimp_container_get_child_index (container,
                                             GIMP_OBJECT (channel));
  if (position < 0)
    success = FALSE;
}
CODE
    );
}

sub image_raise_channel {
    $blurb = "Raise the specified channel in the image's channel stack";

    $help = <<'HELP';
This procedure raises the specified channel one step in the existing
channel stack. The procecure call will fail if there is no channel
above it.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'channel', type => 'channel',
	  desc => 'The channel to raise' }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gimp_image_raise_channel (image, channel, error);
}
CODE
    );
}

sub image_lower_channel {
    $blurb = "Lower the specified channel in the image's channel stack";

    $help = <<'HELP';
This procedure lowers the specified channel one step in the existing
channel stack. The procecure call will fail if there is no channel
below it.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'channel', type => 'channel',
	  desc => 'The channel to lower' }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gimp_image_lower_channel (image, channel, error);
}
CODE
    );
}

sub image_add_channel {
    $blurb = 'Add the specified channel to the image.';

    $help = <<'HELP';
This procedure adds the specified channel to the image at the given position.
If the position is specified as -1, then the channel is inserted above the
active channel or, if no channel is active, at the top of the channel stack.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'channel', type => 'channel',
	  desc => 'The channel' },
	{ name => 'position', type => 'int32',
	  desc => 'The channel position' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_floating (GIMP_ITEM (channel), image, error))
    {
      /* FIXME tree */
      success = gimp_image_add_channel (image, channel,
                                        NULL, MAX (position, -1), TRUE);
    }
  else
    {
      success = FALSE;
    }
}
CODE
    );
}

sub image_remove_channel {
    $blurb = 'Remove the specified channel from the image.';

    $help = <<'HELP';
This procedure removes the specified channel from the image. If the channel
doesn't exist, an error is returned.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'channel', type => 'channel',
	  desc => 'The channel' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (channel), FALSE, error))
    gimp_image_remove_channel (image, channel, TRUE, NULL);
  else
    success = FALSE;
}
CODE
    );
}

sub image_add_vectors {
    $blurb = 'Add the specified vectors object to the image.';

    $help = <<'HELP';
This procedure adds the specified vectors object to the image at the given
position. If the position is specified as -1, then the vectors object is
inserted at the top of the vectors stack.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'vectors', type => 'vectors',
	  desc => 'The vectors object' },
	{ name => 'position', type => 'int32',
	  desc => 'The vectors objects position' }
    );

    $invoke{code} = <<'CODE';
{
  if (gimp_pdb_item_is_floating (GIMP_ITEM (vectors), image, error))
    {
      /* FIXME tree */
      success = gimp_image_add_vectors (image, vectors,
                                        NULL, MAX (position, -1), TRUE);
    }
  else
    {
      success = FALSE;
    }
}
CODE
}

sub image_remove_vectors {
    $blurb = 'Remove the specified path from the image.';

    $help = <<'HELP';
This procedure removes the specified path from the image. If the path
doesn't exist, an error is returned.
HELP

    &simon_pdb_misc('2005', '2.4');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'vectors', type => 'vectors',
	  desc => 'The vectors object' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (vectors), FALSE, error))
    gimp_image_remove_vectors (image, vectors, TRUE, NULL);
  else
    success = FALSE;
}
CODE
    );
}

sub image_get_vectors_position {
    $blurb = 'Returns the position of the vectors object in the vectors objects stack.';

    $help = <<'HELP';
This procedure determines the position of the specified vectors object in the
images vectors object stack. If the vectors object doesn't exist in the image,
an error is returned.
HELP

    &simon_pdb_misc('2006', '2.4');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'vectors', type => 'vectors',
	  desc => 'The vectors object' }
    );

    @outargs = (
	{ name => 'position', type => 'int32',
	  desc => "The position of the vectors object in the vectors stack" }
    );


    %invoke = (
	code => <<'CODE'
{
  GimpContainer *container = gimp_image_get_vectors (image);

  position = gimp_container_get_child_index (container,
                                             GIMP_OBJECT (vectors));
  if (position < 0)
    success = FALSE;
}
CODE
    );
}

sub image_raise_vectors {
    $blurb = "Raise the specified vectors in the image's vectors stack";

    $help = <<'HELP';
This procedure raises the specified vectors one step in the existing
vectors stack. The procecure call will fail if there is no vectors
above it.
HELP

    &simon_pdb_misc('2005', '2.4');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'vectors', type => 'vectors',
	  desc => 'The vectors object to raise' }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gimp_image_raise_vectors (image, vectors, error);
}
CODE
    );
}

sub image_lower_vectors {
    $blurb = "Lower the specified vectors in the image's vectors stack";

    $help = <<'HELP';
This procedure lowers the specified vectors one step in the existing
vectors stack. The procecure call will fail if there is no vectors
below it.
HELP

    &simon_pdb_misc('2005', '2.4');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'vectors', type => 'vectors',
	  desc => 'The vectors object to lower' }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gimp_image_lower_vectors (image, vectors, error);
}
CODE
    );
}

sub image_raise_vectors_to_top {
    $blurb = <<'BLURB';
Raise the specified vectors in the image's vectors stack to top of stack
BLURB

    $help = <<'HELP';
This procedure raises the specified vectors to top of the existing
vectors stack. It will not move the vectors if there is no vectors
above it.
HELP

    &simon_pdb_misc('2005', '2.4');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'vectors', type => 'vectors',
	  desc => 'The vectors object to raise to top' }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gimp_image_raise_vectors_to_top (image, vectors);
}
CODE
    );
}

sub image_lower_vectors_to_bottom {
    $blurb = <<'BLURB';
Lower the specified vectors in the image's vectors stack to bottom of stack
BLURB

    $help = <<'HELP';
This procedure lowers the specified vectors to bottom of the existing
vectors stack. It will not move the vectors if there is no vectors
below it.
HELP

    &simon_pdb_misc('2005', '2.4');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'vectors', type => 'vectors',
	  desc => 'The vectors object to lower to bottom' }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gimp_image_lower_vectors_to_bottom (image, vectors);
}
CODE
    );
}

sub image_get_active_drawable {
    $blurb = "Get the image's active drawable";

    $help = <<'HELP';
This procedure returns the ID of the image's active drawable. This can be
either a layer, a channel, or a layer mask. The active drawable is specified by
the active image channel. If that is -1, then by the active image layer. If the
active image layer has a layer mask and the layer mask is in edit mode, then
the layer mask is the active drawable.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'drawable', type => 'drawable',
	  desc => 'The active drawable' }
    );

    %invoke = (
	code => <<'CODE'
{
  drawable = gimp_image_get_active_drawable (image);
}
CODE
    );
}

sub image_base_type {
    $blurb = 'Get the base type of the image.';

    $help = <<'HELP';
This procedure returns the image's base type. Layers in the image must be of
this subtype, but can have an optional alpha channel.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'base_type', type => 'enum GimpImageBaseType',
	  desc => "The image's base type" }
    );

    %invoke = (
	code => <<'CODE'
{
  base_type = gimp_image_base_type (image);
}
CODE
    );
}

sub image_get_colormap {
    $blurb = "Returns the image's colormap";

    $help = <<'HELP';
This procedure returns an actual pointer to the image's colormap, as well as
the number of bytes contained in the colormap. The actual number of colors in
the transmitted colormap will be 'num-bytes' / 3. If the image is not in
Indexed color mode, no colormap is returned.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'colormap', type => 'int8array', wrap => 1,
	  desc => "The image's colormap",
	  array => { name => 'num_bytes',
		     desc => 'Number of bytes in the colormap array' } }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-colormap.h") ],
	code => <<'CODE'
{
  num_bytes = 3 * gimp_image_get_colormap_size (image);
  colormap = g_memdup (gimp_image_get_colormap (image), num_bytes);
}
CODE
    );
}

sub image_set_colormap {
    $blurb = "Sets the entries in the image's colormap.";

    $help = <<'HELP';
This procedure sets the entries in the specified image's colormap. The number
of entries is specified by the 'num-bytes' parameter and corresponds to the
number of INT8 triples that must be contained in the 'colormap' array. The
actual number of colors in the transmitted colormap is 'num-bytes' / 3.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'colormap', type => 'int8array', wrap => 1,
	  desc => 'The new colormap values',
	  array => { name => 'num_bytes', type => '0 <= int32 <= 768',
		     desc => 'Number of bytes in the colormap array' } }
    );

    %invoke = (
	headers => [ qw("core/gimpimage-colormap.h") ],
        code => <<'CODE'
{
  gimp_image_set_colormap (image, colormap, num_bytes / 3, TRUE);
}
CODE
    );
}

sub image_clean_all {
    $blurb = 'Set the image dirty count to 0.';

    $help = <<'HELP';
This procedure sets the specified image's dirty count to 0, allowing
operations to occur without having a 'dirtied' image. This is
especially useful for creating and loading images which should not
initially be considered dirty, even though layers must be created,
filled, and installed in the image. Note that save plug-ins must NOT
call this function themselves after saving the image.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    %invoke = (
	code => <<'CODE'
{
  gimp_image_clean_all (image);
}
CODE
    );
}

sub image_is_dirty {
    $blurb = 'Checks if the image has unsaved changes.';

    $help = <<'HELP';
This procedure checks the specified image's dirty count to see if it
needs to be saved. Note that saving the image does not automatically
set the dirty count to 0, you need to call gimp_image_clean_all() after
calling a save procedure to make the image clean.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'dirty', type => 'boolean',
	  desc => 'TRUE if the image has unsaved changes.' }
    );

    %invoke = (
	code => <<'CODE'
{
  dirty = gimp_image_is_dirty (image);
}
CODE
    );
}

sub image_get_floating_sel {
    $blurb = 'Return the floating selection of the image.';

    $help = <<'HELP';
This procedure returns the image's floating selection, if it exists.
If it doesn't exist, -1 is returned as the layer ID.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'floating_sel', type => 'layer',
	  desc => "The image's floating selection" }
    );

    %invoke = (
	code => <<'CODE'
{
  floating_sel = gimp_image_get_floating_selection (image);
}
CODE
    );
}

sub image_floating_sel_attached_to {
    $blurb = 'Return the drawable the floating selection is attached to.';

    $help = <<'HELP';
This procedure returns the drawable the image's floating selection is attached
to, if it exists. If it doesn't exist, -1 is returned as the drawable ID.
HELP

    &wolfgang_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'drawable', type => 'drawable',
	  desc => 'The drawable the floating selection is attached to' }
    );

    %invoke = (
	code => <<'CODE'
{
  GimpLayer *floating_sel = gimp_image_get_floating_selection (image);

  if (floating_sel)
    drawable = gimp_layer_get_floating_sel_drawable (floating_sel);
  else
    drawable = NULL;
}
CODE
    );
}

sub image_width {
    $blurb = 'Return the width of the image';

    $help = <<'HELP';
This procedure returns the image's width. This value is independent of any of
the layers in this image. This is the "canvas" width.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'width', type => 'int32',
	  desc => "The image's width" }
    );

    %invoke = (
	code => <<'CODE'
{
  width = gimp_image_get_width (image);
}
CODE
    );
}

sub image_height {
    $blurb = 'Return the height of the image';

    $help = <<'HELP';
This procedure returns the image's height. This value is independent of any of
the layers in this image. This is the "canvas" height.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'height', type => 'int32',
	  desc => "The image's height" }
    );

    %invoke = (
	code => <<'CODE'
{
  height = gimp_image_get_height (image);
}
CODE
    );
}

sub image_get_active_layer {
    $blurb = "Returns the specified image's active layer.";

    $help = <<'HELP';
If there is an active layer, its ID will be returned, otherwise, -1.  If a
channel is currently active, then no layer will be. If a layer mask is active,
then this will return the associated layer.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'active_layer', type => 'layer',
	  desc => 'The active layer' }
    );

    %invoke = (
	code => <<'CODE'
{
  active_layer = gimp_image_get_active_layer (image);
}
CODE
    );
}

sub image_set_active_layer {
    $blurb = "Sets the specified image's active layer.";

    $help = <<'HELP';
If the layer exists, it is set as the active layer in the image. Any
previous active layer or channel is set to inactive. An exception is a
previously existing floating selection, in which case this procedure
will return an execution error.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'active_layer', type => 'layer',
	  desc => 'The new image active layer' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_image_set_active_layer (image, active_layer) != active_layer)
    success = FALSE;
}
CODE
    );
}

sub image_get_active_channel {
    $blurb = "Returns the specified image's active channel.";

    $help = <<'HELP';
If there is an active channel, this will return the channel ID, otherwise, -1.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'active_channel', type => 'channel',
	  desc => 'The active channel' }
    );

    %invoke = (
	code => <<'CODE'
{
  active_channel = gimp_image_get_active_channel (image);
}
CODE
    );
}

sub image_set_active_channel {
    $blurb = "Sets the specified image's active channel.";

    $help = <<'HELP';
If the channel exists, it is set as the active channel in the
image. Any previous active channel or channel is set to inactive. An
exception is a previously existing floating selection, in which case
this procedure will return an execution error.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'active_channel', type => 'channel',
	  desc => 'The new image active channel' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_image_set_active_channel (image, active_channel) != active_channel)
    success = FALSE;
}
CODE
    );
}

sub image_get_active_vectors {
    $blurb = "Returns the specified image's active vectors.";

    $help = <<'HELP';
If there is an active path, its ID will be returned, otherwise, -1.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'active_vectors', type => 'vectors',
	  desc => 'The active vectors' }
    );

    %invoke = (
	code => <<'CODE'
{
  active_vectors = gimp_image_get_active_vectors (image);
}
CODE
    );
}

sub image_set_active_vectors {
    $blurb = "Sets the specified image's active vectors.";

    $help = <<'HELP';
If the path exists, it is set as the active path in the image.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'active_vectors', type => 'vectors',
	  desc => 'The new image active vectors' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_image_set_active_vectors (image, active_vectors) != active_vectors)
    success = FALSE;
}
CODE
    );
}

sub image_get_selection {
    $blurb = "Returns the specified image's selection.";

    $help = <<'HELP';
This will always return a valid ID for a selection -- which is represented as a
channel internally.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'selection', type => 'selection',
	  desc => 'The selection channel' }
    );

    %invoke = (
	code => <<'CODE'
{
  selection = GIMP_SELECTION (gimp_image_get_mask (image));

  if (! selection)
    success = FALSE;
}
CODE
    );
}

sub image_get_component_active {
    $blurb = "Returns if the specified image's image component is active.";

    $help = <<'HELP';
This procedure returns if the specified image's image component
(i.e. Red, Green, Blue intensity channels in an RGB image) is active
or inactive -- whether or not it can be modified. If the specified
component is not valid for the image type, an error is returned.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'component', type => 'enum GimpChannelType',
	  desc => 'The image component' }
    );

    @outargs = (
	{ name => 'active', type => 'boolean',
	  desc => 'Component is active' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (component == GIMP_GRAY_CHANNEL)
    success = gimp_pdb_image_is_base_type (image, GIMP_GRAY, error);
  else if (component == GIMP_INDEXED_CHANNEL)
    success = gimp_pdb_image_is_base_type (image, GIMP_INDEXED, error);
  else
    success = gimp_pdb_image_is_base_type (image, GIMP_RGB, error);

  if (success)
    active = gimp_image_get_component_active (image, component);
}
CODE
    );
}

sub image_set_component_active {
    $blurb = "Sets if the specified image's image component is active.";

    $help = <<'HELP';
This procedure sets if the specified image's image component
(i.e. Red, Green, Blue intensity channels in an RGB image) is active
or inactive -- whether or not it can be modified. If the specified
component is not valid for the image type, an error is returned.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'component', type => 'enum GimpChannelType',
	  desc => 'The image component' },
	{ name => 'active', type => 'boolean',
	  desc => 'Component is active' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (component == GIMP_GRAY_CHANNEL)
    success = gimp_pdb_image_is_base_type (image, GIMP_GRAY, error);
  else if (component == GIMP_INDEXED_CHANNEL)
    success = gimp_pdb_image_is_base_type (image, GIMP_INDEXED, error);
  else
    success = gimp_pdb_image_is_base_type (image, GIMP_RGB, error);

  if (success)
    gimp_image_set_component_active (image, component, active);
}
CODE
    );
}

sub image_get_component_visible {
    $blurb = "Returns if the specified image's image component is visible.";

    $help = <<'HELP';
This procedure returns if the specified image's image component
(i.e. Red, Green, Blue intensity channels in an RGB image) is visible
or invisible -- whether or not it can be seen. If the specified
component is not valid for the image type, an error is returned.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'component', type => 'enum GimpChannelType',
	  desc => 'The image component' }
    );

    @outargs = (
	{ name => 'visible', type => 'boolean',
	  desc => 'Component is visible' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (component == GIMP_GRAY_CHANNEL)
    success = gimp_pdb_image_is_base_type (image, GIMP_GRAY, error);
  else if (component == GIMP_INDEXED_CHANNEL)
    success = gimp_pdb_image_is_base_type (image, GIMP_INDEXED, error);
  else
    success = gimp_pdb_image_is_base_type (image, GIMP_RGB, error);

  if (success)
    visible = gimp_image_get_component_visible (image, component);
}
CODE
    );
}

sub image_set_component_visible {
    $blurb = "Sets if the specified image's image component is visible.";

    $help = <<'HELP';
This procedure sets if the specified image's image component
(i.e. Red, Green, Blue intensity channels in an RGB image) is visible
or invisible -- whether or not it can be seen. If the specified
component is not valid for the image type, an error is returned.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'component', type => 'enum GimpChannelType',
	  desc => 'The image component' },
	{ name => 'visible', type => 'boolean',
	  desc => 'Component is visible' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (component == GIMP_GRAY_CHANNEL)
    success = gimp_pdb_image_is_base_type (image, GIMP_GRAY, error);
  else if (component == GIMP_INDEXED_CHANNEL)
    success = gimp_pdb_image_is_base_type (image, GIMP_INDEXED, error);
  else
    success = gimp_pdb_image_is_base_type (image, GIMP_RGB, error);

  if (success)
    gimp_image_set_component_visible (image, component, visible);
}
CODE
    );
}

sub image_get_filename {
    $blurb = "Returns the specified image's filename.";

    $help = <<'HELP';
This procedure returns the specified image's filename in the
filesystem encoding. The image has a filename only if it was loaded
from a local filesystem or has since been saved locally. Otherwise,
this function returns %NULL. See also gimp_image_get_uri().
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'filename', type => 'string',
	  desc => 'The filename' }
    );

    %invoke = (
	code => <<'CODE'
{
  filename = gimp_image_get_filename (image);
}
CODE
    );
}

sub image_set_filename {
    $blurb = "Sets the specified image's filename.";

    $help = <<'HELP';
This procedure sets the specified image's filename. The filename
should be in the filesystem encoding.
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'filename', type => 'string',
	  desc => 'The new image filename', allow_non_utf8 => 1 }
    );

    %invoke = (
	code => <<'CODE'
{
  /*  verify that the filename can be converted to UTF-8 and back  */
  gchar *utf8 = g_filename_to_utf8 (filename, -1, NULL, NULL, error);

  if (utf8)
    {
      gchar *tmp = g_filename_from_utf8 (utf8, -1, NULL, NULL, error);

      if (tmp)
        g_free (tmp);
      else
        success = FALSE;

      g_free (utf8);
    }
  else
    success = FALSE;

  if (success)
    gimp_image_set_filename (image, filename);
}
CODE
    );
}

sub image_get_uri {
    $blurb = "Returns the URI for the specified image.";

    $help = <<'HELP';
This procedure returns the URI associated with the specified image.
The image has an URI only if it was loaded from a file or has since
been saved. Otherwise, this function returns %NULL.
HELP

    &neo_pdb_misc('2009', '2.8');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'uri', type => 'string',
	  desc => 'The URI' }
    );

    %invoke = (
	code => <<'CODE'
{
  uri = g_strdup (gimp_object_get_name (image));
}
CODE
    );
}

sub image_get_name {
    $blurb = "Returns the specified image's name.";
    $help  =  <<'HELP';
This procedure returns the image's name. If the image has a filename or
an URI, then this is the base name (the last component of the path).
Otherwise it is the translated string "Untitled".
HELP

    &std_pdb_misc;

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'name', type => 'string',
	  desc => 'The name' }
    );

    %invoke = (
	code => <<'CODE'
{
  name = g_strdup (gimp_image_get_display_name (image));
}
CODE
    );
}

sub image_get_resolution {
    $blurb = "Returns the specified image's resolution.";

    $help = <<'HELP';
This procedure returns the specified image's resolution in dots per inch.
This value is independent of any of the layers in this image.
HELP

    &austin_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'xresolution', type => 'float', void_ret => 1,
	  desc => 'The resolution in the x-axis, in dots per inch' },
	{ name => 'yresolution', type => 'float',
	  desc => 'The resolution in the y-axis, in dots per inch' }
    );

    %invoke = (
	code => <<'CODE'
{
  gimp_image_get_resolution (image, &xresolution, &yresolution);
}
CODE
    );
}

sub image_set_resolution {
    $blurb = "Sets the specified image's resolution.";

    $help = <<'HELP';
This procedure sets the specified image's resolution in dots per inch.
This value is independent of any of the layers in this image.
No scaling or resizing is performed.
HELP

    &austin_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'xresolution', type => 'float',
	  desc => 'The new image resolution in the x-axis, in dots per inch' },
	{ name => 'yresolution', type => 'float',
	  desc => 'The new image resolution in the y-axis, in dots per inch' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (! FINITE (xresolution) ||
      xresolution < GIMP_MIN_RESOLUTION || xresolution > GIMP_MAX_RESOLUTION ||
      ! FINITE (yresolution) ||
      yresolution < GIMP_MIN_RESOLUTION || yresolution > GIMP_MAX_RESOLUTION)
    {
      g_set_error_literal (error, GIMP_PDB_ERROR, GIMP_PDB_INVALID_ARGUMENT,
                   	   _("Image resolution is out of bounds, "
                             "using the default resolution instead."));
      success = FALSE;
    }
  else
    {
      gimp_image_set_resolution (image, xresolution, yresolution);
    }
}
CODE
    );
}

sub image_get_unit {
    $blurb = "Returns the specified image's unit.";

    $help = <<'HELP';
This procedure returns the specified image's unit. This value is
independent of any of the layers in this image. See the gimp_unit_*()
procedure definitions for the valid range of unit IDs and a
description of the unit system.
HELP

    &mitch_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'unit', type => 'unit',
	  desc => 'The unit' }
    );

    %invoke = (
	code => <<'CODE'
{
  unit = gimp_image_get_unit (image);
}
CODE
    );
}

sub image_set_unit {
    $blurb = "Sets the specified image's unit.";

    $help = <<'HELP';
This procedure sets the specified image's unit. No scaling or resizing
is performed. This value is independent of any of the layers in this
image. See the gimp_unit_*() procedure definitions for the valid range
of unit IDs and a description of the unit system.
HELP

    &mitch_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'unit', type => 'unit (min GIMP_UNIT_INCH)',
	  desc => 'The new image unit' }
    );

    %invoke = (
	code => <<'CODE'
{
  gimp_image_set_unit (image, unit);
}
CODE
    );
}

sub image_get_tattoo_state {
    $blurb = 'Returns the tattoo state associated with the image.';

    $help = <<'HELP';
This procedure returns the tattoo state of the image. Use only by
save/load plugins that wish to preserve an images tattoo state. Using this
function at other times will produce unexpected results.
HELP

    &andy_pdb_misc('2000');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' }
    );

    @outargs = (
	{ name => 'tattoo_state', type => 'tattoo',
	  desc => 'The tattoo state' }
    );

    %invoke = (
	code => <<'CODE'
{
  tattoo_state = gimp_image_get_tattoo_state (image);
}
CODE
    );
}

sub image_set_tattoo_state {
    $blurb = 'Set the tattoo state associated with the image.';

    $help = <<'HELP';
This procedure sets the tattoo state of the image. Use only by
save/load plugins that wish to preserve an images tattoo state. Using
this function at other times will produce unexpected results. A full
check of uniqueness of states in layers, channels and paths will be
performed by this procedure and a execution failure will be returned
if this fails. A failure will also be returned if the new tattoo state
value is less than the maximum tattoo value from all of the tattoos
from the paths, layers and channels. After the image data has been
loaded and all the tattoos have been set then this is the last
procedure that should be called. If effectively does a status check on
the tattoo values that have been set to make sure that all is OK.
HELP

    &andy_pdb_misc('2000');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'tattoo_state', type => 'tattoo',
	  desc => 'The new image tattoo state' }
    );

    %invoke = (
	code => <<'CODE'
{
  gimp_image_set_tattoo_state (image, tattoo_state);
}
CODE
    );
}

sub image_get_layer_by_tattoo {
    $blurb = 'Find a layer with a given tattoo in an image.';

    $help = <<'HELP';
This procedure returns the layer with the given tattoo in the specified image.
HELP

    &jay_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'tattoo', type => 'tattoo',
	  desc => 'The tattoo of the layer to find' }
    );

    @outargs = (
	{ name => 'layer', type => 'layer',
	  desc => 'The layer with the specified tattoo' }
    );

    %invoke = (
	code => <<'CODE'
{
  layer = gimp_image_get_layer_by_tattoo (image, tattoo);
}
CODE
    );
}

sub image_get_channel_by_tattoo {
    $blurb = 'Find a channel with a given tattoo in an image.';

    $help = <<'HELP';
This procedure returns the channel with the given tattoo in the specified image.
HELP

    &jay_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'tattoo', type => 'tattoo',
	  desc => 'The tattoo of the channel to find' }
    );

    @outargs = (
	{ name => 'channel', type => 'channel',
	  desc => 'The channel with the specified tattoo' }
    );

    %invoke = (
	code => <<'CODE'
{
  channel = gimp_image_get_channel_by_tattoo (image, tattoo);
}
CODE
    );
}

sub image_get_vectors_by_tattoo {
    $blurb = 'Find a vectors with a given tattoo in an image.';

    $help = <<'HELP';
This procedure returns the vectors with the given tattoo in the
specified image.
HELP

    &simon_pdb_misc('2005', '2.6');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'tattoo', type => 'tattoo',
	  desc => 'The tattoo of the vectors to find' }
    );

    @outargs = (
	{ name => 'vectors', type => 'vectors',
	  desc => 'The vectors with the specified tattoo' }
    );

    %invoke = (
	code => <<'CODE'
{
  vectors = gimp_image_get_vectors_by_tattoo (image, tattoo);
}
CODE
    );
}

sub image_thumbnail {
    $blurb = 'Get a thumbnail of an image.';

    $help = <<'HELP';
This function gets data from which a thumbnail of an image preview can
be created. Maximum x or y dimension is 1024 pixels. The pixels are
returned in RGB[A] or GRAY[A] format. The bpp return value gives the
number of bits per pixel in the image.
HELP

    &andy_pdb_misc('1999');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'width', type => '1 <= int32 <= 1024',
	  desc => 'The requested thumbnail width' },
	{ name => 'height', type => '1 <= int32 <= 1024',
	  desc => 'The requested thumbnail height' }
    );

    @outargs = (
	{ name => 'actual_width', type => 'int32', void_ret => 1,
	  desc => 'The previews width' },
	{ name => 'actual_height', type => 'int32',
	  desc => 'The previews height' },
	{ name => 'bpp', type => 'int32',
	  desc => 'The previews bpp' },
        { name => 'thumbnail_data', type => 'int8array', wrap => 1,
	  desc => 'The thumbnail data',
	  array => { name => 'thumbnail_data_count',
		     desc => 'The number of bytes in thumbnail data' } }
    );

    %invoke = (
	code => <<'CODE'
{
  TempBuf *buf;
  gint     dwidth, dheight;

  g_assert (GIMP_VIEWABLE_MAX_PREVIEW_SIZE >= 1024);

  /* Adjust the width/height ratio */
  dwidth  = gimp_image_get_width  (image);
  dheight = gimp_image_get_height (image);

  if (dwidth > dheight)
    height = MAX (1, (width * dheight) / dwidth);
  else
    width  = MAX (1, (height * dwidth) / dheight);

  gimp_pickable_flush (GIMP_PICKABLE (gimp_image_get_projection (image)));

  buf = gimp_viewable_get_new_preview (GIMP_VIEWABLE (image), context,
                                       width, height);

  if (buf)
    {
      actual_width         = buf->width;
      actual_height        = buf->height;
      bpp                  = buf->bytes;
      thumbnail_data_count = actual_width * actual_height * bpp;
      thumbnail_data       = g_memdup (temp_buf_get_data (buf),
                                       thumbnail_data_count);

      temp_buf_free (buf);
    }
  else
    success = FALSE;
}
CODE
    );
}


$extra{app}->{code} = <<'CODE';
#if defined (HAVE_FINITE)
#define FINITE(x) finite(x)
#elif defined (HAVE_ISFINITE)
#define FINITE(x) isfinite(x)
#elif defined (G_OS_WIN32)
#define FINITE(x) _finite(x)
#else
#error "no FINITE() implementation available?!"
#endif
CODE

@headers = qw("libgimpmath/gimpmath.h"
              "libgimpbase/gimpbase.h"
              "base/temp-buf.h"
              "core/gimp.h"
              "core/gimpcontainer.h"
              "core/gimpprogress.h"
              "core/gimpunit.h"
              "gimppdberror.h"
              "gimppdb-utils.h"
              "gimp-intl.h");

@procs = qw(image_is_valid
            image_list
	    image_new image_duplicate image_delete
            image_base_type
            image_width image_height
            image_free_shadow
            image_resize image_resize_to_layers
            image_scale image_scale_full
            image_crop image_flip image_rotate
            image_get_layers
            image_get_channels
            image_get_vectors
            image_get_active_drawable
            image_unset_active_channel
            image_get_floating_sel
            image_floating_sel_attached_to
            image_pick_color
            image_pick_correlate_layer
            image_add_layer image_remove_layer
	    image_get_layer_position
            image_raise_layer image_lower_layer
            image_raise_layer_to_top image_lower_layer_to_bottom
            image_add_channel image_remove_channel
	    image_get_channel_position
            image_raise_channel image_lower_channel
            image_add_vectors image_remove_vectors
	    image_get_vectors_position
            image_raise_vectors image_lower_vectors
            image_raise_vectors_to_top image_lower_vectors_to_bottom
            image_flatten image_merge_visible_layers image_merge_down
            image_add_layer_mask image_remove_layer_mask
            image_get_colormap image_set_colormap
            image_clean_all image_is_dirty
            image_thumbnail
	    image_get_active_layer image_set_active_layer
	    image_get_active_channel image_set_active_channel
	    image_get_active_vectors image_set_active_vectors
	    image_get_selection
	    image_get_component_active image_set_component_active
	    image_get_component_visible image_set_component_visible
	    image_get_filename image_set_filename
	    image_get_uri
            image_get_name
	    image_get_resolution image_set_resolution
	    image_get_unit image_set_unit
	    image_get_tattoo_state image_set_tattoo_state
            image_get_layer_by_tattoo
            image_get_channel_by_tattoo
            image_get_vectors_by_tattoo);

%exports = (app => [@procs], lib => [@procs[0..46,49..77]]);

$desc = 'Image';

1;
