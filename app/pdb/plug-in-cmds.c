/* GIMP - The GNU Image Manipulation Program
 * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl. */

#include "config.h"

#include <stdlib.h>
#include <string.h>

#include <gegl.h>

#include <gdk-pixbuf/gdk-pixbuf.h>

#include "libgimpbase/gimpbase.h"

#include "libgimpbase/gimpbase.h"

#include "pdb-types.h"

#include "core/gimp.h"
#include "core/gimpparamspecs.h"
#include "plug-in/gimpplugin.h"
#include "plug-in/gimpplugindef.h"
#include "plug-in/gimppluginmanager-menu-branch.h"
#include "plug-in/gimppluginmanager-query.h"
#include "plug-in/gimppluginmanager.h"
#include "plug-in/gimppluginprocedure.h"

#include "gimppdb.h"
#include "gimppdb-utils.h"
#include "gimpprocedure.h"
#include "internal-procs.h"


static GimpValueArray *
plug_ins_query_invoker (GimpProcedure         *procedure,
                        Gimp                  *gimp,
                        GimpContext           *context,
                        GimpProgress          *progress,
                        const GimpValueArray  *args,
                        GError               **error)
{
  GimpValueArray *return_vals;
  const gchar *search_string;
  gint num_procedures = 0;
  gchar **procedures = NULL;
  gint num_accelerators = 0;
  gchar **accelerators = NULL;
  gint num_locations = 0;
  gchar **locations = NULL;
  gint num_install_times = 0;
  gint32 *install_times = NULL;

  search_string = g_value_get_string (gimp_value_array_index (args, 0));

  num_procedures = gimp_plug_in_manager_query (gimp->plug_in_manager,
                                               search_string,
                                               &procedures,
                                               &accelerators,
                                               &locations,
                                               &install_times);
  num_accelerators  = num_procedures;
  num_locations     = num_procedures;
  num_install_times = num_procedures;

  return_vals = gimp_procedure_get_return_values (procedure, TRUE, NULL);

  g_value_set_int (gimp_value_array_index (return_vals, 1), num_procedures);
  gimp_value_take_string_array (gimp_value_array_index (return_vals, 2), procedures, num_procedures);
  g_value_set_int (gimp_value_array_index (return_vals, 3), num_accelerators);
  gimp_value_take_string_array (gimp_value_array_index (return_vals, 4), accelerators, num_accelerators);
  g_value_set_int (gimp_value_array_index (return_vals, 5), num_locations);
  gimp_value_take_string_array (gimp_value_array_index (return_vals, 6), locations, num_locations);
  g_value_set_int (gimp_value_array_index (return_vals, 7), num_install_times);
  gimp_value_take_int32_array (gimp_value_array_index (return_vals, 8), install_times, num_install_times);

  return return_vals;
}

static GimpValueArray *
plug_in_domain_register_invoker (GimpProcedure         *procedure,
                                 Gimp                  *gimp,
                                 GimpContext           *context,
                                 GimpProgress          *progress,
                                 const GimpValueArray  *args,
                                 GError               **error)
{
  gboolean success = TRUE;
  const gchar *domain_name;
  GFile *domain_file;

  domain_name = g_value_get_string (gimp_value_array_index (args, 0));
  domain_file = g_value_get_object (gimp_value_array_index (args, 1));

  if (success)
    {
      GimpPlugIn *plug_in = gimp->plug_in_manager->current_plug_in;

      if (plug_in && plug_in->call_mode == GIMP_PLUG_IN_CALL_QUERY)
        {
          gchar *domain_path = domain_file ? g_file_get_path (domain_file) : NULL;

          gimp_plug_in_def_set_locale_domain (plug_in->plug_in_def,
                                              domain_name, domain_path);

          g_free (domain_path);
        }
      else
        success = FALSE;
    }

  return gimp_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static GimpValueArray *
plug_in_help_register_invoker (GimpProcedure         *procedure,
                               Gimp                  *gimp,
                               GimpContext           *context,
                               GimpProgress          *progress,
                               const GimpValueArray  *args,
                               GError               **error)
{
  gboolean success = TRUE;
  const gchar *domain_name;
  GFile *domain_file;

  domain_name = g_value_get_string (gimp_value_array_index (args, 0));
  domain_file = g_value_get_object (gimp_value_array_index (args, 1));

  if (success)
    {
      GimpPlugIn *plug_in = gimp->plug_in_manager->current_plug_in;

      if (plug_in && plug_in->call_mode == GIMP_PLUG_IN_CALL_QUERY)
        {
          gchar *domain_uri = domain_file ? g_file_get_uri (domain_file) : NULL;

          gimp_plug_in_def_set_help_domain (plug_in->plug_in_def,
                                            domain_name, domain_uri);

          g_free (domain_uri);
        }
      else
        success = FALSE;
    }

  return gimp_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static GimpValueArray *
plug_in_menu_branch_register_invoker (GimpProcedure         *procedure,
                                      Gimp                  *gimp,
                                      GimpContext           *context,
                                      GimpProgress          *progress,
                                      const GimpValueArray  *args,
                                      GError               **error)
{
  gboolean success = TRUE;
  const gchar *menu_path;
  const gchar *menu_name;

  menu_path = g_value_get_string (gimp_value_array_index (args, 0));
  menu_name = g_value_get_string (gimp_value_array_index (args, 1));

  if (success)
    {
      GimpPlugIn *plug_in = gimp->plug_in_manager->current_plug_in;

      if (plug_in)
        {
          gimp_plug_in_manager_add_menu_branch (gimp->plug_in_manager,
                                                plug_in->file, menu_path, menu_name);
        }
      else
        success = FALSE;
    }

  return gimp_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static GimpValueArray *
plug_in_set_pdb_error_handler_invoker (GimpProcedure         *procedure,
                                       Gimp                  *gimp,
                                       GimpContext           *context,
                                       GimpProgress          *progress,
                                       const GimpValueArray  *args,
                                       GError               **error)
{
  gboolean success = TRUE;
  gint handler;

  handler = g_value_get_enum (gimp_value_array_index (args, 0));

  if (success)
    {
      GimpPlugIn *plug_in = gimp->plug_in_manager->current_plug_in;

      if (plug_in)
        {
          gimp_plug_in_set_error_handler (plug_in, handler);
        }
      else
        success = FALSE;
    }

  return gimp_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static GimpValueArray *
plug_in_get_pdb_error_handler_invoker (GimpProcedure         *procedure,
                                       Gimp                  *gimp,
                                       GimpContext           *context,
                                       GimpProgress          *progress,
                                       const GimpValueArray  *args,
                                       GError               **error)
{
  gboolean success = TRUE;
  GimpValueArray *return_vals;
  gint handler = 0;

  GimpPlugIn *plug_in = gimp->plug_in_manager->current_plug_in;

  if (plug_in)
    {
      handler = gimp_plug_in_get_error_handler (plug_in);
    }
  else
    success = FALSE;

  return_vals = gimp_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_enum (gimp_value_array_index (return_vals, 1), handler);

  return return_vals;
}

void
register_plug_in_procs (GimpPDB *pdb)
{
  GimpProcedure *procedure;

  /*
   * gimp-plug-ins-query
   */
  procedure = gimp_procedure_new (plug_ins_query_invoker);
  gimp_object_set_static_name (GIMP_OBJECT (procedure),
                               "gimp-plug-ins-query");
  gimp_procedure_set_static_help (procedure,
                                  "Queries the plug-in database for its contents.",
                                  "This procedure queries the contents of the plug-in database.",
                                  NULL);
  gimp_procedure_set_static_attribution (procedure,
                                         "Andy Thomas",
                                         "Andy Thomas",
                                         "1998");
  gimp_procedure_add_argument (procedure,
                               gimp_param_spec_string ("search-string",
                                                       "search string",
                                                       "If not an empty string then use this as a search pattern",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       GIMP_PARAM_READWRITE | GIMP_PARAM_NO_VALIDATE));
  gimp_procedure_add_return_value (procedure,
                                   g_param_spec_int ("num-procedures",
                                                     "num procedures",
                                                     "The number of matching procedures",
                                                     0, G_MAXINT32, 0,
                                                     GIMP_PARAM_READWRITE));
  gimp_procedure_add_return_value (procedure,
                                   gimp_param_spec_string_array ("procedures",
                                                                 "procedures",
                                                                 "The plug-in procedure name",
                                                                 GIMP_PARAM_READWRITE));
  gimp_procedure_add_return_value (procedure,
                                   g_param_spec_int ("num-accelerators",
                                                     "num accelerators",
                                                     "The number of matching procedures",
                                                     0, G_MAXINT32, 0,
                                                     GIMP_PARAM_READWRITE));
  gimp_procedure_add_return_value (procedure,
                                   gimp_param_spec_string_array ("accelerators",
                                                                 "accelerators",
                                                                 "String representing keyboard accelerator (could be empty string)",
                                                                 GIMP_PARAM_READWRITE));
  gimp_procedure_add_return_value (procedure,
                                   g_param_spec_int ("num-locations",
                                                     "num locations",
                                                     "The number of matching procedures",
                                                     0, G_MAXINT32, 0,
                                                     GIMP_PARAM_READWRITE));
  gimp_procedure_add_return_value (procedure,
                                   gimp_param_spec_string_array ("locations",
                                                                 "locations",
                                                                 "Location of the plug-in program",
                                                                 GIMP_PARAM_READWRITE));
  gimp_procedure_add_return_value (procedure,
                                   g_param_spec_int ("num-install-times",
                                                     "num install times",
                                                     "The number of matching procedures",
                                                     0, G_MAXINT32, 0,
                                                     GIMP_PARAM_READWRITE));
  gimp_procedure_add_return_value (procedure,
                                   gimp_param_spec_int32_array ("install-times",
                                                                "install times",
                                                                "Time that the plug-in was installed",
                                                                GIMP_PARAM_READWRITE));
  gimp_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * gimp-plug-in-domain-register
   */
  procedure = gimp_procedure_new (plug_in_domain_register_invoker);
  gimp_object_set_static_name (GIMP_OBJECT (procedure),
                               "gimp-plug-in-domain-register");
  gimp_procedure_set_static_help (procedure,
                                  "Registers a textdomain for localisation.",
                                  "This procedure adds a textdomain to the list of domains Gimp searches for strings when translating its menu entries. There is no need to call this function for plug-ins that have their strings included in the 'gimp-std-plugins' domain as that is used by default. If the compiled message catalog is not in the standard location, you may specify an absolute path to another location. This procedure can only be called in the query function of a plug-in and it has to be called before any procedure is installed.",
                                  NULL);
  gimp_procedure_set_static_attribution (procedure,
                                         "Sven Neumann <sven@gimp.org>",
                                         "Sven Neumann",
                                         "2000");
  gimp_procedure_add_argument (procedure,
                               gimp_param_spec_string ("domain-name",
                                                       "domain name",
                                                       "The name of the textdomain (must be unique)",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       GIMP_PARAM_READWRITE));
  gimp_procedure_add_argument (procedure,
                               g_param_spec_object ("domain-file",
                                                    "domain file",
                                                    "The path to the locally installed compiled message catalog (may be NULL)",
                                                    G_TYPE_FILE,
                                                    GIMP_PARAM_READWRITE));
  gimp_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * gimp-plug-in-help-register
   */
  procedure = gimp_procedure_new (plug_in_help_register_invoker);
  gimp_object_set_static_name (GIMP_OBJECT (procedure),
                               "gimp-plug-in-help-register");
  gimp_procedure_set_static_help (procedure,
                                  "Register a help path for a plug-in.",
                                  "This procedure registers user documentation for the calling plug-in with the GIMP help system. The domain_uri parameter points to the root directory where the plug-in help is installed. For each supported language there should be a file called 'gimp-help.xml' that maps the help IDs to the actual help files.",
                                  NULL);
  gimp_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@gimp.org>",
                                         "Michael Natterer",
                                         "2000");
  gimp_procedure_add_argument (procedure,
                               gimp_param_spec_string ("domain-name",
                                                       "domain name",
                                                       "The XML namespace of the plug-in's help pages",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       GIMP_PARAM_READWRITE));
  gimp_procedure_add_argument (procedure,
                               g_param_spec_object ("domain-file",
                                                    "domain file",
                                                    "The root URI of the plug-in's help pages",
                                                    G_TYPE_FILE,
                                                    GIMP_PARAM_READWRITE));
  gimp_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * gimp-plug-in-menu-branch-register
   */
  procedure = gimp_procedure_new (plug_in_menu_branch_register_invoker);
  gimp_object_set_static_name (GIMP_OBJECT (procedure),
                               "gimp-plug-in-menu-branch-register");
  gimp_procedure_set_static_help (procedure,
                                  "Register a sub-menu.",
                                  "This procedure installs a sub-menu which does not belong to any procedure. The menu-name should be the untranslated menu label. GIMP will look up the translation in the textdomain registered for the plug-in.",
                                  NULL);
  gimp_procedure_set_static_attribution (procedure,
                                         "Michael Natterer <mitch@gimp.org>",
                                         "Michael Natterer",
                                         "2005");
  gimp_procedure_add_argument (procedure,
                               gimp_param_spec_string ("menu-path",
                                                       "menu path",
                                                       "The sub-menu's menu path",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       GIMP_PARAM_READWRITE));
  gimp_procedure_add_argument (procedure,
                               gimp_param_spec_string ("menu-name",
                                                       "menu name",
                                                       "The name of the sub-menu",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       GIMP_PARAM_READWRITE));
  gimp_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * gimp-plug-in-set-pdb-error-handler
   */
  procedure = gimp_procedure_new (plug_in_set_pdb_error_handler_invoker);
  gimp_object_set_static_name (GIMP_OBJECT (procedure),
                               "gimp-plug-in-set-pdb-error-handler");
  gimp_procedure_set_static_help (procedure,
                                  "Sets an error handler for procedure calls.",
                                  "This procedure changes the way that errors in procedure calls are handled. By default GIMP will raise an error dialog if a procedure call made by a plug-in fails. Using this procedure the plug-in can change this behavior. If the error handler is set to %GIMP_PDB_ERROR_HANDLER_PLUGIN, then the plug-in is responsible for calling 'gimp-get-pdb-error' and handling the error whenever one if its procedure calls fails. It can do this by displaying the error message or by forwarding it in its own return values.",
                                  NULL);
  gimp_procedure_set_static_attribution (procedure,
                                         "Sven Neumann <sven@gimp.org>",
                                         "Sven Neumann",
                                         "2008");
  gimp_procedure_add_argument (procedure,
                               g_param_spec_enum ("handler",
                                                  "handler",
                                                  "Who is responsible for handling procedure call errors",
                                                  GIMP_TYPE_PDB_ERROR_HANDLER,
                                                  GIMP_PDB_ERROR_HANDLER_INTERNAL,
                                                  GIMP_PARAM_READWRITE));
  gimp_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * gimp-plug-in-get-pdb-error-handler
   */
  procedure = gimp_procedure_new (plug_in_get_pdb_error_handler_invoker);
  gimp_object_set_static_name (GIMP_OBJECT (procedure),
                               "gimp-plug-in-get-pdb-error-handler");
  gimp_procedure_set_static_help (procedure,
                                  "Retrieves the active error handler for procedure calls.",
                                  "This procedure retrieves the currently active error handler for procedure calls made by the calling plug-in. See 'gimp-plugin-set-pdb-error-handler' for details.",
                                  NULL);
  gimp_procedure_set_static_attribution (procedure,
                                         "Sven Neumann <sven@gimp.org>",
                                         "Sven Neumann",
                                         "2008");
  gimp_procedure_add_return_value (procedure,
                                   g_param_spec_enum ("handler",
                                                      "handler",
                                                      "Who is responsible for handling procedure call errors",
                                                      GIMP_TYPE_PDB_ERROR_HANDLER,
                                                      GIMP_PDB_ERROR_HANDLER_INTERNAL,
                                                      GIMP_PARAM_READWRITE));
  gimp_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);
}
