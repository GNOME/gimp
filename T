app/core/gimpbezierdesc.c:  desc->status   = CAIRO_STATUS_SUCCESS;
app/core/gimpbezierdesc.c:  desc->num_data = n_data;
app/core/gimpbezierdesc.c:  desc->data     = data;
app/core/gimpbezierdesc.c:  for (i = 0; i < desc->num_data; i += desc->data[i].header.length)
app/core/gimpbezierdesc.c:    for (j = 1; j < desc->data[i].header.length; ++j)
app/core/gimpbezierdesc.c:        desc->data[i+j].point.x += offset_x;
app/core/gimpbezierdesc.c:        desc->data[i+j].point.y += offset_y;
app/core/gimpbezierdesc.c:  return gimp_bezier_desc_new (g_memdup2 (desc->data,
app/core/gimpbezierdesc.c:                                          desc->num_data * sizeof (cairo_path_data_t)),
app/core/gimpbezierdesc.c:                               desc->num_data);
app/core/gimpbezierdesc.c:  g_free (desc->data);
app/core/gimpscanconvert.c:  sc->path_data = g_array_new (FALSE, FALSE, sizeof (cairo_path_data_t));
app/core/gimpscanconvert.c:  sc->ratio_xy = 1.0;
app/core/gimpscanconvert.c:  if (sc->path_data)
app/core/gimpscanconvert.c:    g_array_free (sc->path_data, TRUE);
app/core/gimpscanconvert.c:  if (sc->dash_info)
app/core/gimpscanconvert.c:    g_array_free (sc->dash_info, TRUE);
app/core/gimpscanconvert.c:  sc->ratio_xy = ratio_xy;
app/core/gimpscanconvert.c:  sc->clip   = TRUE;
app/core/gimpscanconvert.c:  sc->clip_x = x;
app/core/gimpscanconvert.c:  sc->clip_y = y;
app/core/gimpscanconvert.c:  sc->clip_w = width;
app/core/gimpscanconvert.c:  sc->clip_h = height;
app/core/gimpscanconvert.c:          sc->path_data = g_array_append_val (sc->path_data, pd);
app/core/gimpscanconvert.c:          sc->path_data = g_array_append_val (sc->path_data, pd);
app/core/gimpscanconvert.c:      sc->path_data = g_array_append_val (sc->path_data, pd);
app/core/gimpscanconvert.c:  sc->path_data = g_array_append_vals (sc->path_data,
app/core/gimpscanconvert.c:  sc->do_stroke = TRUE;
app/core/gimpscanconvert.c:  sc->width     = width;
app/core/gimpscanconvert.c:  sc->join      = join;
app/core/gimpscanconvert.c:  sc->cap       = cap;
app/core/gimpscanconvert.c:  sc->miter     = miter;
app/core/gimpscanconvert.c:  if (sc->dash_info)
app/core/gimpscanconvert.c:      g_array_free (sc->dash_info, TRUE);
app/core/gimpscanconvert.c:      sc->dash_info = NULL;
app/core/gimpscanconvert.c:          sc->dash_info = g_array_sized_new (FALSE, FALSE,
app/core/gimpscanconvert.c:          sc->dash_info = g_array_append_vals (sc->dash_info, dashes, n_dashes);
app/core/gimpscanconvert.c:          sc->dash_offset = dash_offset;
app/core/gimpscanconvert.c:  if (sc->clip && ! gimp_rectangle_intersect (x, y, width, height,
app/core/gimpscanconvert.c:                                              sc->clip_x, sc->clip_y,
app/core/gimpscanconvert.c:                                              sc->clip_w, sc->clip_h,
app/core/gimpscanconvert.c:  path.data     = (cairo_path_data_t *) sc->path_data->data;
app/core/gimpscanconvert.c:  path.num_data = sc->path_data->len;
app/core/gimpscanconvert.c:      cairo_set_miter_limit (cr, sc->miter);
app/core/gimpscanconvert.c:      if (sc->do_stroke)
app/core/gimpscanconvert.c:                              sc->cap == GIMP_CAP_BUTT ? CAIRO_LINE_CAP_BUTT :
app/core/gimpscanconvert.c:                              sc->cap == GIMP_CAP_ROUND ? CAIRO_LINE_CAP_ROUND :
app/core/gimpscanconvert.c:                               sc->join == GIMP_JOIN_MITER ? CAIRO_LINE_JOIN_MITER :
app/core/gimpscanconvert.c:                               sc->join == GIMP_JOIN_ROUND ? CAIRO_LINE_JOIN_ROUND :
app/core/gimpscanconvert.c:          cairo_set_line_width (cr, sc->width);
app/core/gimpscanconvert.c:          if (sc->dash_info)
app/core/gimpscanconvert.c:                            (double *) sc->dash_info->data,
app/core/gimpscanconvert.c:                            sc->dash_info->len,
app/core/gimpscanconvert.c:                            sc->dash_offset);
app/core/gimpscanconvert.c:          cairo_scale (cr, 1.0, sc->ratio_xy);
app/pdb/gimppdb-query.c:      match_string (pdb_query->proc_type_regex, type_desc->value_desc))
app/pdb/gimppdb-query.c:      output_string (string, type_desc->value_desc);
app/tools/gimpseamlessclonetool.c:  if (sc->paste == NULL)
app/tools/gimpseamlessclonetool.c:      sc->paste = gimp_gegl_buffer_dup (gimp_buffer_get_buffer (buffer));
app/tools/gimpseamlessclonetool.c:      sc->width  = gegl_buffer_get_width  (sc->paste);
app/tools/gimpseamlessclonetool.c:      sc->height = gegl_buffer_get_height (sc->paste);
app/tools/gimpseamlessclonetool.c:  sc->tool_state = SC_STATE_RENDER_WAIT;
app/tools/gimpseamlessclonetool.c:  if (sc->tool_state == SC_STATE_INIT)
app/tools/gimpseamlessclonetool.c:      sc->tool_state = SC_STATE_INIT;
app/tools/gimpseamlessclonetool.c:      g_clear_object (&sc->paste);
app/tools/gimpseamlessclonetool.c:      g_clear_object (&sc->render_node);
app/tools/gimpseamlessclonetool.c:      sc->sc_node = NULL;
app/tools/gimpseamlessclonetool.c:  if (sc->filter)
app/tools/gimpseamlessclonetool.c:      gimp_drawable_filter_abort (sc->filter);
app/tools/gimpseamlessclonetool.c:      g_clear_object (&sc->filter);
app/tools/gimpseamlessclonetool.c:  if (sc->filter)
app/tools/gimpseamlessclonetool.c:      gimp_drawable_filter_commit (sc->filter, GIMP_PROGRESS (tool), FALSE);
app/tools/gimpseamlessclonetool.c:      g_clear_object (&sc->filter);
app/tools/gimpseamlessclonetool.c:      sc->xoff = (gint) coords->x - sc->width / 2;
app/tools/gimpseamlessclonetool.c:      sc->yoff = (gint) coords->y - sc->height / 2;
app/tools/gimpseamlessclonetool.c:  if (sc->tool_state == SC_STATE_RENDER_WAIT &&
app/tools/gimpseamlessclonetool.c:      sc->xoff_p = sc->xoff;
app/tools/gimpseamlessclonetool.c:      sc->yoff_p = sc->yoff;
app/tools/gimpseamlessclonetool.c:      sc->xclick = coords->x;
app/tools/gimpseamlessclonetool.c:      sc->yclick = coords->y;
app/tools/gimpseamlessclonetool.c:      sc->tool_state = SC_STATE_RENDER_MOTION;
app/tools/gimpseamlessclonetool.c:  if (sc->tool_state == SC_STATE_RENDER_MOTION)
app/tools/gimpseamlessclonetool.c:          sc->xoff = sc->xoff_p;
app/tools/gimpseamlessclonetool.c:          sc->yoff = sc->yoff_p;
app/tools/gimpseamlessclonetool.c:          sc->xoff = sc->xoff_p + (gint) (coords->x - sc->xclick);
app/tools/gimpseamlessclonetool.c:          sc->yoff = sc->yoff_p + (gint) (coords->y - sc->yclick);
app/tools/gimpseamlessclonetool.c:      sc->tool_state = SC_STATE_RENDER_WAIT;
app/tools/gimpseamlessclonetool.c:  if (sc->tool_state == SC_STATE_RENDER_MOTION)
app/tools/gimpseamlessclonetool.c:      sc->xoff = sc->xoff_p + (gint) (coords->x - sc->xclick);
app/tools/gimpseamlessclonetool.c:      sc->yoff = sc->yoff_p + (gint) (coords->y - sc->yclick);
app/tools/gimpseamlessclonetool.c:      if (sc->tool_state == SC_STATE_RENDER_MOTION)
app/tools/gimpseamlessclonetool.c:      else if (sc->tool_state == SC_STATE_RENDER_WAIT &&
app/tools/gimpseamlessclonetool.c:  if (sc->tool_state == SC_STATE_RENDER_WAIT ||
app/tools/gimpseamlessclonetool.c:      sc->tool_state == SC_STATE_RENDER_MOTION)
app/tools/gimpseamlessclonetool.c:                                    sc->xoff, sc->yoff, sc->width, sc->height);
app/tools/gimpseamlessclonetool.c:                               "buffer",    sc->paste,
app/tools/gimpseamlessclonetool.c:  sc->render_node = node;
app/tools/gimpseamlessclonetool.c:  sc->sc_node     = op;
app/tools/gimpseamlessclonetool.c:      rendered_xoff == sc->xoff                               &&
app/tools/gimpseamlessclonetool.c:      rendered_yoff == sc->yoff)
app/tools/gimpseamlessclonetool.c:  gegl_node_set (sc->sc_node,
app/tools/gimpseamlessclonetool.c:                 "xoff", (gint) sc->xoff - off_x,
app/tools/gimpseamlessclonetool.c:                 "yoff", (gint) sc->yoff - off_y,
app/tools/gimpseamlessclonetool.c:  rendered_xoff              = sc->xoff;
app/tools/gimpseamlessclonetool.c:  rendered_yoff              = sc->yoff;
app/tools/gimpseamlessclonetool.c:  if (! sc->render_node)
app/tools/gimpseamlessclonetool.c:  sc->filter = gimp_drawable_filter_new (drawable,
app/tools/gimpseamlessclonetool.c:                                         sc->render_node,
app/tools/gimpseamlessclonetool.c:  gimp_drawable_filter_set_region (sc->filter, GIMP_FILTER_REGION_DRAWABLE);
app/tools/gimpseamlessclonetool.c:  g_signal_connect (sc->filter, "flush",
app/tools/gimpseamlessclonetool.c:  g_object_get (sc->sc_node, "gegl-operation", &op, NULL);
app/tools/gimpseamlessclonetool.c:  gimp_drawable_filter_apply (sc->filter, NULL);
app/tools/gimpseamlessclonetool.c:  output = gegl_node_get_output_proxy (sc->render_node, "output");
app/vectors/gimpvectors.c:          cmd_array = g_array_append_vals (cmd_array, bezdesc->data,
app/vectors/gimpvectors.c:                                           bezdesc->num_data);
build/windows/jhbuild/patches/ghostscript-8.71-windows.patch:+	news-3600 | risc-news)
build/windows/jhbuild/patches/ghostscript-8.71-windows.patch:+	openrisc | openrisc-*)
build/windows/jhbuild/patches/ghostscript-8.71-windows.patch:+	parisc-*)
ChangeLog.pre-2-6:	tests for when mk_vector is out of memory. Can't rely on sc->sink.
libgimpbase/gimputils.c:      while (value_desc->value_desc)
libgimpbase/gimputils.c:          if (value_desc->value == value)
libgimpbase/gimputils.c:              if (enum_desc && enum_desc->value_desc)
libgimpbase/gimputils.c:                                                enum_desc->value_desc);
libgimpbase/gimputils.c:                    *value_desc = g_strip_context (enum_desc->value_desc,
libgimpbase/gimputils.c:                                                             enum_desc->value_desc));
libgimpbase/gimputils.c:              *value_help = ((enum_desc && enum_desc->value_help) ?
libgimpbase/gimputils.c:                                       enum_desc->value_help) :
libgimpbase/gimputils.c:  if (enum_desc && enum_desc->value_desc)
libgimpbase/gimputils.c:                             enum_desc->value_desc);
libgimpbase/gimputils.c:        return g_strip_context (enum_desc->value_desc,
libgimpbase/gimputils.c:                                          enum_desc->value_desc));
libgimpbase/gimputils.c:  if (enum_desc && enum_desc->value_help)
libgimpbase/gimputils.c:                     enum_desc->value_help);
libgimpbase/gimputils.c:      enum_desc[1].value == enum_desc->value &&
libgimpbase/gimputils.c:      while (value_desc->value_desc)
libgimpbase/gimputils.c:          if ((value_desc->value & value) == value_desc->value)
libgimpbase/gimputils.c:            *value_desc = ((flags_desc && flags_desc->value_desc) ?
libgimpbase/gimputils.c:                                     flags_desc->value_desc) :
libgimpbase/gimputils.c:            *value_help = ((flags_desc && flags_desc->value_desc) ?
libgimpbase/gimputils.c:                                     flags_desc->value_help) :
libgimpbase/gimputils.c:  if (flags_desc->value_desc)
libgimpbase/gimputils.c:                             flags_desc->value_desc);
libgimpbase/gimputils.c:        return g_strip_context (flags_desc->value_desc,
libgimpbase/gimputils.c:                                          flags_desc->value_desc));
libgimpbase/gimputils.c:  if (flags_desc->value_help)
libgimpbase/gimputils.c:                     flags_desc->value_help);
libgimpbase/gimputils.c:      flags_desc[1].value == flags_desc->value &&
libgimpwidgets/gimpcolorscales.c:                               gettext (enum_desc->value_help), NULL);
libgimpwidgets/gimpcolorscales.c:        gimp_color_scale_entry_new (gettext (enum_desc->value_desc),
libgimpwidgets/gimpcolorscales.c:                               gettext (enum_desc->value_help),
libgimpwidgets/gimpcolorselect.c:                                                         gettext (enum_desc->value_desc));
libgimpwidgets/gimpcolorselect.c:            gimp_help_set_help_data (button, gettext (enum_desc->value_help),
plug-ins/common/compose.c:                            type_desc->str,
plug-ins/common/compose.c:                            type_desc->str,
plug-ins/common/decompose.c:                            type_desc->str,
plug-ins/common/sphere-designer.c:  GimpVector4 p, *v = &disc->a;
plug-ins/common/sphere-designer.c:  t = -(v->x * r->v1.x + v->y * r->v1.y + v->z * r->v1.z - disc->b) /
plug-ins/common/sphere-designer.c:  if (d2 > disc->r * disc->r)
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (args == sc->NIL)
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  first_arg = sc->vptr->pair_car(args);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (!sc->vptr->is_string(first_arg))
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  filename = sc->vptr->string_value(first_arg);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->T;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (args == sc->NIL)
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  first_arg = sc->vptr->pair_car(args);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (!sc->vptr->is_string(first_arg))
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  filename = sc->vptr->string_value(first_arg);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  return sc->vptr->mk_integer(sc, retcode);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (args == sc->NIL)
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  first_arg = sc->vptr->pair_car(args);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (!sc->vptr->is_string(first_arg))
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  filename = sc->vptr->string_value(first_arg);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    ret = sc->vptr->mk_integer(sc,buf.st_size);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    ret = sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (args == sc->NIL)
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  first_arg = sc->vptr->pair_car(args);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (!sc->vptr->is_string(first_arg)) {
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  filename = sc->vptr->string_value(first_arg);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    ret = sc->T;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    ret = sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (args == sc->NIL)
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  first_arg = sc->vptr->pair_car(args);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (!sc->vptr->is_string(first_arg))
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  dirpath = sc->vptr->string_value(first_arg);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  return (sc->vptr->mk_integer(sc, (long) dir));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (args == sc->NIL)
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  first_arg = sc->vptr->pair_car(args);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (!sc->vptr->is_integer(first_arg))
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  dir = (GDir *) sc->vptr->ivalue(first_arg);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->EOF_OBJ;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  return (sc->vptr->mk_string(sc, entry));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (args == sc->NIL)
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  first_arg = sc->vptr->pair_car(args);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (!sc->vptr->is_integer(first_arg))
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  dir = (GDir *) sc->vptr->ivalue(first_arg);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  return sc->T;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (args == sc->NIL)
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  first_arg = sc->vptr->pair_car(args);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (!sc->vptr->is_integer(first_arg))
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  dir = (GDir *) sc->vptr->ivalue(first_arg);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  return sc->T;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (args == sc->NIL)
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  first_arg = sc->vptr->pair_car(args);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (!sc->vptr->is_string(first_arg))
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  dirname = sc->vptr->string_value(first_arg);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  rest = sc->vptr->pair_cdr(args);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (sc->vptr->is_pair(rest)) /* optional mode argument */
plug-ins/script-fu/libscriptfu/ftx/ftx.c:      second_arg = sc->vptr->pair_car(rest);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:      if (!sc->vptr->is_integer(second_arg))
plug-ins/script-fu/libscriptfu/ftx/ftx.c:        return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:      mode = sc->vptr->ivalue(second_arg);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->T;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (args == sc->NIL)
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  first_arg = sc->vptr->pair_car(args);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (!sc->vptr->is_string(first_arg))
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  varname = sc->vptr->string_value(first_arg);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    ret = sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    ret = sc->vptr->mk_string(sc,value);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (args != sc->NIL)
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  ret = sc->vptr->cons(sc, sc->vptr->mk_integer(sc,(long) now_tm->tm_year),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:         sc->vptr->cons(sc, sc->vptr->mk_integer(sc,(long) now_tm->tm_mon),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:          sc->vptr->cons(sc, sc->vptr->mk_integer(sc,(long) now_tm->tm_mday),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:           sc->vptr->cons(sc, sc->vptr->mk_integer(sc,(long) now_tm->tm_hour),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:            sc->vptr->cons(sc, sc->vptr->mk_integer(sc,(long) now_tm->tm_min),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:             sc->vptr->cons(sc, sc->vptr->mk_integer(sc,(long) now_tm->tm_sec),sc->NIL))))));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  ret = sc->vptr->cons(sc, sc->vptr->mk_integer(sc,(long) time / G_USEC_PER_SEC),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:         sc->vptr->cons(sc, sc->vptr->mk_integer(sc,(long) time % G_USEC_PER_SEC),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:          sc->NIL));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (args == sc->NIL)
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  first_arg = sc->vptr->pair_car(args);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  if (!sc->vptr->is_integer(first_arg))
plug-ins/script-fu/libscriptfu/ftx/ftx.c:    return sc->F;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  usec = sc->vptr->ivalue(first_arg);
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  return sc->T;
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  sc->vptr->scheme_define(sc,sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_symbol(sc,"getenv"),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_foreign_func(sc, foreign_getenv));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  sc->vptr->scheme_define(sc, sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_symbol(sc,"time"),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_foreign_func(sc, foreign_time));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  sc->vptr->scheme_define(sc, sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_symbol(sc,"gettimeofday"),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_foreign_func(sc, foreign_gettimeofday));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  sc->vptr->scheme_define(sc, sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_symbol(sc,"usleep"),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_foreign_func(sc, foreign_usleep));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  sc->vptr->scheme_define(sc, sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_symbol(sc,"file-exists?"),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_foreign_func(sc, foreign_fileexists));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  sc->vptr->scheme_define(sc, sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_symbol(sc,"file-type"),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_foreign_func(sc, foreign_filetype));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  sc->vptr->scheme_define(sc, sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_symbol(sc,"file-size"),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_foreign_func(sc, foreign_filesize));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  sc->vptr->scheme_define(sc, sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_symbol(sc,"file-delete"),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_foreign_func(sc, foreign_filedelete));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  sc->vptr->scheme_define(sc, sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_symbol(sc,"dir-open-stream"),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_foreign_func(sc, foreign_diropenstream));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  sc->vptr->scheme_define(sc, sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_symbol(sc,"dir-read-entry"),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_foreign_func(sc, foreign_dirreadentry));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  sc->vptr->scheme_define(sc, sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_symbol(sc,"dir-rewind"),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_foreign_func(sc, foreign_dirrewind));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  sc->vptr->scheme_define(sc, sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_symbol(sc,"dir-close-stream"),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_foreign_func(sc, foreign_dirclosestream));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:  sc->vptr->scheme_define(sc, sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_symbol(sc,"dir-make"),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:                               sc->vptr->mk_foreign_func(sc, foreign_mkdir));
plug-ins/script-fu/libscriptfu/ftx/ftx.c:      sc->vptr->scheme_define(sc, sc->global_env,
plug-ins/script-fu/libscriptfu/ftx/ftx.c:            sc->vptr->mk_symbol(sc, file_type_constants[i].name),
plug-ins/script-fu/libscriptfu/ftx/ftx.c:            sc->vptr->mk_integer(sc, file_type_constants[i].value));
plug-ins/script-fu/libscriptfu/script-fu-compat.c:  sc->vptr->load_string ((scheme *) sc, buff);
plug-ins/script-fu/libscriptfu/script-fu-errors.c:              sc->vptr->vector_length (vector), expected_length);
plug-ins/script-fu/libscriptfu/script-fu-errors.c:  glong count = sc->vptr->vector_length (vector);
plug-ins/script-fu/libscriptfu/script-fu-errors.c:                     sc->vptr->rvalue ( sc->vptr->vector_elem (vector, j) ));
plug-ins/script-fu/libscriptfu/script-fu-errors.c:                     sc->vptr->ivalue ( sc->vptr->vector_elem (vector, j) ));
plug-ins/script-fu/libscriptfu/script-fu-errors.c:  g_return_if_fail (num_elements == sc->vptr->list_length (sc, list));
plug-ins/script-fu/libscriptfu/script-fu-errors.c:          pointer v_element = sc->vptr->pair_car (list);
plug-ins/script-fu/libscriptfu/script-fu-errors.c:                   sc->vptr->string_value ( v_element ));
plug-ins/script-fu/libscriptfu/script-fu-errors.c:          list = sc->vptr->pair_cdr (list);
plug-ins/script-fu/libscriptfu/script-fu-errors.c:           ts_types[ type(sc->vptr->pair_car (a)) ],
plug-ins/script-fu/libscriptfu/script-fu-errors.c:           type(sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/script-fu-regex.c:  sc->vptr->scheme_define (sc,
plug-ins/script-fu/libscriptfu/script-fu-regex.c:                           sc->global_env,
plug-ins/script-fu/libscriptfu/script-fu-regex.c:                           sc->vptr->mk_symbol(sc,"re-match"),
plug-ins/script-fu/libscriptfu/script-fu-regex.c:                           sc->vptr->mk_foreign_func(sc, foreign_re_match));
plug-ins/script-fu/libscriptfu/script-fu-regex.c:  sc->vptr->load_string
plug-ins/script-fu/libscriptfu/script-fu-regex.c:  pointer   retval = sc->F;
plug-ins/script-fu/libscriptfu/script-fu-regex.c:  pointer   third_arg = sc->NIL;
plug-ins/script-fu/libscriptfu/script-fu-regex.c:  if (!((args != sc->NIL)
plug-ins/script-fu/libscriptfu/script-fu-regex.c:        && sc->vptr->is_string ((first_arg = sc->vptr->pair_car (args)))
plug-ins/script-fu/libscriptfu/script-fu-regex.c:        && (args = sc->vptr->pair_cdr (args))
plug-ins/script-fu/libscriptfu/script-fu-regex.c:        && sc->vptr->is_pair (args)
plug-ins/script-fu/libscriptfu/script-fu-regex.c:        && sc->vptr->is_string ((second_arg = sc->vptr->pair_car (args)))))
plug-ins/script-fu/libscriptfu/script-fu-regex.c:      return sc->F;
plug-ins/script-fu/libscriptfu/script-fu-regex.c:  pattern = sc->vptr->string_value (first_arg);
plug-ins/script-fu/libscriptfu/script-fu-regex.c:  string  = sc->vptr->string_value (second_arg);
plug-ins/script-fu/libscriptfu/script-fu-regex.c:  args = sc->vptr->pair_cdr (args);
plug-ins/script-fu/libscriptfu/script-fu-regex.c:  if (args != sc->NIL)
plug-ins/script-fu/libscriptfu/script-fu-regex.c:      if (!(sc->vptr->is_pair (args)
plug-ins/script-fu/libscriptfu/script-fu-regex.c:            && sc->vptr->is_vector ((third_arg = sc->vptr->pair_car (args)))))
plug-ins/script-fu/libscriptfu/script-fu-regex.c:          return sc->F;
plug-ins/script-fu/libscriptfu/script-fu-regex.c:    return sc->F;
plug-ins/script-fu/libscriptfu/script-fu-regex.c:                           sc->vptr->cons(sc,
plug-ins/script-fu/libscriptfu/script-fu-regex.c:                                          sc->vptr->mk_integer(sc, start),
plug-ins/script-fu/libscriptfu/script-fu-regex.c:                                          sc->vptr->mk_integer(sc, end)));
plug-ins/script-fu/libscriptfu/script-fu-regex.c:    retval = sc->T;
plug-ins/script-fu/libscriptfu/tinyscheme/CHANGES:        Added tests for when mk_vector is out of memory. Can't rely on sc->sink.
plug-ins/script-fu/libscriptfu/tinyscheme/CHANGES:    that sc->outport be set to NIL in scheme_deinit, which I did.
plug-ins/script-fu/libscriptfu/tinyscheme/CHANGES:    Dennis Taylor remarked that OP_VALUEPRINT reset sc->value instead
plug-ins/script-fu/libscriptfu/tinyscheme/Manual.txt:           if(args!=sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/Manual.txt:               if(sc->isnumber(sc->pair_car(args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/Manual.txt:                    double v=sc->rvalue(sc->pair_car(args));
plug-ins/script-fu/libscriptfu/tinyscheme/Manual.txt:                    return sc->mk_real(sc,v*v);
plug-ins/script-fu/libscriptfu/tinyscheme/Manual.txt:           return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/Manual.txt:   sc->interface->scheme_define(
plug-ins/script-fu/libscriptfu/tinyscheme/Manual.txt:        sc->global_env,
plug-ins/script-fu/libscriptfu/tinyscheme/Manual.txt:        sc->interface->mk_symbol(sc,"square"),
plug-ins/script-fu/libscriptfu/tinyscheme/Manual.txt:        sc->interface->mk_foreign_func(sc, square));
plug-ins/script-fu/libscriptfu/tinyscheme/Manual.txt:     manipulate Scheme data is using the function pointers in sc->interface.
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          char *p=(char*)sc->malloc(len);
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          x = get_cell(sc, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:|               sc->free(strvalue(a));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               sc->free(strvalue(a));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:|         p = sc->strbuff;
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(!isnumber(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               Error_1(sc,"make-block: not a number:",car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          len=ivalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               Error_1(sc,"make-block: not positive:",car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(cdr(sc->args)!=sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               if(!isnumber(cadr(sc->args)) || ivalue(cadr(sc->args))<0) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>                    Error_1(sc,"make-block: not a positive number:",cadr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               fill=charvalue(cadr(sc->args))%255;
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(!ismemblock(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               Error_1(sc,"block-length: not a memory block:",car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          s_return(sc,mk_integer(sc,keynum(car(sc->args))));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(!ismemblock(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               Error_1(sc,"block-ref: not a memory block:",car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          str=strvalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(cdr(sc->args)==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(!isnumber(cadr(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               Error_1(sc,"block-ref: not a number:",cadr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          index=ivalue(cadr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(index<0 || index>=keynum(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               Error_1(sc,"block-ref: out of bounds:",cadr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(!ismemblock(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               Error_1(sc,"block-set!: not a memory block:",car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(isimmutable(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               Error_1(sc,"block-set!: unable to alter immutable memory block:",car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          str=strvalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(cdr(sc->args)==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(!isnumber(cadr(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               Error_1(sc,"block-set!: not a number:",cadr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          index=ivalue(cadr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(index<0 || index>=keynum(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               Error_1(sc,"block-set!: out of bounds:",cadr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(cddr(sc->args)==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          if(!isinteger(caddr(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>               Error_1(sc,"block-set!: not an integer:",caddr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          c=ivalue(caddr(sc->args))%255;
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          s_return(sc,car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:|          s_retbool(isvector(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/hack.txt:>          s_retbool(ismemblock(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/dynload.c:   if ((args != sc->NIL) && is_string((first_arg = pair_car(args)))) {
plug-ins/script-fu/libscriptfu/tinyscheme/dynload.c:            retval = sc->F;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (sc->last_cell_seg >= CELL_NSEGMENT - 1)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          cp = (char*) sc->malloc(CELL_SEGSIZE * sizeof(struct cell)+adj);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          i = ++sc->last_cell_seg ;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->alloc_seg[i] = cp;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        sc->cell_seg[i] = newp;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        while (i > 0 && sc->cell_seg[i - 1] > sc->cell_seg[i]) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:              p = sc->cell_seg[i];
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            sc->cell_seg[i] = sc->cell_seg[i - 1];
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            sc->cell_seg[--i] = p;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->fcells += CELL_SEGSIZE;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               car(p) = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        if (sc->free_cell == sc->NIL || p < sc->free_cell) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:             cdr(last) = sc->free_cell;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:             sc->free_cell = newp;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:              p = sc->free_cell;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:              while (cdr(p) != sc->NIL && newp > cdr(p))
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if (sc->free_cell != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    pointer x = sc->free_cell;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->free_cell = cdr(x);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    --sc->fcells;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if(sc->no_memory) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    return sc->sink;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if (sc->free_cell == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    const int min_to_be_recovered = sc->last_cell_seg*8;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    if (sc->fcells < min_to_be_recovered
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        || sc->free_cell == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:      if (!alloc_cellseg(sc,1) && sc->free_cell == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        sc->no_memory=1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        return sc->sink;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  x = sc->free_cell;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->free_cell = cdr(x);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  --sc->fcells;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       if(sc->no_memory) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       if (sc->fcells < n) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               gc(sc, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if (sc->fcells < n) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                               sc->no_memory=1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                               return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if (sc->fcells < n) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                       sc->no_memory=1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                       return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       return (sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if(sc->no_memory) { return sc->sink; }
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if (x != sc->NIL) { return x; }
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  gc(sc, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if (x != sc->NIL) { return x; }
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:      sc->no_memory=1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:      return sc->sink;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if (x != sc->NIL) { return x; }
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->no_memory=1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  return sc->sink;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  pp=&sc->free_cell;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  while(*pp!=sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:      sc->fcells -= n;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  cdr(holder) = car(sc->sink);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  car(sc->sink) = holder;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  push_recent_alloc(sc, cell, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if(sc->no_memory) { return sc->sink; }
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  push_recent_alloc(sc, cells, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  car(sc->sink) = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  x = immutable_cons(sc, mk_string(sc, name), sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  location = hash_fn(name, ivalue_unchecked(sc->oblist));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  set_vector_elem(sc->oblist, location,
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                  immutable_cons(sc, x, vector_elem(sc->oblist, location)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  location = hash_fn(name, ivalue_unchecked(sc->oblist));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  for (x = vector_elem(sc->oblist, location); x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  pointer ob_list = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  for (i = 0; i < ivalue_unchecked(sc->oblist); i++) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    for (x  = vector_elem(sc->oblist, i); x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     for (x = sc->oblist; x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  x = immutable_cons(sc, mk_string(sc, name), sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->oblist = immutable_cons(sc, x, sc->oblist);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  return sc->oblist;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  pointer x = get_cell(sc, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  pointer x = get_cell(sc, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  pointer x = get_cell (sc, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:      return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  x = get_cell(sc,sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  pointer x = get_cell(sc,sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  pointer x = get_cell(sc,sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->foreign_error = cons (sc, mk_string (sc, s), a);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  return sc->T;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       q=(gchar*)sc->malloc(len+1);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       q=(gchar*)sc->malloc(char_cnt*len+1);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       sc->no_memory=1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       return sc->strbuff;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     pointer x = get_cell(sc, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     pointer x = get_cell(sc, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:{ return get_vector_object(sc,len,sc->NIL); }
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     if (x != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     for(; sc->gensym_cnt<LONG_MAX; sc->gensym_cnt++) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          snprintf(name,40,"gensym-%ld",sc->gensym_cnt);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (x != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          return cons(sc, sc->COLON_HOOK,
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                                   sc->QUOTE,
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                                   cons(sc, mk_atom(sc,p+2), sc->NIL)),
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                              cons(sc, mk_symbol(sc,strlwr(q)), sc->NIL)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          return (sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          return (sc->F);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:              return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                  return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          return (sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if(sc->gc_verbose) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  mark(sc->oblist);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  mark(sc->global_env);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  mark(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  mark(sc->envir);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  mark(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  mark(sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  mark(sc->inport);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  mark(sc->save_inport);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  mark(sc->outport);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  mark(sc->loadport);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  mark(car(sc->sink));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  mark(sc->c_nest);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  clrmark(sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->fcells = 0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->free_cell = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  for (i = sc->last_cell_seg; i >= 0; i--) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    p = sc->cell_seg[i] + CELL_SEGSIZE;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    while (--p >= sc->cell_seg[i]) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          car(p) = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        ++sc->fcells;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        cdr(p) = sc->free_cell;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        sc->free_cell = p;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if (sc->gc_verbose) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    snprintf(msg,80,"done: %ld cells were recovered.\n", sc->fcells);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->free(strvalue(a));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->free(a->_object._port);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c: if (sc->file_i == MAXFIL-1)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->file_i++;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->load_stack[sc->file_i].kind=port_file|port_input;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->load_stack[sc->file_i].rep.stdio.file=fin;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->load_stack[sc->file_i].rep.stdio.closeit=1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->nesting_stack[sc->file_i]=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->loadport->_object._port=sc->load_stack+sc->file_i;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->load_stack[sc->file_i].rep.stdio.curr_line = 0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:      sc->load_stack[sc->file_i].rep.stdio.filename = store_string(sc, strlen(fname), fname, 0);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c: if(sc->file_i != 0) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     sc->nesting=sc->nesting_stack[sc->file_i];
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     port_close(sc,sc->loadport,port_input);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     sc->file_i--;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     sc->loadport->_object._port=sc->load_stack+sc->file_i;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c: return sc->file_i==0 && sc->load_stack[0].rep.stdio.file==stdin
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     && sc->inport->_object._port->kind&port_file;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    pt = (port *)sc->malloc(sizeof *pt);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  pt=(port*)sc->malloc(sizeof(port));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  pt=(port*)sc->malloc(sizeof(port));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  start=sc->malloc(BLOCK_SIZE);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        sc->free(pt->rep.stdio.filename);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  pt = sc->inport->_object._port;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if (result == EOF && sc->inport == sc->loadport)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  pt = sc->inport->_object._port;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  char *str=sc->malloc(new_size);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->free(start);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  port *pt=sc->outport->_object._port;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  char *p = sc->strbuff;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  } while ((p - sc->strbuff < sizeof(sc->strbuff)) &&
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if(p == sc->strbuff+2 && c_prev == '\\')
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  return sc->strbuff;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  char *p = sc->strbuff;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    if(c == EOF || p-sc->strbuff > sizeof(sc->strbuff)-1) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:      return sc->F;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        return mk_counted_string(sc,sc->strbuff,
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                                 g_utf8_strlen(sc->strbuff, sizeof(sc->strbuff)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         return sc->F;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          return sc->F;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     if (sc->load_stack[sc->file_i].kind & port_file)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       sc->load_stack[sc->file_i].rep.stdio.curr_line += curr_line;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:           if(c == '\n' && sc->load_stack[sc->file_i].kind & port_file)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:             sc->load_stack[sc->file_i].rep.stdio.curr_line++;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:           if(c == '\n' && sc->load_stack[sc->file_i].kind & port_file)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:             sc->load_stack[sc->file_i].rep.stdio.curr_line++;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:#define   ok_abbrev(x)   (is_pair(x) && cdr(x) == sc->NIL)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     if (l == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     } else if (l == sc->T) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     } else if (l == sc->F) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     } else if (l == sc->EOF_OBJ) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          p = sc->strbuff;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               *pp=sc->strbuff;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         p        = sc->strbuff;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               p = sc->strbuff;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          p = sc->strbuff;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          p = sc->strbuff;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     pointer x = get_cell(sc, sc->NIL, d);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if(cdr(d)==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  while(cdr(cdr(p))!=sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    if(cdr(cdr(p))!=sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     pointer p = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     while (p != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    if (p == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    return sc->F;   /* signal an error */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:#define is_true(p)       ((p) != sc->F)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:#define is_false(p)      ((p) == sc->F)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if (old_env == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    new_frame = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->envir = immutable_cons(sc, new_frame, old_env);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  setenvironment(sc->envir);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  for (x = env; x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    for ( ; y != sc->NIL; y = cdr(y)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         if (y != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:           return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    if (x != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->envir = immutable_cons(sc, sc->NIL, old_env);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  setenvironment(sc->envir);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    for (x = env; x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         for (y = car(x); y != sc->NIL; y = cdr(y)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         if (y != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:           return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    if (x != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  new_slot_spec_in_env(sc, sc->envir, variable, value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     pointer hdl=sc->ERROR_HOOK;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     if (sc->load_stack[sc->file_i].kind & port_file &&
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         sc->load_stack[sc->file_i].rep.stdio.file != stdin) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       int ln = sc->load_stack[sc->file_i].rep.stdio.curr_line;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       const char *fname = sc->load_stack[sc->file_i].rep.stdio.filename;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     x=find_slot_in_env(sc,sc->envir,hdl,1);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    if (x != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cons(sc, cons(sc, sc->QUOTE, cons(sc,(a), sc->NIL)), sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         sc->code = cons(sc, mk_string(sc, str), sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         setimmutable(car(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         sc->code = cons(sc, slot_value_in_env(x), sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         sc->op = (int)OP_EVAL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         return sc->T;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = cons(sc, (a), sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->args = cons(sc, mk_string(sc, str), sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    setimmutable(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->op = (int)OP_ERR0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    return sc->T;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->op = (int)(a);                                      \
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    return sc->T; END
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  int nframes = (int)sc->dump;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if (nframes >= sc->dump_size) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->dump_size += STACK_GROWTH;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    /* alas there is no sc->realloc */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->dump_base = realloc(sc->dump_base,
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                            sizeof(struct dump_stack_frame) * sc->dump_size);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  next_frame = (struct dump_stack_frame *)sc->dump_base + nframes;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  next_frame->envir = sc->envir;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->dump = (pointer)(nframes+1);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  int nframes = (int)sc->dump;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->value = (a);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  frame = (struct dump_stack_frame *)sc->dump_base + nframes;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->op = frame->op;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->args = frame->args;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->envir = frame->envir;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->code = frame->code;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->dump = (pointer)nframes;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  return sc->T;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  /* in this implementation, sc->dump is the number of frames on the stack */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->dump = (pointer)0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->dump_size = 0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->dump_base = NULL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  free(sc->dump_base);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->dump_base = NULL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->dump = (pointer)0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->dump_size = 0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  int nframes = (int)sc->dump;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    frame = (struct dump_stack_frame *)sc->dump_base + i;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->dump = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->dump = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->value = (a);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    if(sc->dump==sc->NIL) return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->op = ivalue(car(sc->dump));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->args = cadr(sc->dump);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->envir = caddr(sc->dump);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->code = cadddr(sc->dump);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->dump = cddddr(sc->dump);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    return sc->T;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->dump = cons(sc, sc->envir, cons(sc, (code), sc->dump));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->dump = cons(sc, (args), sc->dump);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->dump = cons(sc, mk_integer(sc, (long)(op)), sc->dump);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  mark(sc->dump);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:#define s_retbool(tf)    s_return(sc,(tf) ? sc->T : sc->F)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               fprintf(sc->outport->_object._port->rep.stdio.file,
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                       "Loading %s\n", strvalue(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (!file_push(sc,strvalue(car(sc->args)))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               Error_1(sc,"unable to open", car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            sc->args = mk_integer(sc,sc->file_i);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       if(sc->loadport->_object._port->kind & port_saw_EOF)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:           if(sc->file_i == 0)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:           sc->envir = sc->global_env;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       sc->nesting=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       sc->save_inport=sc->inport;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       sc->inport = sc->loadport;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       s_save(sc,OP_T0LVL, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       s_save(sc,OP_VALUEPRINT, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       s_save(sc,OP_T1LVL, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = sc->value;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->inport=sc->save_inport;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->tok = token(sc);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(sc->tok==TOK_EOF)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            { s_return(sc,sc->EOF_OBJ); }
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       if(sc->tracing) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       if(file_interactive(sc) || sc->print_output) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         sc->print_flag = 1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         sc->args = sc->value;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         s_return(sc,sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       if(sc->tracing) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         /*s_save(sc,OP_VALUEPRINT,sc->NIL,sc->NIL);*/
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         s_save(sc,OP_REAL_EVAL,sc->args,sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         sc->args=sc->code;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_symbol(sc->code)) {    /* symbol */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               x=find_slot_in_env(sc,sc->envir,sc->code,1);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if (x != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    Error_1(sc,"eval: unbound variable:", sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (is_pair(sc->code)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if (is_syntax(x = car(sc->code))) {     /* SYNTAX */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->code = cdr(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    s_save(sc,OP_E0ARGS, sc->NIL, sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    /* If no macros => s_save(sc,OP_E1ARGS, sc->NIL, cdr(sc->code));*/
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->code = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_macro(sc->value)) {    /* macro expansion */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_DOMACRO, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = cons(sc,sc->code, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = sc->value;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cdr(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = cons(sc, sc->value, sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_pair(sc->code)) { /* continue */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_E1ARGS, sc->args, cdr(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = reverse_in_place(sc, sc->NIL, sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = cdr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       int tr=sc->tracing;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       sc->tracing=ivalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       if(sc->tracing) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         s_save(sc,OP_REAL_APPLY,sc->args,sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         sc->print_flag = 1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         /*  sc->args=cons(sc,sc->code,sc->args);*/
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_proc(sc->code)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_goto(sc,procnum(sc->code));   /* PROCEDURE */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (is_foreign(sc->code))
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               push_recent_alloc(sc,sc->args,sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->foreign_error = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               x=sc->code->_object._ff(sc,sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if (sc->foreign_error == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                   x = sc->foreign_error;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                   sc->foreign_error = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (is_closure(sc->code) || is_macro(sc->code)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                     || is_promise(sc->code)) { /* CLOSURE */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               new_frame_in_env(sc, closure_env(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               for (x = car(closure_code(sc->code)), y = sc->args;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    if (y == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if (x == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                     * if (y != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cdr(closure_code(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (is_continuation(sc->code)) { /* CONTINUATION */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->dump = cont_dump(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->args != sc->NIL ? car(sc->args) : sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = sc->value;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          /* If the hook is defined, apply it to sc->code, otherwise
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:             set sc->value fall thru */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               pointer f=find_slot_in_env(sc,sc->envir,sc->COMPILE_HOOK,1);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if(f==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->value = sc->code;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    s_save(sc,OP_LAMBDA1,sc->args,sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->args=cons(sc,sc->code,sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->code=slot_value_in_env(f);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,mk_closure(sc, sc->value, sc->envir));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,mk_closure(sc, sc->code, sc->envir));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       if(car(x)==sc->LAMBDA) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       if(cdr(sc->args)==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         y=sc->envir;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         y=cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,car(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(is_immutable(car(sc->code)))
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                Error_1(sc,"define: unable to alter immutable", car(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_pair(car(sc->code))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               x = caar(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cons(sc, sc->LAMBDA, cons(sc, cdar(sc->code), cdr(sc->code)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               x = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cadr(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_save(sc,OP_DEF1, sc->NIL, x);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=find_slot_in_env(sc,sc->envir,sc->code,0);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (x != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               set_slot_in_env(sc, x, sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               new_slot_in_env(sc, sc->code, sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=sc->envir;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(cdr(sc->args)!=sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               x=cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(find_slot_in_env(sc,x,car(sc->args),1)!=sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(is_immutable(car(sc->code)))
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                Error_1(sc,"set!: unable to alter immutable variable",car(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_save(sc,OP_SET1, sc->NIL, car(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = cadr(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          y=find_slot_in_env(sc,sc->envir,sc->code,1);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (y != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:             set_slot_in_env(sc, y, sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:             s_return(sc,sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:             Error_1(sc,"set!: unbound variable:", sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (!is_pair(sc->code)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (cdr(sc->code) != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_BEGIN, sc->NIL, cdr(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_save(sc,OP_IF1, sc->NIL, cdr(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_true(sc->value))
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cadr(sc->code);  /* (if #f 1) ==> () because
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                                            * car(sc->NIL) = sc->NIL */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->value = sc->code;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = is_symbol(car(sc->code)) ? cadr(sc->code) : car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = cons(sc, sc->value, sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_pair(sc->code)) { /* continue */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if (!is_pair(car(sc->code)) || !is_pair(cdar(sc->code))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    Error_1(sc, "Bad syntax of binding spec in let :", car(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_LET1, sc->args, cdr(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cadar(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = reverse_in_place(sc, sc->NIL, sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = cdr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          new_frame_in_env(sc, sc->envir);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          for (x = is_symbol(car(sc->code)) ? cadr(sc->code) : car(sc->code), y = sc->args;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               y != sc->NIL; x = cdr(x), y = cdr(y)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_symbol(car(sc->code))) {    /* named let */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               for (x = cadr(sc->code), sc->args = sc->NIL; x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->args = cons(sc, caar(x), sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               x = mk_closure(sc, cons(sc, reverse_in_place(sc, sc->NIL, sc->args), cddr(sc->code)), sc->envir);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               new_slot_in_env(sc, car(sc->code), x);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cddr(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cdr(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (car(sc->code) == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               new_frame_in_env(sc, sc->envir);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cdr(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(!is_pair(car(sc->code)) || !is_pair(caar(sc->code)) || !is_pair(cdaar(sc->code))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               Error_1(sc,"Bad syntax of binding spec in let* :",car(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_save(sc,OP_LET1AST, cdr(sc->code), car(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = cadaar(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          new_frame_in_env(sc, sc->envir);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          new_slot_in_env(sc, caar(sc->code), sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = cdr(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_pair(sc->code)) { /* continue */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_LET2AST, sc->args, sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cadar(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = sc->args;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          snprintf(sc->strbuff,STRBUFFSIZE,"%d: illegal operator", sc->op);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          Error_0(sc,sc->strbuff);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     return sc->T;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          new_frame_in_env(sc, sc->envir);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->value = sc->code;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = cons(sc, sc->value, sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_pair(sc->code)) { /* continue */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if (!is_pair(car(sc->code)) || !is_pair(cdar(sc->code))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    Error_1(sc,"Bad syntax of binding spec in letrec :",car(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_LET1REC, sc->args, cdr(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cadar(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = reverse_in_place(sc, sc->NIL, sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = cdr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          for (x = car(sc->code), y = sc->args; y != sc->NIL; x = cdr(x), y = cdr(y)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = cdr(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (!is_pair(sc->code)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_save(sc,OP_COND1, sc->NIL, sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = caar(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_true(sc->value)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if ((sc->code = cdar(sc->code)) == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    s_return(sc,sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if(!sc->code) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if(!sc->code || car(sc->code)==sc->FEED_TO) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    if(!is_pair(cdr(sc->code))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    x=cons(sc, sc->QUOTE, cons(sc, sc->value, sc->NIL));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->code=cons(sc,cadr(sc->code),cons(sc,x,sc->NIL));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if ((sc->code = cdr(sc->code)) == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    s_return(sc,sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    s_save(sc,OP_COND1, sc->NIL, sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->code = caar(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x = mk_closure(sc, cons(sc, sc->NIL, sc->code), sc->envir);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (sc->code == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_save(sc,OP_AND1, sc->NIL, cdr(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_false(sc->value)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (sc->code == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_AND1, sc->NIL, cdr(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (sc->code == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->F);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_save(sc,OP_OR1, sc->NIL, cdr(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_true(sc->value)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (sc->code == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_OR1, sc->NIL, cdr(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_save(sc,OP_C1STREAM, sc->NIL, cdr(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = sc->value;  /* save sc->value to register sc->args for gc */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x = mk_closure(sc, cons(sc, sc->NIL, sc->code), sc->envir);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,cons(sc, sc->args, x));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_pair(car(sc->code))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               x = caar(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cons(sc, sc->LAMBDA, cons(sc, cdar(sc->code), cdr(sc->code)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               x = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->code = cadr(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_save(sc,OP_MACRO1, sc->NIL, x);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          typeflag(sc->value) = T_MACRO;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x = find_slot_in_env(sc, sc->envir, sc->code, 0);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (x != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               set_slot_in_env(sc, x, sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               new_slot_in_env(sc, sc->code, sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_save(sc,OP_CASE1, sc->NIL, cdr(sc->code));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = car(sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          for (x = sc->code; x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               for ( ; y != sc->NIL; y = cdr(y)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    if (eqv(car(y), sc->value)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if (y != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (x != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->code = cdar(x);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    s_save(sc,OP_CASE2, sc->NIL, cdar(x));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->code = caar(x);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_true(sc->value)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = list_star(sc,cdr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          /*sc->args = cadr(sc->args);*/
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(cdr(sc->args)!=sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->envir=cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = cons(sc, mk_continuation(sc, sc->dump), sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          snprintf(sc->strbuff,STRBUFFSIZE,"%d: illegal operator", sc->op);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          Error_0(sc,sc->strbuff);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     return sc->T;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(cdr(sc->args)==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               y=cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          y=cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       for (x = sc->args; x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       for (x = sc->args; x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       if(cdr(sc->args)==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         x=sc->args;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         x = cdr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         v = nvalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       for (; x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       if(cdr(sc->args)==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         x=sc->args;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         x = cdr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         v = nvalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       for (; x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          v = nvalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x = cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          v = nvalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x = cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          v = nvalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x = cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       s_return(sc,caar(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       s_return(sc,cdar(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          cdr(sc->args) = cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       if(!is_immutable(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         caar(sc->args) = cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         s_return(sc,car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       if(!is_immutable(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         cdar(sc->args) = cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:         s_return(sc,car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        b = ivalue (car (sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        b = ivalue (car (sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          c=ivalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          c=(gunichar)ivalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          c=(gunichar)ivalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          c=(gunichar)ivalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,mk_symbol(sc,strvalue(car(sc->args))));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          char *s=strvalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(cdr(sc->args)!=sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            /* we know cadr(sc->args) is a natural number */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            pf = ivalue_unchecked(cadr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            Error_1(sc, "string->atom: bad base:", cadr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                s_return(sc, sc->F);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=mk_string(sc,symname(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          y=cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(y!=sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            /* we know cadr(sc->args) is a natural number */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          len=ivalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(cdr(sc->args)!=sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               fill=charvalue(cadr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,mk_integer(sc,g_utf8_strlen(strvalue(car(sc->args)), -1)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          str=strvalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(index>=g_utf8_strlen(strvalue(car(sc->args)), -1)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          y=cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          c=charvalue(caddr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          newstr = (char *)sc->malloc(newlen+1);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:             sc->no_memory=1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       for (x = sc->args; x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       newstr = (char *)sc->malloc(len+1);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->no_memory=1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          Error_1(sc,"string-set!: No memory to append strings:",car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:       for (x = sc->args; x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          str=strvalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          index0=ivalue(cadr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               Error_1(sc,"substring: start out of bounds:",cadr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(cddr(sc->args)!=sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               index1=ivalue(caddr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    Error_1(sc,"substring: end out of bounds:",caddr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          str = (char *)sc->malloc(len+1);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:             sc->no_memory=1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:             Error_1(sc,"string-set!: No memory to extract substring:",car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          int len=list_length(sc,sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               Error_1(sc,"vector: not a proper list:",sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(sc->no_memory) { s_return(sc, sc->sink); }
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          for (x = sc->args, i = 0; is_pair(x); x = cdr(x), i++) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          pointer fill=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          len=ivalue(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(cdr(sc->args)!=sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               fill=cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(sc->no_memory) { s_return(sc, sc->sink); }
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(fill!=sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,mk_integer(sc,ivalue(car(sc->args))));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(index>=ivalue(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,vector_elem(car(sc->args),index));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(is_immutable(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               Error_1(sc,"vector-set!: unable to alter immutable vector:",car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(index>=ivalue(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          set_vector_elem(car(sc->args),index,caddr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          snprintf(sc->strbuff,STRBUFFSIZE,"%d: illegal operator", sc->op);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          Error_0(sc,sc->strbuff);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     return sc->T;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        if (fast == sc->NIL)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        if (fast == sc->NIL)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_false(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(car(sc->args) == sc->F || car(sc->args) == sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(car(sc->args) == sc->EOF_OBJ);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(car(sc->args) == sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=sc->args;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          for (; x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_symbol(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_number(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_string(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_integer(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_number(car(sc->args))); /* All numbers are real */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:      s_retbool (is_byte (car (sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_character(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(Cisalpha(ivalue(car(sc->args))));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(Cisdigit(ivalue(car(sc->args))));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(Cisspace(ivalue(car(sc->args))));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(Cisupper(ivalue(car(sc->args))));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(Cislower(ivalue(car(sc->args))));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_port(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_inport(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_outport(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_proc(car(sc->args)) || is_closure(car(sc->args))
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                 || is_continuation(car(sc->args)) || is_foreign(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_pair(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(list_length(sc,car(sc->args)) >= 0);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_environment(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_vector(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(car(sc->args) == cadr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(eqv(car(sc->args), cadr(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          snprintf(sc->strbuff,STRBUFFSIZE,"%d: illegal operator", sc->op);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          Error_0(sc,sc->strbuff);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     return sc->T;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->code = car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_promise(sc->code)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc, OP_SAVE_FORCED, sc->NIL, sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          memcpy(sc->code,sc->value,sizeof(struct cell));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(is_pair(cdr(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if(cadr(sc->args)!=sc->outport) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    x=cons(sc,sc->outport,sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    s_save(sc,OP_SET_OUTPORT, x, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->outport=cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->print_flag = 1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->print_flag = 0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(is_pair(sc->args)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if(car(sc->args)!=sc->outport) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    x=cons(sc,sc->outport,sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    s_save(sc,OP_SET_OUTPORT, x, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->outport=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->retcode=-1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (!is_string(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args=cons(sc,mk_string(sc," -- "),sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               setimmutable(car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          putstr(sc, strvalue(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = cdr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (sc->args != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_ERR1, cdr(sc->args), sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->print_flag = 1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if(sc->interactive_repl) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    return sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,reverse(sc, car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,list_star(sc,sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          y = sc->args;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          while (cdr(y) != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:              if (x == sc->F) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (!hasprop(car(sc->args)) || !hasprop(cadr(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          for (x = symprop(car(sc->args)), y = cadr(sc->args); x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (x != sc->NIL)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               cdar(x) = caddr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               symprop(car(sc->args)) = cons(sc, cons(sc, y, caddr(sc->args)),
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                                symprop(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (!hasprop(car(sc->args)) || !hasprop(cadr(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          for (x = symprop(car(sc->args)), y = cadr(sc->args); x != sc->NIL; x = cdr(x)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (x != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(is_pair(sc->args)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               gint err_code = ivalue (car (sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->retcode = err_code;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    snprintf (sc->strbuff, STRBUFFSIZE, "script quit with code: %d", err_code);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    putstr (sc, sc->strbuff);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          return (sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          gc(sc, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     {    int  was = sc->gc_verbose;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->gc_verbose = (car(sc->args) != sc->F);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (!is_pair(sc->args) || !is_number(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          alloc_cellseg(sc, (int) ivalue(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->inport);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->outport);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          p=port_from_filename(sc,strvalue(car(sc->args)),prop);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(p==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->F);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                                strvalue (car (sc->args)),
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                                strvalue (car (sc->args)) + strlength (car (sc->args)),
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(p==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->F);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(car(sc->args)==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if(p==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    s_return(sc,sc->F);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               p=port_from_string(sc, strvalue(car(sc->args)),
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                          strvalue(car(sc->args))+strlength(car(sc->args)),
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if(p==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    s_return(sc,sc->F);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if ((p=car(sc->args)->_object._port)->kind&port_string) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               str=sc->malloc(size);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->free(str);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->F);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          port_close(sc,car(sc->args),port_input);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          port_close(sc,car(sc->args),port_output);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->global_env);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->envir);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sprintf(sc->strbuff, "%d: illegal operator", sc->op);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          Error_0(sc,sc->strbuff);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     return sc->T;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     if(sc->nesting!=0) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          int n=sc->nesting;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->nesting=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->retcode=-1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(!is_pair(sc->args)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(!is_inport(car(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               Error_1(sc,"read: not an input port:",car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(car(sc->args)==sc->inport) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=sc->inport;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->inport=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x=cons(sc,x,sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_save(sc,OP_SET_INPORT, x, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        if (is_pair (sc->args))
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            if (car (sc->args) != sc->inport)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                x = sc->inport;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                x = cons (sc, x, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                s_save (sc, OP_SET_INPORT, x, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                sc->inport = car (sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return (sc, sc->EOF_OBJ);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        if (is_pair (sc->args))
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            if (car (sc->args) != sc->inport)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                x = sc->inport;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                x = cons (sc, x, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                s_save(sc, OP_SET_INPORT, x, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                sc->inport = car (sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return (sc, sc->EOF_OBJ);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        pointer p = sc->inport;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        if (is_pair (sc->args))
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            p = car (sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->inport=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->outport=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          switch (sc->tok) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->EOF_OBJ);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->tok = token(sc);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_RDVEC,sc->NIL,sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->tok = token(sc);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if (sc->tok == TOK_RPAREN) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    s_return(sc,sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               } else if (sc->tok == TOK_DOT) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->nesting_stack[sc->file_i]++;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    s_save(sc,OP_RDLIST, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_RDQUOTE, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->tok = token(sc);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->tok = token(sc);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if(sc->tok==TOK_VEC) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                 s_save(sc,OP_RDQQUOTEVEC, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                 sc->tok=TOK_LPAREN;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                 s_save(sc,OP_RDQQUOTE, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_RDUNQUOTE, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->tok = token(sc);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_RDUQTSP, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->tok = token(sc);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if(x==sc->F) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if(x==sc->F) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                 sc->free(strvalue(x));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               pointer f=find_slot_in_env(sc,sc->envir,sc->SHARP_HOOK,1);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if(f==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                    sc->code=cons(sc,slot_value_in_env(f),sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               if ((x = mk_sharp_const(sc, readstr_upto(sc, DELIMITERS))) == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = cons(sc, sc->value, sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->tok = token(sc);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          while (sc->tok == TOK_COMMENT) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->tok = token(sc);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (sc->tok == TOK_EOF)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          else if (sc->tok == TOK_RPAREN) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               else if (sc->load_stack[sc->file_i].kind & port_file)
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                  sc->load_stack[sc->file_i].rep.stdio.curr_line++;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->nesting_stack[sc->file_i]--;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,reverse_in_place(sc, sc->NIL, sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (sc->tok == TOK_DOT) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_RDDOT, sc->args, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->tok = token(sc);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_RDLIST, sc->args, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->nesting_stack[sc->file_i]--;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,reverse_in_place(sc, sc->value, sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,cons(sc, sc->QUOTE, cons(sc, sc->value, sc->NIL)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,cons(sc, sc->QQUOTE, cons(sc, sc->value, sc->NIL)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                             cons(sc,cons(sc, sc->QQUOTE,
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                                  cons(sc,sc->value,sc->NIL)),
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:                                  sc->NIL))));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,cons(sc, sc->UNQUOTE, cons(sc, sc->value, sc->NIL)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_return(sc,cons(sc, sc->UNQUOTESP, cons(sc, sc->value, sc->NIL)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          /*sc->code=cons(sc,mk_proc(sc,OP_VECTOR),sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          /*x=cons(sc,mk_proc(sc,OP_VECTOR),sc->value);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          /*sc->code=mk_proc(sc,OP_VECTOR);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args=sc->value;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args=sc->value;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if(is_vector(sc->args)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args=cons(sc,sc->args,mk_integer(sc,0));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if(is_environment(sc->args)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (!is_pair(sc->args)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               printatom(sc, sc->args, sc->print_flag);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (car(sc->args) == sc->QUOTE && ok_abbrev(cdr(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (car(sc->args) == sc->QQUOTE && ok_abbrev(cdr(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (car(sc->args) == sc->UNQUOTE && ok_abbrev(cdr(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (car(sc->args) == sc->UNQUOTESP && ok_abbrev(cdr(sc->args))) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = cadr(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_P1LIST, cdr(sc->args), sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args = car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (is_pair(sc->args)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            s_save(sc,OP_P1LIST, cdr(sc->args), sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            sc->args = car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if(is_vector(sc->args)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            s_save(sc,OP_P1LIST,sc->NIL,sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            if (sc->args != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:              printatom(sc, sc->args, sc->print_flag);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:            s_return(sc,sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          int i=ivalue_unchecked(cdr(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          pointer vec=car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               ivalue_unchecked(cdr(sc->args))=i+1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_save(sc,OP_PVECFROM, sc->args, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->args=elem;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          snprintf(sc->strbuff,STRBUFFSIZE,"%d: illegal operator", sc->op);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          Error_0(sc,sc->strbuff);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     return sc->T;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          v=list_length(sc,car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               Error_1(sc,"length: not a list:",car(sc->args));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          x = car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          for (y = cadr(sc->args); is_pair(y); y = cdr(y)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->F);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          sc->args = car(sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          if (sc->args == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->F);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (is_closure(sc->args)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,cons(sc, sc->LAMBDA, closure_code(sc->value)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          } else if (is_macro(sc->args)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,cons(sc, sc->LAMBDA, closure_code(sc->value)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               s_return(sc,sc->F);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_closure(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          s_retbool(is_macro(car(sc->args)));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          snprintf(sc->strbuff,STRBUFFSIZE,"%d: illegal operator", sc->op);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          Error_0(sc,sc->strbuff);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     return sc->T; /* NOTREACHED */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->op = op;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    op_code_info *pcd=dispatch_table+sc->op;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:      int n=list_length(sc,sc->args);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:          pointer arglist=sc->args;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:              if(arg!=sc->NIL && !is_pair(arg)) break;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        if(_Error_1(sc,msg,0)==sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        pcd=dispatch_table+sc->op;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    if (pcd->func(sc, (enum scheme_opcodes)sc->op) == sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    if(sc->no_memory) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     y = get_cell(sc, sc->NIL, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->vptr=&vtbl;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->gensym_cnt=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->malloc=malloc;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->free=free;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->last_cell_seg = -1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->sink = &sc->_sink;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->NIL = &sc->_NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->T = &sc->_HASHT;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->F = &sc->_HASHF;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->EOF_OBJ=&sc->_EOF_OBJ;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->free_cell = &sc->_NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->fcells = 0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->no_memory=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->inport=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->outport=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->save_inport=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->loadport=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->nesting=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->interactive_repl=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->print_output=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->no_memory=1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->gc_verbose = 0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->code = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->tracing=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  /* init sc->NIL */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  typeflag(sc->NIL) = (T_ATOM | MARK);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  car(sc->NIL) = cdr(sc->NIL) = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  typeflag(sc->T) = (T_ATOM | MARK);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  car(sc->T) = cdr(sc->T) = sc->T;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  typeflag(sc->F) = (T_ATOM | MARK);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  car(sc->F) = cdr(sc->F) = sc->F;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  typeflag(sc->sink) = (T_PAIR | MARK);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  car(sc->sink) = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->c_nest = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->oblist = oblist_initial_value(sc);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  new_frame_in_env(sc, sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->global_env = sc->envir;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  new_slot_in_env(sc, x, sc->T);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->LAMBDA = mk_symbol(sc, "lambda");
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->QUOTE = mk_symbol(sc, "quote");
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->QQUOTE = mk_symbol(sc, "quasiquote");
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->UNQUOTE = mk_symbol(sc, "unquote");
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->UNQUOTESP = mk_symbol(sc, "unquote-splicing");
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->FEED_TO = mk_symbol(sc, "=>");
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->COLON_HOOK = mk_symbol(sc,"*colon-hook*");
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->ERROR_HOOK = mk_symbol(sc, "*error-hook*");
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->SHARP_HOOK = mk_symbol(sc, "*sharp-hook*");
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->COMPILE_HOOK = mk_symbol(sc, "*compile-hook*");
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  return !sc->no_memory;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->inport=port_from_file(sc,fin,port_input);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->inport=port_from_string(sc,start,past_the_end,port_input);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->outport=port_from_file(sc,fout,port_output);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->outport=port_from_string(sc,start,past_the_end,port_output);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c: sc->ext_data=p;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->oblist=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->global_env=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->envir=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->code=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->args=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->value=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if(is_port(sc->inport)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    typeflag(sc->inport) = T_ATOM;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->inport=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->outport=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if(is_port(sc->save_inport)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    typeflag(sc->save_inport) = T_ATOM;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->save_inport=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if(is_port(sc->loadport)) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    typeflag(sc->loadport) = T_ATOM;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->loadport=sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->gc_verbose=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  gc(sc,sc->NIL,sc->NIL);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  for(i=0; i<=sc->last_cell_seg; i++) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->free(sc->alloc_seg[i]);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  for(i=0; i<sc->file_i; i++) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    if (sc->load_stack[sc->file_i].kind & port_file) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:      fname = sc->load_stack[i].rep.stdio.filename;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        sc->free(fname);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->envir = sc->global_env;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->file_i=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->load_stack[0].kind=port_input|port_file;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->load_stack[0].rep.stdio.file=fin;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->loadport=mk_port(sc,sc->load_stack);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->retcode=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->interactive_repl=1;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->load_stack[0].rep.stdio.curr_line = 0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->load_stack[0].rep.stdio.filename = store_string(sc, strlen(filename), filename, 0);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->load_stack[0].rep.stdio.filename = NULL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->inport=sc->loadport;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->args = mk_integer(sc,sc->file_i);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  typeflag(sc->loadport)=T_ATOM;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if(sc->retcode==0) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->retcode=sc->nesting!=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->envir = sc->global_env;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->file_i=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->load_stack[0].kind=port_input|port_string;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->load_stack[0].rep.string.start=(char*)cmd; /* This func respects const */
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->load_stack[0].rep.string.past_the_end=(char*)cmd+strlen(cmd);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->load_stack[0].rep.string.curr=(char*)cmd;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->loadport=mk_port(sc,sc->load_stack);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->retcode=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->interactive_repl=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->inport=sc->loadport;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->args = mk_integer(sc,sc->file_i);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  typeflag(sc->loadport)=T_ATOM;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  if(sc->retcode==0) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:    sc->retcode=sc->nesting!=0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:     if (x != sc->NIL) {
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:               sc->global_env,
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:{ return scheme_eval(sc, cons(sc,mk_symbol(sc,procname),sc->NIL)); }
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:        car(sc->sink),
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:             sc->envir,
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:             sc->dump));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->c_nest = cons(sc, saved_data, sc->c_nest);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  car(sc->sink) = caar(sc->c_nest);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->envir = cadar(sc->c_nest);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->dump = cdr(cdar(sc->c_nest));
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->c_nest = cdr(sc->c_nest);
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  int old_repl = sc->interactive_repl;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->interactive_repl = 0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->envir = sc->global_env;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->args = args;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->code = func;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->retcode = 0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->interactive_repl = old_repl;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  return sc->value;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  int old_repl = sc->interactive_repl;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->interactive_repl = 0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->args = sc->NIL;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->code = obj;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->retcode = 0;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  sc->interactive_repl = old_repl;
plug-ins/script-fu/libscriptfu/tinyscheme/scheme.c:  return sc->value;
plug-ins/script-fu/libscriptfu/scheme-marshal.c:  guint num_elements = sc->vptr->vector_length (vector);
plug-ins/script-fu/libscriptfu/scheme-marshal.c:      pointer element = sc->vptr->vector_elem (vector, j);
plug-ins/script-fu/libscriptfu/scheme-marshal.c:      if (!sc->vptr->is_number (element))
plug-ins/script-fu/libscriptfu/scheme-marshal.c:      id = sc->vptr->ivalue (element);
plug-ins/script-fu/libscriptfu/scheme-marshal.c:  /* require sc->vptr->is_string (sc->vptr->pair_car (a)) */
plug-ins/script-fu/libscriptfu/scheme-marshal.c:  GFile *gfile = g_file_new_for_path (sc->vptr->string_value (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-marshal.c:  vector = sc->vptr->mk_vector (sc, n);
plug-ins/script-fu/libscriptfu/scheme-marshal.c:      sc->vptr->set_vector_elem (vector, j, sc->vptr->mk_integer (sc, id));
plug-ins/script-fu/libscriptfu/scheme-marshal.c:      /* Alt: list = sc->vptr->cons (sc, sc->vptr->mk_integer (sc, id), list); */
plug-ins/script-fu/libscriptfu/script-fu-scripts.c:  if (sc->vptr->list_length (sc, a) < 7)
plug-ins/script-fu/libscriptfu/script-fu-scripts.c:  if (args_error != sc->NIL)
plug-ins/script-fu/libscriptfu/script-fu-scripts.c:  return sc->NIL;
plug-ins/script-fu/libscriptfu/script-fu-scripts.c:  if (sc->vptr->list_length (sc, a) < 8)
plug-ins/script-fu/libscriptfu/script-fu-scripts.c:  if (args_error != sc->NIL)
plug-ins/script-fu/libscriptfu/script-fu-scripts.c:  if (args_error != sc->NIL)
plug-ins/script-fu/libscriptfu/script-fu-scripts.c:  return sc->NIL;
plug-ins/script-fu/libscriptfu/script-fu-scripts.c:  if (sc->vptr->list_length (sc, a) != 2)
plug-ins/script-fu/libscriptfu/script-fu-scripts.c:  name = sc->vptr->string_value (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/script-fu-scripts.c:  a = sc->vptr->pair_cdr (a);
plug-ins/script-fu/libscriptfu/script-fu-scripts.c:      return sc->NIL;
plug-ins/script-fu/libscriptfu/script-fu-scripts.c:  path = sc->vptr->string_value (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/script-fu-scripts.c:  return sc->NIL;
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:  pointer result = sc->NIL;
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:          result = sc->vptr->cons (sc, scheme_value, result);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:  /* result can be sc->NIL i.e. empty list. */
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:  pointer  result = sc->NIL;
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:          result = sc->vptr->mk_string (sc, parsed_filepath);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:          result = sc->vptr->mk_string (sc, "");
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      result = sc->vptr->mk_string (sc, name);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      result = sc->vptr->mk_integer (sc, id);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      result = sc->vptr->mk_integer (sc, v);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      result = sc->vptr->mk_integer (sc, v);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      result = sc->vptr->mk_real (sc, v);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      result = sc->vptr->mk_integer (sc, v);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      result = sc->vptr->mk_integer (sc, v);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      result = sc->vptr->mk_string (sc, v);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      pointer       vector = sc->vptr->mk_vector (sc, array_length);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:          sc->vptr->set_vector_elem (vector, j,
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                                      sc->vptr->mk_integer (sc, v[j]));
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      pointer       vector   = sc->vptr->mk_vector (sc, n);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:          sc->vptr->set_vector_elem (vector, j,
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                                      sc->vptr->mk_integer (sc, v[j]));
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      pointer        vector = sc->vptr->mk_vector (sc, array_length);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:          sc->vptr->set_vector_elem (vector, j,
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                                      sc->vptr->mk_real (sc, v[j]));
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      pointer        list = sc->NIL;
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:          list = sc->vptr->cons (sc,
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                                  sc->vptr->mk_string (sc,
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      temp_val = sc->vptr->cons
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                    sc->vptr->mk_integer (sc, r),
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                    sc->vptr->cons
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                        sc->vptr->mk_integer (sc, g),
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                        sc->vptr->cons
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                          sc->vptr->mk_integer (sc, b),
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                          sc->NIL)));
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:      pointer  vector   = sc->vptr->mk_vector (sc, array_length);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:          temp_val = sc->vptr->cons
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                        sc->vptr->mk_integer (sc, r),
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                        sc->vptr->cons
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                          sc->vptr->mk_integer (sc, g),
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                          sc->vptr->cons
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                              sc->vptr->mk_integer (sc, b),
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                              sc->NIL)));
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:          sc->vptr->set_vector_elem (vector, j, temp_val);
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:          temp_val = sc->vptr->cons
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                        sc->vptr->mk_string (sc, v->name),
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                        sc->vptr->cons
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                            sc->vptr->mk_integer (sc, v->flags),
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                            sc->vptr->cons
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                              sc->vptr->mk_counted_string (sc,
plug-ins/script-fu/libscriptfu/scheme-marshal-return.c:                              sc->NIL)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  symbol = sc->vptr->mk_symbol (sc, "gimp-directory");
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->scheme_define (sc, sc->global_env, symbol,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                           sc->vptr->mk_string (sc, gimp_directory ()));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->setimmutable (symbol);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  symbol = sc->vptr->mk_symbol (sc, "gimp-data-directory");
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->scheme_define (sc, sc->global_env, symbol,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                           sc->vptr->mk_string (sc, gimp_data_directory ()));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->setimmutable (symbol);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  symbol = sc->vptr->mk_symbol (sc, "gimp-plug-in-directory");
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->scheme_define (sc, sc->global_env, symbol,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                           sc->vptr->mk_string (sc, gimp_plug_in_directory ()));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->setimmutable (symbol);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  symbol = sc->vptr->mk_symbol (sc, "gimp-locale-directory");
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->scheme_define (sc, sc->global_env, symbol,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                           sc->vptr->mk_string (sc, gimp_locale_directory ()));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->setimmutable (symbol);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  symbol = sc->vptr->mk_symbol (sc, "gimp-sysconf-directory");
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->scheme_define (sc, sc->global_env, symbol,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                           sc->vptr->mk_string (sc, gimp_sysconf_directory ()));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->setimmutable (symbol);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:      symbol = sc->vptr->mk_symbol (sc, script_constants[i].name);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:      sc->vptr->scheme_define (sc, sc->global_env, symbol,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                               sc->vptr->mk_integer (sc,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:      sc->vptr->setimmutable (symbol);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  symbol = sc->vptr->mk_symbol (sc, "DIR-SEPARATOR");
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->scheme_define (sc, sc->global_env, symbol,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                           sc->vptr->mk_string (sc, G_DIR_SEPARATOR_S));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->setimmutable (symbol);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  symbol = sc->vptr->mk_symbol (sc, "SEARCHPATH-SEPARATOR");
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->scheme_define (sc, sc->global_env, symbol,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                           sc->vptr->mk_string (sc, G_SEARCHPATH_SEPARATOR_S));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->setimmutable (symbol);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  symbol = sc->vptr->mk_symbol (sc, "gimp-dir");
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->scheme_define (sc, sc->global_env, symbol,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                           sc->vptr->mk_string (sc, gimp_directory ()));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->setimmutable (symbol);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  symbol = sc->vptr->mk_symbol (sc, "gimp-data-dir");
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->scheme_define (sc, sc->global_env, symbol,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                           sc->vptr->mk_string (sc, gimp_data_directory ()));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->setimmutable (symbol);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  symbol = sc->vptr->mk_symbol (sc, "gimp-plugin-dir");
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->scheme_define (sc, sc->global_env, symbol,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                           sc->vptr->mk_string (sc, gimp_plug_in_directory ()));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->setimmutable (symbol);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:      symbol = sc->vptr->mk_symbol (sc, scheme_name);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:      sc->vptr->scheme_define (sc, sc->global_env, symbol,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                               sc->vptr->mk_integer (sc, int_value));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:      sc->vptr->setimmutable (symbol);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  symbol = sc->vptr->mk_symbol (sc, symbol_name);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->scheme_define (sc, sc->global_env, symbol,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                           sc->vptr->mk_foreign_func (sc, func));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  sc->vptr->setimmutable (symbol);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:      sc->vptr->load_string (sc, buff);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  pointer          return_val = sc->NIL;
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  if (a == sc->NIL)
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  if (sc->vptr->is_pair (a))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:    proc_name = g_strdup (sc->vptr->string_value (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:    proc_name = g_strdup (sc->vptr->string_value (a));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  g_debug ("parms rcvd: %d", sc->vptr->list_length (sc, a)-1);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  actual_arg_count = sc->vptr->list_length (sc, a) - 1;
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:        a = sc->vptr->pair_cdr (a);  /* advance pointer to next arg in list. */
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                             sc->vptr->ivalue (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                              sc->vptr->ivalue (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                               sc->vptr->ivalue (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                                sc->vptr->rvalue (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                              sc->vptr->ivalue (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                                 sc->vptr->ivalue (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                                  sc->vptr->string_value (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          vector = sc->vptr->pair_car (a);  /* vector is pointing to a list */
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_list (sc, vector))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              n_elements = sc->vptr->list_length (sc, vector);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  pointer v_element = sc->vptr->pair_car (vector);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  if (!sc->vptr->is_string (v_element))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  array[j] = g_strdup (sc->vptr->string_value (v_element));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  vector = sc->vptr->pair_cdr (vector);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                glong count = sc->vptr->list_length ( sc, sc->vptr->pair_car (a) );
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                gimp_display_get_by_id (sc->vptr->ivalue (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                gimp_image_get_by_id (sc->vptr->ivalue (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                gimp_layer_get_by_id (sc->vptr->ivalue (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                gimp_layer_mask_get_by_id (sc->vptr->ivalue (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                gimp_channel_get_by_id (sc->vptr->ivalue (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              gint id = sc->vptr->ivalue (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                gimp_vectors_get_by_id (sc->vptr->ivalue (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_number (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              item_ID = sc->vptr->ivalue (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          vector = sc->vptr->pair_car (a);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_vector (vector))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:               * n_elements != sc->vptr->list_length (sc, vector))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              if (n_elements > sc->vptr->vector_length (vector))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  pointer v_element = sc->vptr->vector_elem (vector, j);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  if (! sc->vptr->is_number (v_element))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  array[j] = (gint32) sc->vptr->ivalue (v_element);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          vector = sc->vptr->pair_car (a);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_vector (vector))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              n_elements = sc->vptr->vector_length (vector);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  pointer v_element = sc->vptr->vector_elem (vector, j);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  if (!sc->vptr->is_number (v_element))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  array[j] = (guint8) sc->vptr->ivalue (v_element);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          vector = sc->vptr->pair_car (a);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_vector (vector))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              if (n_elements > sc->vptr->vector_length (vector))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  pointer v_element = sc->vptr->vector_elem (vector, j);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  if (!sc->vptr->is_number (v_element))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  array[j] = (gfloat) sc->vptr->rvalue (v_element);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                                        sc->vptr->string_value (sc->vptr->pair_car (a)),
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              g_debug ("(%s)", sc->vptr->string_value (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          else if (sc->vptr->is_list (sc, sc->vptr->pair_car (a)) &&
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                   sc->vptr->list_length (sc, sc->vptr->pair_car (a)) == 3)
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              color_list = sc->vptr->pair_car (a);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              if (sc->vptr->is_number (sc->vptr->pair_car (color_list)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                r = CLAMP (sc->vptr->ivalue (sc->vptr->pair_car (color_list)),
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              color_list = sc->vptr->pair_cdr (color_list);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              if (sc->vptr->is_number (sc->vptr->pair_car (color_list)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                g = CLAMP (sc->vptr->ivalue (sc->vptr->pair_car (color_list)),
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              color_list = sc->vptr->pair_cdr (color_list);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              if (sc->vptr->is_number (sc->vptr->pair_car (color_list)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                b = CLAMP (sc->vptr->ivalue (sc->vptr->pair_car (color_list)),
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          vector = sc->vptr->pair_car (a);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_vector (vector))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              if (n_elements > sc->vptr->vector_length (vector))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  pointer v_element = sc->vptr->vector_elem (vector, j);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  if (! (sc->vptr->is_list (sc,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                                            sc->vptr->pair_car (v_element)) &&
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                         sc->vptr->list_length (sc,
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                                                sc->vptr->pair_car (v_element)) == 3))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  color_list = sc->vptr->pair_car (v_element);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  r = CLAMP (sc->vptr->ivalue (sc->vptr->pair_car (color_list)),
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  color_list = sc->vptr->pair_cdr (color_list);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  g = CLAMP (sc->vptr->ivalue (sc->vptr->pair_car (color_list)),
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  color_list = sc->vptr->pair_cdr (color_list);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                  b = CLAMP (sc->vptr->ivalue (sc->vptr->pair_car (color_list)),
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              g_debug ("color vector has %ld elements", sc->vptr->vector_length (vector));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_list (sc, sc->vptr->pair_car (a)) ||
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              sc->vptr->list_length (sc, sc->vptr->pair_car (a)) != 3)
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              temp_val = sc->vptr->pair_car (a);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              if (! sc->vptr->is_string (sc->vptr->pair_car (temp_val)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                sc->vptr->string_value (sc->vptr->pair_car (temp_val));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              temp_val = sc->vptr->pair_cdr (temp_val);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              if (! sc->vptr->is_number (sc->vptr->pair_car (temp_val)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                sc->vptr->ivalue (sc->vptr->pair_car (temp_val));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              temp_val = sc->vptr->pair_cdr (temp_val);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              if (!sc->vptr->is_string (sc->vptr->pair_car (temp_val)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                sc->vptr->string_value (sc->vptr->pair_car (temp_val));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          vector = sc->vptr->pair_car (a);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (sc->vptr->is_vector (vector))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:                                       sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:          if (! sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:              const gchar  *name = sc->vptr->string_value (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:        /* return_val can be sc->NIL */
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  if (return_val == sc->NIL)
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:        return_val = sc->vptr->cons (sc, sc->T, sc->NIL);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:        return_val = sc->vptr->cons (sc, sc->F, sc->NIL);
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  return sc->NIL;
plug-ins/script-fu/libscriptfu/scheme-wrapper.c:  return sc->NIL;
plug-ins/script-fu/libscriptfu/script-fu-register.c:  name = sc->vptr->string_value (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/script-fu-register.c:  a = sc->vptr->pair_cdr (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:  menu_label = sc->vptr->string_value (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/script-fu-register.c:  a = sc->vptr->pair_cdr (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:  blurb = sc->vptr->string_value (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/script-fu-register.c:  a = sc->vptr->pair_cdr (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:  author = sc->vptr->string_value (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/script-fu-register.c:  a = sc->vptr->pair_cdr (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:  copyright = sc->vptr->string_value (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/script-fu-register.c:  a = sc->vptr->pair_cdr (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:  date = sc->vptr->string_value (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/script-fu-register.c:  a = sc->vptr->pair_cdr (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:  if (sc->vptr->is_pair (a))
plug-ins/script-fu/libscriptfu/script-fu-register.c:      image_types = sc->vptr->string_value (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/script-fu-register.c:      a = sc->vptr->pair_cdr (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:      image_types = sc->vptr->string_value (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:      a = sc->NIL;
plug-ins/script-fu/libscriptfu/script-fu-register.c:  n_args = sc->vptr->list_length (sc, a) / 3;
plug-ins/script-fu/libscriptfu/script-fu-register.c:      if (a != sc->NIL)
plug-ins/script-fu/libscriptfu/script-fu-register.c:          if (!sc->vptr->is_integer (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:          arg->type = sc->vptr->ivalue (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/script-fu-register.c:          a = sc->vptr->pair_cdr (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:      if (a != sc->NIL)
plug-ins/script-fu/libscriptfu/script-fu-register.c:          if (!sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:          arg->label = g_strdup (sc->vptr->string_value (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/script-fu-register.c:          a = sc->vptr->pair_cdr (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:      if (a != sc->NIL)
plug-ins/script-fu/libscriptfu/script-fu-register.c:              if (!sc->vptr->is_integer (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                sc->vptr->ivalue (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/script-fu-register.c:              if (sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                                            sc->vptr->string_value (sc->vptr->pair_car (a)),
plug-ins/script-fu/libscriptfu/script-fu-register.c:              else if (sc->vptr->is_list (sc, sc->vptr->pair_car (a)) &&
plug-ins/script-fu/libscriptfu/script-fu-register.c:                       sc->vptr->list_length(sc, sc->vptr->pair_car (a)) == 3)
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  color_list = sc->vptr->pair_car (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  r = CLAMP (sc->vptr->ivalue (sc->vptr->pair_car (color_list)), 0, 255);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  color_list = sc->vptr->pair_cdr (color_list);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  g = CLAMP (sc->vptr->ivalue (sc->vptr->pair_car (color_list)), 0, 255);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  color_list = sc->vptr->pair_cdr (color_list);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  b = CLAMP (sc->vptr->ivalue (sc->vptr->pair_car (color_list)), 0, 255);
plug-ins/script-fu/libscriptfu/script-fu-register.c:              if (!sc->vptr->is_integer (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                (sc->vptr->ivalue (sc->vptr->pair_car (a))) ? TRUE : FALSE;
plug-ins/script-fu/libscriptfu/script-fu-register.c:              if (!sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                g_strdup (sc->vptr->string_value (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/script-fu-register.c:              if (!sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                g_strdup (sc->vptr->string_value (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                if (!sc->vptr->is_list (sc, a))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                adj_list = sc->vptr->pair_car (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  sc->vptr->rvalue (sc->vptr->pair_car (adj_list));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                adj_list = sc->vptr->pair_cdr (adj_list);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  sc->vptr->rvalue (sc->vptr->pair_car (adj_list));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                adj_list = sc->vptr->pair_cdr (adj_list);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  sc->vptr->rvalue (sc->vptr->pair_car (adj_list));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                adj_list = sc->vptr->pair_cdr (adj_list);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  sc->vptr->rvalue (sc->vptr->pair_car (adj_list));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                adj_list = sc->vptr->pair_cdr (adj_list);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  sc->vptr->rvalue (sc->vptr->pair_car (adj_list));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                adj_list = sc->vptr->pair_cdr (adj_list);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  sc->vptr->ivalue (sc->vptr->pair_car (adj_list));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                adj_list = sc->vptr->pair_cdr (adj_list);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  sc->vptr->ivalue (sc->vptr->pair_car (adj_list));
plug-ins/script-fu/libscriptfu/script-fu-register.c:              if (!sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:              if (!sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                g_strdup (sc->vptr->string_value (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/script-fu-register.c:              if (!sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                g_strdup (sc->vptr->string_value (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/script-fu-register.c:              if (!sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                g_strdup (sc->vptr->string_value (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/script-fu-register.c:              if (!sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                g_strdup (sc->vptr->string_value (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                if (!sc->vptr->is_list (sc, a))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                brush_list = sc->vptr->pair_car (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  g_strdup (sc->vptr->string_value (sc->vptr->pair_car (brush_list)));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                brush_list = sc->vptr->pair_cdr (brush_list);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  sc->vptr->rvalue (sc->vptr->pair_car (brush_list));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                brush_list = sc->vptr->pair_cdr (brush_list);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  sc->vptr->ivalue (sc->vptr->pair_car (brush_list));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                brush_list = sc->vptr->pair_cdr (brush_list);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  sc->vptr->ivalue (sc->vptr->pair_car (brush_list));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                brush_list = sc->vptr->pair_car (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                  g_strdup (sc->vptr->string_value (sc->vptr->pair_car (brush_list)));
plug-ins/script-fu/libscriptfu/script-fu-register.c:              if (!sc->vptr->is_string (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                g_strdup (sc->vptr->string_value (sc->vptr->pair_car (a)));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                if (!sc->vptr->is_list (sc, a))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                for (option_list = sc->vptr->pair_car (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                     option_list != sc->NIL;
plug-ins/script-fu/libscriptfu/script-fu-register.c:                     option_list = sc->vptr->pair_cdr (option_list))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                                      g_strdup (sc->vptr->string_value
plug-ins/script-fu/libscriptfu/script-fu-register.c:                                                (sc->vptr->pair_car (option_list))));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                if (!sc->vptr->is_list (sc, a))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                option_list = sc->vptr->pair_car (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                if (!sc->vptr->is_string (sc->vptr->pair_car (option_list)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                val = sc->vptr->string_value (sc->vptr->pair_car (option_list));
plug-ins/script-fu/libscriptfu/script-fu-register.c:                option_list = sc->vptr->pair_cdr (option_list);
plug-ins/script-fu/libscriptfu/script-fu-register.c:                if (!sc->vptr->is_string (sc->vptr->pair_car (option_list)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:                                            sc->vptr->string_value (sc->vptr->pair_car (option_list)));
plug-ins/script-fu/libscriptfu/script-fu-register.c:          a = sc->vptr->pair_cdr (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:  return sc->NIL;
plug-ins/script-fu/libscriptfu/script-fu-register.c:  if (!sc->vptr->is_integer (sc->vptr->pair_car (a)))
plug-ins/script-fu/libscriptfu/script-fu-register.c:  script->drawable_arity = sc->vptr->ivalue (sc->vptr->pair_car (a));
plug-ins/script-fu/libscriptfu/script-fu-register.c:  a = sc->vptr->pair_cdr (a);
plug-ins/script-fu/libscriptfu/script-fu-register.c:  return sc->NIL;
po/ka.po:"   Esc-.    "
